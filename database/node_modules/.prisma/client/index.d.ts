import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  sqltag as sql,
  empty,
  join,
  raw,
} from '@prisma/client/runtime';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }

/**
 * Re-export of sql-template-tag
 */
export { sql, empty, join, raw }

/**
 * Prisma Client JS version: 2.3.0
 * Query Engine version: e11114fa1ea826f9e7b4fa1ced34e78892fe8e0e
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export declare type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export declare type InputJsonObject = {[Key in string]?: JsonValue}
 
export declare interface InputJsonArray extends Array<JsonValue> {}
 
export declare type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}

declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export declare type TrueKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}


/**
 * Client
**/

export declare type Datasource = {
  url?: string
}

export type Datasources = {
  db?: Datasource
}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * ```
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends Array<LogLevel | LogDefinition>> = GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]> 

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type Action =
  | 'findOne'
  | 'findMany'
  | 'create'
  | 'update'
  | 'updateMany'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'

/**
 * These options are being passed in to the middleware as "params"
 */
export type MiddlewareParams = {
  model?: string
  action: Action
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

/**
 * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
 */
export type Middleware<T = any> = (
  params: MiddlewareParams,
  next: (params: MiddlewareParams) => Promise<T>,
) => Promise<T>

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Nodes
 * const nodes = await prisma.node.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md).
 */
export declare class PrismaClient<
  T extends PrismaClientOptions = PrismaClientOptions,
  U = keyof T extends 'log' ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

  /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Nodes
   * const nodes = await prisma.node.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md).
   */
  constructor(optionsArg?: T);
  on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  connect(): Promise<void>;
  /**
   * @private
   */
  private runDisconnect;
  /**
   * Disconnect from the database
   */
  disconnect(): Promise<any>;

  
  /**
   * Add a middleware
   */
  use(cb: Middleware): void
  

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md#raw-database-access).
  */
  executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md#raw-database-access).
  */
  queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;

  /**
   * Execute queries in a transaction
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   */
  transaction: PromiseConstructor['all']

  /**
   * `prisma.node`: Exposes CRUD operations for the **Node** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nodes
    * const nodes = await prisma.node.findMany()
    * ```
    */
  get node(): NodeDelegate;

  /**
   * `prisma.workspace`: Exposes CRUD operations for the **Workspace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workspaces
    * const workspaces = await prisma.workspace.findMany()
    * ```
    */
  get workspace(): WorkspaceDelegate;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): UserDelegate;

  /**
   * `prisma.pipeline`: Exposes CRUD operations for the **Pipeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pipelines
    * const pipelines = await prisma.pipeline.findMany()
    * ```
    */
  get pipeline(): PipelineDelegate;

  /**
   * `prisma.stage`: Exposes CRUD operations for the **Stage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stages
    * const stages = await prisma.stage.findMany()
    * ```
    */
  get stage(): StageDelegate;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): ReviewDelegate;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): ClientDelegate;

  /**
   * `prisma.candidate`: Exposes CRUD operations for the **Candidate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Candidates
    * const candidates = await prisma.candidate.findMany()
    * ```
    */
  get candidate(): CandidateDelegate;

  /**
   * `prisma.fieldDefinition`: Exposes CRUD operations for the **FieldDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FieldDefinitions
    * const fieldDefinitions = await prisma.fieldDefinition.findMany()
    * ```
    */
  get fieldDefinition(): FieldDefinitionDelegate;

  /**
   * `prisma.fieldValue`: Exposes CRUD operations for the **FieldValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FieldValues
    * const fieldValues = await prisma.fieldValue.findMany()
    * ```
    */
  get fieldValue(): FieldValueDelegate;

  /**
   * `prisma.application`: Exposes CRUD operations for the **Application** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applications
    * const applications = await prisma.application.findMany()
    * ```
    */
  get application(): ApplicationDelegate;

  /**
   * `prisma.job`: Exposes CRUD operations for the **Job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): JobDelegate;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): LocationDelegate;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): TagDelegate;

  /**
   * `prisma.source`: Exposes CRUD operations for the **Source** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sources
    * const sources = await prisma.source.findMany()
    * ```
    */
  get source(): SourceDelegate;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): CommentDelegate;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): AppointmentDelegate;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): EventDelegate;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): NotificationDelegate;
}



/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export declare const OrderByArg: {
  asc: 'asc',
  desc: 'desc'
};

export declare type OrderByArg = (typeof OrderByArg)[keyof typeof OrderByArg]


export declare const WorkspaceType: {
  FREE: 'FREE'
};

export declare type WorkspaceType = (typeof WorkspaceType)[keyof typeof WorkspaceType]


export declare const JobStatus: {
  DRAFT: 'DRAFT',
  OPEN: 'OPEN',
  CLOSED: 'CLOSED'
};

export declare type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]


export declare const FieldType: {
  TEXT: 'TEXT',
  TEXTAREA: 'TEXTAREA',
  NUMBER: 'NUMBER',
  SCORE: 'SCORE',
  BOOLEAN: 'BOOLEAN'
};

export declare type FieldType = (typeof FieldType)[keyof typeof FieldType]


export declare const TagType: {
  CANDIDATE: 'CANDIDATE',
  APPLICATION: 'APPLICATION',
  JOB: 'JOB'
};

export declare type TagType = (typeof TagType)[keyof typeof TagType]



/**
 * Model Node
 */

export type Node = {
  id: string
}


export type AggregateNode = {
  count: number
}



export type AggregateNodeArgs = {
  where?: NodeWhereInput
  orderBy?: NodeOrderByInput
  cursor?: NodeWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetNodeAggregateType<T extends AggregateNodeArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type NodeSelect = {
  id?: boolean
  user?: boolean | UserArgs
  client?: boolean | ClientArgs
  candidate?: boolean | CandidateArgs
  application?: boolean | ApplicationArgs
  job?: boolean | JobArgs
  tag?: boolean | TagArgs
  comment?: boolean | CommentArgs
  source?: boolean | SourceArgs
  pipeline?: boolean | PipelineArgs
  stage?: boolean | StageArgs
  location?: boolean | LocationArgs
  review?: boolean | ReviewArgs
  event?: boolean | EventArgs
  appointment?: boolean | AppointmentArgs
  notification?: boolean | NotificationArgs
  field?: boolean | FieldDefinitionArgs
  workspace?: boolean | WorkspaceArgs
}

export type NodeInclude = {
  user?: boolean | UserArgs
  client?: boolean | ClientArgs
  candidate?: boolean | CandidateArgs
  application?: boolean | ApplicationArgs
  job?: boolean | JobArgs
  tag?: boolean | TagArgs
  comment?: boolean | CommentArgs
  source?: boolean | SourceArgs
  pipeline?: boolean | PipelineArgs
  stage?: boolean | StageArgs
  location?: boolean | LocationArgs
  review?: boolean | ReviewArgs
  event?: boolean | EventArgs
  appointment?: boolean | AppointmentArgs
  notification?: boolean | NotificationArgs
  field?: boolean | FieldDefinitionArgs
  workspace?: boolean | WorkspaceArgs
}

export type NodeGetPayload<
  S extends boolean | null | undefined | NodeArgs,
  U = keyof S
> = S extends true
  ? Node
  : S extends undefined
  ? never
  : S extends NodeArgs | FindManyNodeArgs
  ? 'include' extends U
    ? Node  & {
      [P in TrueKeys<S['include']>]:
      P extends 'user'
      ? UserGetPayload<S['include'][P]> | null :
      P extends 'client'
      ? ClientGetPayload<S['include'][P]> | null :
      P extends 'candidate'
      ? CandidateGetPayload<S['include'][P]> | null :
      P extends 'application'
      ? ApplicationGetPayload<S['include'][P]> | null :
      P extends 'job'
      ? JobGetPayload<S['include'][P]> | null :
      P extends 'tag'
      ? TagGetPayload<S['include'][P]> | null :
      P extends 'comment'
      ? CommentGetPayload<S['include'][P]> | null :
      P extends 'source'
      ? SourceGetPayload<S['include'][P]> | null :
      P extends 'pipeline'
      ? PipelineGetPayload<S['include'][P]> | null :
      P extends 'stage'
      ? StageGetPayload<S['include'][P]> | null :
      P extends 'location'
      ? LocationGetPayload<S['include'][P]> | null :
      P extends 'review'
      ? ReviewGetPayload<S['include'][P]> | null :
      P extends 'event'
      ? EventGetPayload<S['include'][P]> | null :
      P extends 'appointment'
      ? AppointmentGetPayload<S['include'][P]> | null :
      P extends 'notification'
      ? NotificationGetPayload<S['include'][P]> | null :
      P extends 'field'
      ? FieldDefinitionGetPayload<S['include'][P]> | null :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Node ? Node[P]
: 
      P extends 'user'
      ? UserGetPayload<S['select'][P]> | null :
      P extends 'client'
      ? ClientGetPayload<S['select'][P]> | null :
      P extends 'candidate'
      ? CandidateGetPayload<S['select'][P]> | null :
      P extends 'application'
      ? ApplicationGetPayload<S['select'][P]> | null :
      P extends 'job'
      ? JobGetPayload<S['select'][P]> | null :
      P extends 'tag'
      ? TagGetPayload<S['select'][P]> | null :
      P extends 'comment'
      ? CommentGetPayload<S['select'][P]> | null :
      P extends 'source'
      ? SourceGetPayload<S['select'][P]> | null :
      P extends 'pipeline'
      ? PipelineGetPayload<S['select'][P]> | null :
      P extends 'stage'
      ? StageGetPayload<S['select'][P]> | null :
      P extends 'location'
      ? LocationGetPayload<S['select'][P]> | null :
      P extends 'review'
      ? ReviewGetPayload<S['select'][P]> | null :
      P extends 'event'
      ? EventGetPayload<S['select'][P]> | null :
      P extends 'appointment'
      ? AppointmentGetPayload<S['select'][P]> | null :
      P extends 'notification'
      ? NotificationGetPayload<S['select'][P]> | null :
      P extends 'field'
      ? FieldDefinitionGetPayload<S['select'][P]> | null :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['select'][P]> | null : never
    }
  : Node
: Node


export interface NodeDelegate {
  /**
   * Find zero or one Node.
   * @param {FindOneNodeArgs} args - Arguments to find a Node
   * @example
   * // Get one Node
   * const node = await prisma.node.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneNodeArgs>(
    args: Subset<T, FindOneNodeArgs>
  ): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>
  /**
   * Find zero or more Nodes.
   * @param {FindManyNodeArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Nodes
   * const nodes = await prisma.node.findMany()
   * 
   * // Get first 10 Nodes
   * const nodes = await prisma.node.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const nodeWithIdOnly = await prisma.node.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyNodeArgs>(
    args?: Subset<T, FindManyNodeArgs>
  ): CheckSelect<T, Promise<Array<Node>>, Promise<Array<NodeGetPayload<T>>>>
  /**
   * Create a Node.
   * @param {NodeCreateArgs} args - Arguments to create a Node.
   * @example
   * // Create one Node
   * const Node = await prisma.node.create({
   *   data: {
   *     // ... data to create a Node
   *   }
   * })
   * 
  **/
  create<T extends NodeCreateArgs>(
    args: Subset<T, NodeCreateArgs>
  ): CheckSelect<T, Prisma__NodeClient<Node>, Prisma__NodeClient<NodeGetPayload<T>>>
  /**
   * Delete a Node.
   * @param {NodeDeleteArgs} args - Arguments to delete one Node.
   * @example
   * // Delete one Node
   * const Node = await prisma.node.delete({
   *   where: {
   *     // ... filter to delete one Node
   *   }
   * })
   * 
  **/
  delete<T extends NodeDeleteArgs>(
    args: Subset<T, NodeDeleteArgs>
  ): CheckSelect<T, Prisma__NodeClient<Node>, Prisma__NodeClient<NodeGetPayload<T>>>
  /**
   * Update one Node.
   * @param {NodeUpdateArgs} args - Arguments to update one Node.
   * @example
   * // Update one Node
   * const node = await prisma.node.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends NodeUpdateArgs>(
    args: Subset<T, NodeUpdateArgs>
  ): CheckSelect<T, Prisma__NodeClient<Node>, Prisma__NodeClient<NodeGetPayload<T>>>
  /**
   * Delete zero or more Nodes.
   * @param {NodeDeleteManyArgs} args - Arguments to filter Nodes to delete.
   * @example
   * // Delete a few Nodes
   * const { count } = await prisma.node.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends NodeDeleteManyArgs>(
    args: Subset<T, NodeDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Nodes.
   * @param {NodeUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Nodes
   * const node = await prisma.node.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends NodeUpdateManyArgs>(
    args: Subset<T, NodeUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Node.
   * @param {NodeUpsertArgs} args - Arguments to update or create a Node.
   * @example
   * // Update or create a Node
   * const node = await prisma.node.upsert({
   *   create: {
   *     // ... data to create a Node
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Node we want to update
   *   }
   * })
  **/
  upsert<T extends NodeUpsertArgs>(
    args: Subset<T, NodeUpsertArgs>
  ): CheckSelect<T, Prisma__NodeClient<Node>, Prisma__NodeClient<NodeGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyNodeArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateNodeArgs>(args: Subset<T, AggregateNodeArgs>): Promise<GetNodeAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for Node.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__NodeClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

  client<T extends ClientArgs = {}>(args?: Subset<T, ClientArgs>): CheckSelect<T, Prisma__ClientClient<Client | null>, Prisma__ClientClient<ClientGetPayload<T> | null>>;

  candidate<T extends CandidateArgs = {}>(args?: Subset<T, CandidateArgs>): CheckSelect<T, Prisma__CandidateClient<Candidate | null>, Prisma__CandidateClient<CandidateGetPayload<T> | null>>;

  application<T extends ApplicationArgs = {}>(args?: Subset<T, ApplicationArgs>): CheckSelect<T, Prisma__ApplicationClient<Application | null>, Prisma__ApplicationClient<ApplicationGetPayload<T> | null>>;

  job<T extends JobArgs = {}>(args?: Subset<T, JobArgs>): CheckSelect<T, Prisma__JobClient<Job | null>, Prisma__JobClient<JobGetPayload<T> | null>>;

  tag<T extends TagArgs = {}>(args?: Subset<T, TagArgs>): CheckSelect<T, Prisma__TagClient<Tag | null>, Prisma__TagClient<TagGetPayload<T> | null>>;

  comment<T extends CommentArgs = {}>(args?: Subset<T, CommentArgs>): CheckSelect<T, Prisma__CommentClient<Comment | null>, Prisma__CommentClient<CommentGetPayload<T> | null>>;

  source<T extends SourceArgs = {}>(args?: Subset<T, SourceArgs>): CheckSelect<T, Prisma__SourceClient<Source | null>, Prisma__SourceClient<SourceGetPayload<T> | null>>;

  pipeline<T extends PipelineArgs = {}>(args?: Subset<T, PipelineArgs>): CheckSelect<T, Prisma__PipelineClient<Pipeline | null>, Prisma__PipelineClient<PipelineGetPayload<T> | null>>;

  stage<T extends StageArgs = {}>(args?: Subset<T, StageArgs>): CheckSelect<T, Prisma__StageClient<Stage | null>, Prisma__StageClient<StageGetPayload<T> | null>>;

  location<T extends LocationArgs = {}>(args?: Subset<T, LocationArgs>): CheckSelect<T, Prisma__LocationClient<Location | null>, Prisma__LocationClient<LocationGetPayload<T> | null>>;

  review<T extends ReviewArgs = {}>(args?: Subset<T, ReviewArgs>): CheckSelect<T, Prisma__ReviewClient<Review | null>, Prisma__ReviewClient<ReviewGetPayload<T> | null>>;

  event<T extends EventArgs = {}>(args?: Subset<T, EventArgs>): CheckSelect<T, Prisma__EventClient<Event | null>, Prisma__EventClient<EventGetPayload<T> | null>>;

  appointment<T extends AppointmentArgs = {}>(args?: Subset<T, AppointmentArgs>): CheckSelect<T, Prisma__AppointmentClient<Appointment | null>, Prisma__AppointmentClient<AppointmentGetPayload<T> | null>>;

  notification<T extends NotificationArgs = {}>(args?: Subset<T, NotificationArgs>): CheckSelect<T, Prisma__NotificationClient<Notification | null>, Prisma__NotificationClient<NotificationGetPayload<T> | null>>;

  field<T extends FieldDefinitionArgs = {}>(args?: Subset<T, FieldDefinitionArgs>): CheckSelect<T, Prisma__FieldDefinitionClient<FieldDefinition | null>, Prisma__FieldDefinitionClient<FieldDefinitionGetPayload<T> | null>>;

  workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Node findOne
 */
export type FindOneNodeArgs = {
  /**
   * Select specific fields to fetch from the Node
  **/
  select?: NodeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NodeInclude | null
  /**
   * Filter, which Node to fetch.
  **/
  where: NodeWhereUniqueInput
}


/**
 * Node findMany
 */
export type FindManyNodeArgs = {
  /**
   * Select specific fields to fetch from the Node
  **/
  select?: NodeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NodeInclude | null
  /**
   * Filter, which Nodes to fetch.
  **/
  where?: NodeWhereInput
  /**
   * Determine the order of the Nodes to fetch.
  **/
  orderBy?: NodeOrderByInput
  /**
   * Sets the position for listing Nodes.
  **/
  cursor?: NodeWhereUniqueInput
  /**
   * The number of Nodes to fetch. If negative number, it will take Nodes before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Nodes.
  **/
  skip?: number
}


/**
 * Node create
 */
export type NodeCreateArgs = {
  /**
   * Select specific fields to fetch from the Node
  **/
  select?: NodeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NodeInclude | null
  /**
   * The data needed to create a Node.
  **/
  data: NodeCreateInput
}


/**
 * Node update
 */
export type NodeUpdateArgs = {
  /**
   * Select specific fields to fetch from the Node
  **/
  select?: NodeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NodeInclude | null
  /**
   * The data needed to update a Node.
  **/
  data: NodeUpdateInput
  /**
   * Choose, which Node to update.
  **/
  where: NodeWhereUniqueInput
}


/**
 * Node updateMany
 */
export type NodeUpdateManyArgs = {
  data: NodeUpdateManyMutationInput
  where?: NodeWhereInput
}


/**
 * Node upsert
 */
export type NodeUpsertArgs = {
  /**
   * Select specific fields to fetch from the Node
  **/
  select?: NodeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NodeInclude | null
  /**
   * The filter to search for the Node to update in case it exists.
  **/
  where: NodeWhereUniqueInput
  /**
   * In case the Node found by the `where` argument doesn't exist, create a new Node with this data.
  **/
  create: NodeCreateInput
  /**
   * In case the Node was found with the provided `where` argument, update it with this data.
  **/
  update: NodeUpdateInput
}


/**
 * Node delete
 */
export type NodeDeleteArgs = {
  /**
   * Select specific fields to fetch from the Node
  **/
  select?: NodeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NodeInclude | null
  /**
   * Filter which Node to delete.
  **/
  where: NodeWhereUniqueInput
}


/**
 * Node deleteMany
 */
export type NodeDeleteManyArgs = {
  where?: NodeWhereInput
}


/**
 * Node without action
 */
export type NodeArgs = {
  /**
   * Select specific fields to fetch from the Node
  **/
  select?: NodeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NodeInclude | null
}



/**
 * Model Workspace
 */

export type Workspace = {
  id: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
  name: string
  description: string | null
  website: string | null
  type: WorkspaceType
}


export type AggregateWorkspace = {
  count: number
}



export type AggregateWorkspaceArgs = {
  where?: WorkspaceWhereInput
  orderBy?: WorkspaceOrderByInput
  cursor?: WorkspaceWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetWorkspaceAggregateType<T extends AggregateWorkspaceArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type WorkspaceSelect = {
  id?: boolean
  node?: boolean | NodeArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  name?: boolean
  description?: boolean
  website?: boolean
  type?: boolean
  users?: boolean | FindManyUserArgs
  clients?: boolean | FindManyClientArgs
  candidates?: boolean | FindManyCandidateArgs
  applications?: boolean | FindManyApplicationArgs
  job?: boolean | FindManyJobArgs
  tags?: boolean | FindManyTagArgs
  sources?: boolean | FindManySourceArgs
  comments?: boolean | FindManyCommentArgs
  pipelines?: boolean | FindManyPipelineArgs
  stages?: boolean | FindManyStageArgs
  locations?: boolean | FindManyLocationArgs
  reviews?: boolean | FindManyReviewArgs
  event?: boolean | FindManyEventArgs
  appointment?: boolean | FindManyAppointmentArgs
  notification?: boolean | FindManyNotificationArgs
  fields?: boolean | FindManyFieldDefinitionArgs
}

export type WorkspaceInclude = {
  node?: boolean | NodeArgs
  users?: boolean | FindManyUserArgs
  clients?: boolean | FindManyClientArgs
  candidates?: boolean | FindManyCandidateArgs
  applications?: boolean | FindManyApplicationArgs
  job?: boolean | FindManyJobArgs
  tags?: boolean | FindManyTagArgs
  sources?: boolean | FindManySourceArgs
  comments?: boolean | FindManyCommentArgs
  pipelines?: boolean | FindManyPipelineArgs
  stages?: boolean | FindManyStageArgs
  locations?: boolean | FindManyLocationArgs
  reviews?: boolean | FindManyReviewArgs
  event?: boolean | FindManyEventArgs
  appointment?: boolean | FindManyAppointmentArgs
  notification?: boolean | FindManyNotificationArgs
  fields?: boolean | FindManyFieldDefinitionArgs
}

export type WorkspaceGetPayload<
  S extends boolean | null | undefined | WorkspaceArgs,
  U = keyof S
> = S extends true
  ? Workspace
  : S extends undefined
  ? never
  : S extends WorkspaceArgs | FindManyWorkspaceArgs
  ? 'include' extends U
    ? Workspace  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'users'
      ? Array<UserGetPayload<S['include'][P]>> :
      P extends 'clients'
      ? Array<ClientGetPayload<S['include'][P]>> :
      P extends 'candidates'
      ? Array<CandidateGetPayload<S['include'][P]>> :
      P extends 'applications'
      ? Array<ApplicationGetPayload<S['include'][P]>> :
      P extends 'job'
      ? Array<JobGetPayload<S['include'][P]>> :
      P extends 'tags'
      ? Array<TagGetPayload<S['include'][P]>> :
      P extends 'sources'
      ? Array<SourceGetPayload<S['include'][P]>> :
      P extends 'comments'
      ? Array<CommentGetPayload<S['include'][P]>> :
      P extends 'pipelines'
      ? Array<PipelineGetPayload<S['include'][P]>> :
      P extends 'stages'
      ? Array<StageGetPayload<S['include'][P]>> :
      P extends 'locations'
      ? Array<LocationGetPayload<S['include'][P]>> :
      P extends 'reviews'
      ? Array<ReviewGetPayload<S['include'][P]>> :
      P extends 'event'
      ? Array<EventGetPayload<S['include'][P]>> :
      P extends 'appointment'
      ? Array<AppointmentGetPayload<S['include'][P]>> :
      P extends 'notification'
      ? Array<NotificationGetPayload<S['include'][P]>> :
      P extends 'fields'
      ? Array<FieldDefinitionGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Workspace ? Workspace[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'users'
      ? Array<UserGetPayload<S['select'][P]>> :
      P extends 'clients'
      ? Array<ClientGetPayload<S['select'][P]>> :
      P extends 'candidates'
      ? Array<CandidateGetPayload<S['select'][P]>> :
      P extends 'applications'
      ? Array<ApplicationGetPayload<S['select'][P]>> :
      P extends 'job'
      ? Array<JobGetPayload<S['select'][P]>> :
      P extends 'tags'
      ? Array<TagGetPayload<S['select'][P]>> :
      P extends 'sources'
      ? Array<SourceGetPayload<S['select'][P]>> :
      P extends 'comments'
      ? Array<CommentGetPayload<S['select'][P]>> :
      P extends 'pipelines'
      ? Array<PipelineGetPayload<S['select'][P]>> :
      P extends 'stages'
      ? Array<StageGetPayload<S['select'][P]>> :
      P extends 'locations'
      ? Array<LocationGetPayload<S['select'][P]>> :
      P extends 'reviews'
      ? Array<ReviewGetPayload<S['select'][P]>> :
      P extends 'event'
      ? Array<EventGetPayload<S['select'][P]>> :
      P extends 'appointment'
      ? Array<AppointmentGetPayload<S['select'][P]>> :
      P extends 'notification'
      ? Array<NotificationGetPayload<S['select'][P]>> :
      P extends 'fields'
      ? Array<FieldDefinitionGetPayload<S['select'][P]>> : never
    }
  : Workspace
: Workspace


export interface WorkspaceDelegate {
  /**
   * Find zero or one Workspace.
   * @param {FindOneWorkspaceArgs} args - Arguments to find a Workspace
   * @example
   * // Get one Workspace
   * const workspace = await prisma.workspace.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneWorkspaceArgs>(
    args: Subset<T, FindOneWorkspaceArgs>
  ): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>
  /**
   * Find zero or more Workspaces.
   * @param {FindManyWorkspaceArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Workspaces
   * const workspaces = await prisma.workspace.findMany()
   * 
   * // Get first 10 Workspaces
   * const workspaces = await prisma.workspace.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const workspaceWithIdOnly = await prisma.workspace.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyWorkspaceArgs>(
    args?: Subset<T, FindManyWorkspaceArgs>
  ): CheckSelect<T, Promise<Array<Workspace>>, Promise<Array<WorkspaceGetPayload<T>>>>
  /**
   * Create a Workspace.
   * @param {WorkspaceCreateArgs} args - Arguments to create a Workspace.
   * @example
   * // Create one Workspace
   * const Workspace = await prisma.workspace.create({
   *   data: {
   *     // ... data to create a Workspace
   *   }
   * })
   * 
  **/
  create<T extends WorkspaceCreateArgs>(
    args: Subset<T, WorkspaceCreateArgs>
  ): CheckSelect<T, Prisma__WorkspaceClient<Workspace>, Prisma__WorkspaceClient<WorkspaceGetPayload<T>>>
  /**
   * Delete a Workspace.
   * @param {WorkspaceDeleteArgs} args - Arguments to delete one Workspace.
   * @example
   * // Delete one Workspace
   * const Workspace = await prisma.workspace.delete({
   *   where: {
   *     // ... filter to delete one Workspace
   *   }
   * })
   * 
  **/
  delete<T extends WorkspaceDeleteArgs>(
    args: Subset<T, WorkspaceDeleteArgs>
  ): CheckSelect<T, Prisma__WorkspaceClient<Workspace>, Prisma__WorkspaceClient<WorkspaceGetPayload<T>>>
  /**
   * Update one Workspace.
   * @param {WorkspaceUpdateArgs} args - Arguments to update one Workspace.
   * @example
   * // Update one Workspace
   * const workspace = await prisma.workspace.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends WorkspaceUpdateArgs>(
    args: Subset<T, WorkspaceUpdateArgs>
  ): CheckSelect<T, Prisma__WorkspaceClient<Workspace>, Prisma__WorkspaceClient<WorkspaceGetPayload<T>>>
  /**
   * Delete zero or more Workspaces.
   * @param {WorkspaceDeleteManyArgs} args - Arguments to filter Workspaces to delete.
   * @example
   * // Delete a few Workspaces
   * const { count } = await prisma.workspace.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends WorkspaceDeleteManyArgs>(
    args: Subset<T, WorkspaceDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Workspaces.
   * @param {WorkspaceUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Workspaces
   * const workspace = await prisma.workspace.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends WorkspaceUpdateManyArgs>(
    args: Subset<T, WorkspaceUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Workspace.
   * @param {WorkspaceUpsertArgs} args - Arguments to update or create a Workspace.
   * @example
   * // Update or create a Workspace
   * const workspace = await prisma.workspace.upsert({
   *   create: {
   *     // ... data to create a Workspace
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Workspace we want to update
   *   }
   * })
  **/
  upsert<T extends WorkspaceUpsertArgs>(
    args: Subset<T, WorkspaceUpsertArgs>
  ): CheckSelect<T, Prisma__WorkspaceClient<Workspace>, Prisma__WorkspaceClient<WorkspaceGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyWorkspaceArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateWorkspaceArgs>(args: Subset<T, AggregateWorkspaceArgs>): Promise<GetWorkspaceAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for Workspace.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__WorkspaceClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  users<T extends FindManyUserArgs = {}>(args?: Subset<T, FindManyUserArgs>): CheckSelect<T, Promise<Array<User>>, Promise<Array<UserGetPayload<T>>>>;

  clients<T extends FindManyClientArgs = {}>(args?: Subset<T, FindManyClientArgs>): CheckSelect<T, Promise<Array<Client>>, Promise<Array<ClientGetPayload<T>>>>;

  candidates<T extends FindManyCandidateArgs = {}>(args?: Subset<T, FindManyCandidateArgs>): CheckSelect<T, Promise<Array<Candidate>>, Promise<Array<CandidateGetPayload<T>>>>;

  applications<T extends FindManyApplicationArgs = {}>(args?: Subset<T, FindManyApplicationArgs>): CheckSelect<T, Promise<Array<Application>>, Promise<Array<ApplicationGetPayload<T>>>>;

  job<T extends FindManyJobArgs = {}>(args?: Subset<T, FindManyJobArgs>): CheckSelect<T, Promise<Array<Job>>, Promise<Array<JobGetPayload<T>>>>;

  tags<T extends FindManyTagArgs = {}>(args?: Subset<T, FindManyTagArgs>): CheckSelect<T, Promise<Array<Tag>>, Promise<Array<TagGetPayload<T>>>>;

  sources<T extends FindManySourceArgs = {}>(args?: Subset<T, FindManySourceArgs>): CheckSelect<T, Promise<Array<Source>>, Promise<Array<SourceGetPayload<T>>>>;

  comments<T extends FindManyCommentArgs = {}>(args?: Subset<T, FindManyCommentArgs>): CheckSelect<T, Promise<Array<Comment>>, Promise<Array<CommentGetPayload<T>>>>;

  pipelines<T extends FindManyPipelineArgs = {}>(args?: Subset<T, FindManyPipelineArgs>): CheckSelect<T, Promise<Array<Pipeline>>, Promise<Array<PipelineGetPayload<T>>>>;

  stages<T extends FindManyStageArgs = {}>(args?: Subset<T, FindManyStageArgs>): CheckSelect<T, Promise<Array<Stage>>, Promise<Array<StageGetPayload<T>>>>;

  locations<T extends FindManyLocationArgs = {}>(args?: Subset<T, FindManyLocationArgs>): CheckSelect<T, Promise<Array<Location>>, Promise<Array<LocationGetPayload<T>>>>;

  reviews<T extends FindManyReviewArgs = {}>(args?: Subset<T, FindManyReviewArgs>): CheckSelect<T, Promise<Array<Review>>, Promise<Array<ReviewGetPayload<T>>>>;

  event<T extends FindManyEventArgs = {}>(args?: Subset<T, FindManyEventArgs>): CheckSelect<T, Promise<Array<Event>>, Promise<Array<EventGetPayload<T>>>>;

  appointment<T extends FindManyAppointmentArgs = {}>(args?: Subset<T, FindManyAppointmentArgs>): CheckSelect<T, Promise<Array<Appointment>>, Promise<Array<AppointmentGetPayload<T>>>>;

  notification<T extends FindManyNotificationArgs = {}>(args?: Subset<T, FindManyNotificationArgs>): CheckSelect<T, Promise<Array<Notification>>, Promise<Array<NotificationGetPayload<T>>>>;

  fields<T extends FindManyFieldDefinitionArgs = {}>(args?: Subset<T, FindManyFieldDefinitionArgs>): CheckSelect<T, Promise<Array<FieldDefinition>>, Promise<Array<FieldDefinitionGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Workspace findOne
 */
export type FindOneWorkspaceArgs = {
  /**
   * Select specific fields to fetch from the Workspace
  **/
  select?: WorkspaceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: WorkspaceInclude | null
  /**
   * Filter, which Workspace to fetch.
  **/
  where: WorkspaceWhereUniqueInput
}


/**
 * Workspace findMany
 */
export type FindManyWorkspaceArgs = {
  /**
   * Select specific fields to fetch from the Workspace
  **/
  select?: WorkspaceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: WorkspaceInclude | null
  /**
   * Filter, which Workspaces to fetch.
  **/
  where?: WorkspaceWhereInput
  /**
   * Determine the order of the Workspaces to fetch.
  **/
  orderBy?: WorkspaceOrderByInput
  /**
   * Sets the position for listing Workspaces.
  **/
  cursor?: WorkspaceWhereUniqueInput
  /**
   * The number of Workspaces to fetch. If negative number, it will take Workspaces before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Workspaces.
  **/
  skip?: number
}


/**
 * Workspace create
 */
export type WorkspaceCreateArgs = {
  /**
   * Select specific fields to fetch from the Workspace
  **/
  select?: WorkspaceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: WorkspaceInclude | null
  /**
   * The data needed to create a Workspace.
  **/
  data: WorkspaceCreateInput
}


/**
 * Workspace update
 */
export type WorkspaceUpdateArgs = {
  /**
   * Select specific fields to fetch from the Workspace
  **/
  select?: WorkspaceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: WorkspaceInclude | null
  /**
   * The data needed to update a Workspace.
  **/
  data: WorkspaceUpdateInput
  /**
   * Choose, which Workspace to update.
  **/
  where: WorkspaceWhereUniqueInput
}


/**
 * Workspace updateMany
 */
export type WorkspaceUpdateManyArgs = {
  data: WorkspaceUpdateManyMutationInput
  where?: WorkspaceWhereInput
}


/**
 * Workspace upsert
 */
export type WorkspaceUpsertArgs = {
  /**
   * Select specific fields to fetch from the Workspace
  **/
  select?: WorkspaceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: WorkspaceInclude | null
  /**
   * The filter to search for the Workspace to update in case it exists.
  **/
  where: WorkspaceWhereUniqueInput
  /**
   * In case the Workspace found by the `where` argument doesn't exist, create a new Workspace with this data.
  **/
  create: WorkspaceCreateInput
  /**
   * In case the Workspace was found with the provided `where` argument, update it with this data.
  **/
  update: WorkspaceUpdateInput
}


/**
 * Workspace delete
 */
export type WorkspaceDeleteArgs = {
  /**
   * Select specific fields to fetch from the Workspace
  **/
  select?: WorkspaceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: WorkspaceInclude | null
  /**
   * Filter which Workspace to delete.
  **/
  where: WorkspaceWhereUniqueInput
}


/**
 * Workspace deleteMany
 */
export type WorkspaceDeleteManyArgs = {
  where?: WorkspaceWhereInput
}


/**
 * Workspace without action
 */
export type WorkspaceArgs = {
  /**
   * Select specific fields to fetch from the Workspace
  **/
  select?: WorkspaceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: WorkspaceInclude | null
}



/**
 * Model User
 */

export type User = {
  id: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
  email: string
  avatarUrl: string | null
}


export type AggregateUser = {
  count: number
}



export type AggregateUserArgs = {
  where?: UserWhereInput
  orderBy?: UserOrderByInput
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetUserAggregateType<T extends AggregateUserArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type UserSelect = {
  id?: boolean
  node?: boolean | NodeArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  email?: boolean
  avatarUrl?: boolean
  workspaces?: boolean | FindManyWorkspaceArgs
  comments?: boolean | FindManyCommentArgs
  reviews?: boolean | FindManyReviewArgs
  appointments?: boolean | FindManyAppointmentArgs
}

export type UserInclude = {
  node?: boolean | NodeArgs
  workspaces?: boolean | FindManyWorkspaceArgs
  comments?: boolean | FindManyCommentArgs
  reviews?: boolean | FindManyReviewArgs
  appointments?: boolean | FindManyAppointmentArgs
}

export type UserGetPayload<
  S extends boolean | null | undefined | UserArgs,
  U = keyof S
> = S extends true
  ? User
  : S extends undefined
  ? never
  : S extends UserArgs | FindManyUserArgs
  ? 'include' extends U
    ? User  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'workspaces'
      ? Array<WorkspaceGetPayload<S['include'][P]>> :
      P extends 'comments'
      ? Array<CommentGetPayload<S['include'][P]>> :
      P extends 'reviews'
      ? Array<ReviewGetPayload<S['include'][P]>> :
      P extends 'appointments'
      ? Array<AppointmentGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof User ? User[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'workspaces'
      ? Array<WorkspaceGetPayload<S['select'][P]>> :
      P extends 'comments'
      ? Array<CommentGetPayload<S['select'][P]>> :
      P extends 'reviews'
      ? Array<ReviewGetPayload<S['select'][P]>> :
      P extends 'appointments'
      ? Array<AppointmentGetPayload<S['select'][P]>> : never
    }
  : User
: User


export interface UserDelegate {
  /**
   * Find zero or one User.
   * @param {FindOneUserArgs} args - Arguments to find a User
   * @example
   * // Get one User
   * const user = await prisma.user.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneUserArgs>(
    args: Subset<T, FindOneUserArgs>
  ): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>
  /**
   * Find zero or more Users.
   * @param {FindManyUserArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Users
   * const users = await prisma.user.findMany()
   * 
   * // Get first 10 Users
   * const users = await prisma.user.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyUserArgs>(
    args?: Subset<T, FindManyUserArgs>
  ): CheckSelect<T, Promise<Array<User>>, Promise<Array<UserGetPayload<T>>>>
  /**
   * Create a User.
   * @param {UserCreateArgs} args - Arguments to create a User.
   * @example
   * // Create one User
   * const User = await prisma.user.create({
   *   data: {
   *     // ... data to create a User
   *   }
   * })
   * 
  **/
  create<T extends UserCreateArgs>(
    args: Subset<T, UserCreateArgs>
  ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>
  /**
   * Delete a User.
   * @param {UserDeleteArgs} args - Arguments to delete one User.
   * @example
   * // Delete one User
   * const User = await prisma.user.delete({
   *   where: {
   *     // ... filter to delete one User
   *   }
   * })
   * 
  **/
  delete<T extends UserDeleteArgs>(
    args: Subset<T, UserDeleteArgs>
  ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>
  /**
   * Update one User.
   * @param {UserUpdateArgs} args - Arguments to update one User.
   * @example
   * // Update one User
   * const user = await prisma.user.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends UserUpdateArgs>(
    args: Subset<T, UserUpdateArgs>
  ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>
  /**
   * Delete zero or more Users.
   * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
   * @example
   * // Delete a few Users
   * const { count } = await prisma.user.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends UserDeleteManyArgs>(
    args: Subset<T, UserDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Users.
   * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Users
   * const user = await prisma.user.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends UserUpdateManyArgs>(
    args: Subset<T, UserUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one User.
   * @param {UserUpsertArgs} args - Arguments to update or create a User.
   * @example
   * // Update or create a User
   * const user = await prisma.user.upsert({
   *   create: {
   *     // ... data to create a User
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the User we want to update
   *   }
   * })
  **/
  upsert<T extends UserUpsertArgs>(
    args: Subset<T, UserUpsertArgs>
  ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyUserArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateUserArgs>(args: Subset<T, AggregateUserArgs>): Promise<GetUserAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for User.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__UserClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  workspaces<T extends FindManyWorkspaceArgs = {}>(args?: Subset<T, FindManyWorkspaceArgs>): CheckSelect<T, Promise<Array<Workspace>>, Promise<Array<WorkspaceGetPayload<T>>>>;

  comments<T extends FindManyCommentArgs = {}>(args?: Subset<T, FindManyCommentArgs>): CheckSelect<T, Promise<Array<Comment>>, Promise<Array<CommentGetPayload<T>>>>;

  reviews<T extends FindManyReviewArgs = {}>(args?: Subset<T, FindManyReviewArgs>): CheckSelect<T, Promise<Array<Review>>, Promise<Array<ReviewGetPayload<T>>>>;

  appointments<T extends FindManyAppointmentArgs = {}>(args?: Subset<T, FindManyAppointmentArgs>): CheckSelect<T, Promise<Array<Appointment>>, Promise<Array<AppointmentGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * User findOne
 */
export type FindOneUserArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * Filter, which User to fetch.
  **/
  where: UserWhereUniqueInput
}


/**
 * User findMany
 */
export type FindManyUserArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * Filter, which Users to fetch.
  **/
  where?: UserWhereInput
  /**
   * Determine the order of the Users to fetch.
  **/
  orderBy?: UserOrderByInput
  /**
   * Sets the position for listing Users.
  **/
  cursor?: UserWhereUniqueInput
  /**
   * The number of Users to fetch. If negative number, it will take Users before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Users.
  **/
  skip?: number
}


/**
 * User create
 */
export type UserCreateArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * The data needed to create a User.
  **/
  data: UserCreateInput
}


/**
 * User update
 */
export type UserUpdateArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * The data needed to update a User.
  **/
  data: UserUpdateInput
  /**
   * Choose, which User to update.
  **/
  where: UserWhereUniqueInput
}


/**
 * User updateMany
 */
export type UserUpdateManyArgs = {
  data: UserUpdateManyMutationInput
  where?: UserWhereInput
}


/**
 * User upsert
 */
export type UserUpsertArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * The filter to search for the User to update in case it exists.
  **/
  where: UserWhereUniqueInput
  /**
   * In case the User found by the `where` argument doesn't exist, create a new User with this data.
  **/
  create: UserCreateInput
  /**
   * In case the User was found with the provided `where` argument, update it with this data.
  **/
  update: UserUpdateInput
}


/**
 * User delete
 */
export type UserDeleteArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * Filter which User to delete.
  **/
  where: UserWhereUniqueInput
}


/**
 * User deleteMany
 */
export type UserDeleteManyArgs = {
  where?: UserWhereInput
}


/**
 * User without action
 */
export type UserArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
}



/**
 * Model Pipeline
 */

export type Pipeline = {
  id: string
  wid: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
}


export type AggregatePipeline = {
  count: number
}



export type AggregatePipelineArgs = {
  where?: PipelineWhereInput
  orderBy?: PipelineOrderByInput
  cursor?: PipelineWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetPipelineAggregateType<T extends AggregatePipelineArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type PipelineSelect = {
  id?: boolean
  wid?: boolean
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  stages?: boolean | FindManyStageArgs
}

export type PipelineInclude = {
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  stages?: boolean | FindManyStageArgs
}

export type PipelineGetPayload<
  S extends boolean | null | undefined | PipelineArgs,
  U = keyof S
> = S extends true
  ? Pipeline
  : S extends undefined
  ? never
  : S extends PipelineArgs | FindManyPipelineArgs
  ? 'include' extends U
    ? Pipeline  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['include'][P]> :
      P extends 'stages'
      ? Array<StageGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Pipeline ? Pipeline[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['select'][P]> :
      P extends 'stages'
      ? Array<StageGetPayload<S['select'][P]>> : never
    }
  : Pipeline
: Pipeline


export interface PipelineDelegate {
  /**
   * Find zero or one Pipeline.
   * @param {FindOnePipelineArgs} args - Arguments to find a Pipeline
   * @example
   * // Get one Pipeline
   * const pipeline = await prisma.pipeline.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnePipelineArgs>(
    args: Subset<T, FindOnePipelineArgs>
  ): CheckSelect<T, Prisma__PipelineClient<Pipeline | null>, Prisma__PipelineClient<PipelineGetPayload<T> | null>>
  /**
   * Find zero or more Pipelines.
   * @param {FindManyPipelineArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Pipelines
   * const pipelines = await prisma.pipeline.findMany()
   * 
   * // Get first 10 Pipelines
   * const pipelines = await prisma.pipeline.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const pipelineWithIdOnly = await prisma.pipeline.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyPipelineArgs>(
    args?: Subset<T, FindManyPipelineArgs>
  ): CheckSelect<T, Promise<Array<Pipeline>>, Promise<Array<PipelineGetPayload<T>>>>
  /**
   * Create a Pipeline.
   * @param {PipelineCreateArgs} args - Arguments to create a Pipeline.
   * @example
   * // Create one Pipeline
   * const Pipeline = await prisma.pipeline.create({
   *   data: {
   *     // ... data to create a Pipeline
   *   }
   * })
   * 
  **/
  create<T extends PipelineCreateArgs>(
    args: Subset<T, PipelineCreateArgs>
  ): CheckSelect<T, Prisma__PipelineClient<Pipeline>, Prisma__PipelineClient<PipelineGetPayload<T>>>
  /**
   * Delete a Pipeline.
   * @param {PipelineDeleteArgs} args - Arguments to delete one Pipeline.
   * @example
   * // Delete one Pipeline
   * const Pipeline = await prisma.pipeline.delete({
   *   where: {
   *     // ... filter to delete one Pipeline
   *   }
   * })
   * 
  **/
  delete<T extends PipelineDeleteArgs>(
    args: Subset<T, PipelineDeleteArgs>
  ): CheckSelect<T, Prisma__PipelineClient<Pipeline>, Prisma__PipelineClient<PipelineGetPayload<T>>>
  /**
   * Update one Pipeline.
   * @param {PipelineUpdateArgs} args - Arguments to update one Pipeline.
   * @example
   * // Update one Pipeline
   * const pipeline = await prisma.pipeline.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends PipelineUpdateArgs>(
    args: Subset<T, PipelineUpdateArgs>
  ): CheckSelect<T, Prisma__PipelineClient<Pipeline>, Prisma__PipelineClient<PipelineGetPayload<T>>>
  /**
   * Delete zero or more Pipelines.
   * @param {PipelineDeleteManyArgs} args - Arguments to filter Pipelines to delete.
   * @example
   * // Delete a few Pipelines
   * const { count } = await prisma.pipeline.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends PipelineDeleteManyArgs>(
    args: Subset<T, PipelineDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Pipelines.
   * @param {PipelineUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Pipelines
   * const pipeline = await prisma.pipeline.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends PipelineUpdateManyArgs>(
    args: Subset<T, PipelineUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Pipeline.
   * @param {PipelineUpsertArgs} args - Arguments to update or create a Pipeline.
   * @example
   * // Update or create a Pipeline
   * const pipeline = await prisma.pipeline.upsert({
   *   create: {
   *     // ... data to create a Pipeline
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Pipeline we want to update
   *   }
   * })
  **/
  upsert<T extends PipelineUpsertArgs>(
    args: Subset<T, PipelineUpsertArgs>
  ): CheckSelect<T, Prisma__PipelineClient<Pipeline>, Prisma__PipelineClient<PipelineGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyPipelineArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregatePipelineArgs>(args: Subset<T, AggregatePipelineArgs>): Promise<GetPipelineAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for Pipeline.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__PipelineClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>;

  stages<T extends FindManyStageArgs = {}>(args?: Subset<T, FindManyStageArgs>): CheckSelect<T, Promise<Array<Stage>>, Promise<Array<StageGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Pipeline findOne
 */
export type FindOnePipelineArgs = {
  /**
   * Select specific fields to fetch from the Pipeline
  **/
  select?: PipelineSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PipelineInclude | null
  /**
   * Filter, which Pipeline to fetch.
  **/
  where: PipelineWhereUniqueInput
}


/**
 * Pipeline findMany
 */
export type FindManyPipelineArgs = {
  /**
   * Select specific fields to fetch from the Pipeline
  **/
  select?: PipelineSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PipelineInclude | null
  /**
   * Filter, which Pipelines to fetch.
  **/
  where?: PipelineWhereInput
  /**
   * Determine the order of the Pipelines to fetch.
  **/
  orderBy?: PipelineOrderByInput
  /**
   * Sets the position for listing Pipelines.
  **/
  cursor?: PipelineWhereUniqueInput
  /**
   * The number of Pipelines to fetch. If negative number, it will take Pipelines before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Pipelines.
  **/
  skip?: number
}


/**
 * Pipeline create
 */
export type PipelineCreateArgs = {
  /**
   * Select specific fields to fetch from the Pipeline
  **/
  select?: PipelineSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PipelineInclude | null
  /**
   * The data needed to create a Pipeline.
  **/
  data: PipelineCreateInput
}


/**
 * Pipeline update
 */
export type PipelineUpdateArgs = {
  /**
   * Select specific fields to fetch from the Pipeline
  **/
  select?: PipelineSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PipelineInclude | null
  /**
   * The data needed to update a Pipeline.
  **/
  data: PipelineUpdateInput
  /**
   * Choose, which Pipeline to update.
  **/
  where: PipelineWhereUniqueInput
}


/**
 * Pipeline updateMany
 */
export type PipelineUpdateManyArgs = {
  data: PipelineUpdateManyMutationInput
  where?: PipelineWhereInput
}


/**
 * Pipeline upsert
 */
export type PipelineUpsertArgs = {
  /**
   * Select specific fields to fetch from the Pipeline
  **/
  select?: PipelineSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PipelineInclude | null
  /**
   * The filter to search for the Pipeline to update in case it exists.
  **/
  where: PipelineWhereUniqueInput
  /**
   * In case the Pipeline found by the `where` argument doesn't exist, create a new Pipeline with this data.
  **/
  create: PipelineCreateInput
  /**
   * In case the Pipeline was found with the provided `where` argument, update it with this data.
  **/
  update: PipelineUpdateInput
}


/**
 * Pipeline delete
 */
export type PipelineDeleteArgs = {
  /**
   * Select specific fields to fetch from the Pipeline
  **/
  select?: PipelineSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PipelineInclude | null
  /**
   * Filter which Pipeline to delete.
  **/
  where: PipelineWhereUniqueInput
}


/**
 * Pipeline deleteMany
 */
export type PipelineDeleteManyArgs = {
  where?: PipelineWhereInput
}


/**
 * Pipeline without action
 */
export type PipelineArgs = {
  /**
   * Select specific fields to fetch from the Pipeline
  **/
  select?: PipelineSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PipelineInclude | null
}



/**
 * Model Stage
 */

export type Stage = {
  id: string
  wid: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
  pipelineId: string
}


export type AggregateStage = {
  count: number
}



export type AggregateStageArgs = {
  where?: StageWhereInput
  orderBy?: StageOrderByInput
  cursor?: StageWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetStageAggregateType<T extends AggregateStageArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type StageSelect = {
  id?: boolean
  wid?: boolean
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  pipeline?: boolean | PipelineArgs
  pipelineId?: boolean
  applications?: boolean | FindManyApplicationArgs
  reviews?: boolean | FindManyReviewArgs
}

export type StageInclude = {
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  pipeline?: boolean | PipelineArgs
  applications?: boolean | FindManyApplicationArgs
  reviews?: boolean | FindManyReviewArgs
}

export type StageGetPayload<
  S extends boolean | null | undefined | StageArgs,
  U = keyof S
> = S extends true
  ? Stage
  : S extends undefined
  ? never
  : S extends StageArgs | FindManyStageArgs
  ? 'include' extends U
    ? Stage  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['include'][P]> :
      P extends 'pipeline'
      ? PipelineGetPayload<S['include'][P]> :
      P extends 'applications'
      ? Array<ApplicationGetPayload<S['include'][P]>> :
      P extends 'reviews'
      ? Array<ReviewGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Stage ? Stage[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['select'][P]> :
      P extends 'pipeline'
      ? PipelineGetPayload<S['select'][P]> :
      P extends 'applications'
      ? Array<ApplicationGetPayload<S['select'][P]>> :
      P extends 'reviews'
      ? Array<ReviewGetPayload<S['select'][P]>> : never
    }
  : Stage
: Stage


export interface StageDelegate {
  /**
   * Find zero or one Stage.
   * @param {FindOneStageArgs} args - Arguments to find a Stage
   * @example
   * // Get one Stage
   * const stage = await prisma.stage.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneStageArgs>(
    args: Subset<T, FindOneStageArgs>
  ): CheckSelect<T, Prisma__StageClient<Stage | null>, Prisma__StageClient<StageGetPayload<T> | null>>
  /**
   * Find zero or more Stages.
   * @param {FindManyStageArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Stages
   * const stages = await prisma.stage.findMany()
   * 
   * // Get first 10 Stages
   * const stages = await prisma.stage.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const stageWithIdOnly = await prisma.stage.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyStageArgs>(
    args?: Subset<T, FindManyStageArgs>
  ): CheckSelect<T, Promise<Array<Stage>>, Promise<Array<StageGetPayload<T>>>>
  /**
   * Create a Stage.
   * @param {StageCreateArgs} args - Arguments to create a Stage.
   * @example
   * // Create one Stage
   * const Stage = await prisma.stage.create({
   *   data: {
   *     // ... data to create a Stage
   *   }
   * })
   * 
  **/
  create<T extends StageCreateArgs>(
    args: Subset<T, StageCreateArgs>
  ): CheckSelect<T, Prisma__StageClient<Stage>, Prisma__StageClient<StageGetPayload<T>>>
  /**
   * Delete a Stage.
   * @param {StageDeleteArgs} args - Arguments to delete one Stage.
   * @example
   * // Delete one Stage
   * const Stage = await prisma.stage.delete({
   *   where: {
   *     // ... filter to delete one Stage
   *   }
   * })
   * 
  **/
  delete<T extends StageDeleteArgs>(
    args: Subset<T, StageDeleteArgs>
  ): CheckSelect<T, Prisma__StageClient<Stage>, Prisma__StageClient<StageGetPayload<T>>>
  /**
   * Update one Stage.
   * @param {StageUpdateArgs} args - Arguments to update one Stage.
   * @example
   * // Update one Stage
   * const stage = await prisma.stage.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends StageUpdateArgs>(
    args: Subset<T, StageUpdateArgs>
  ): CheckSelect<T, Prisma__StageClient<Stage>, Prisma__StageClient<StageGetPayload<T>>>
  /**
   * Delete zero or more Stages.
   * @param {StageDeleteManyArgs} args - Arguments to filter Stages to delete.
   * @example
   * // Delete a few Stages
   * const { count } = await prisma.stage.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends StageDeleteManyArgs>(
    args: Subset<T, StageDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Stages.
   * @param {StageUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Stages
   * const stage = await prisma.stage.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends StageUpdateManyArgs>(
    args: Subset<T, StageUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Stage.
   * @param {StageUpsertArgs} args - Arguments to update or create a Stage.
   * @example
   * // Update or create a Stage
   * const stage = await prisma.stage.upsert({
   *   create: {
   *     // ... data to create a Stage
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Stage we want to update
   *   }
   * })
  **/
  upsert<T extends StageUpsertArgs>(
    args: Subset<T, StageUpsertArgs>
  ): CheckSelect<T, Prisma__StageClient<Stage>, Prisma__StageClient<StageGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyStageArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateStageArgs>(args: Subset<T, AggregateStageArgs>): Promise<GetStageAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for Stage.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__StageClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>;

  pipeline<T extends PipelineArgs = {}>(args?: Subset<T, PipelineArgs>): CheckSelect<T, Prisma__PipelineClient<Pipeline | null>, Prisma__PipelineClient<PipelineGetPayload<T> | null>>;

  applications<T extends FindManyApplicationArgs = {}>(args?: Subset<T, FindManyApplicationArgs>): CheckSelect<T, Promise<Array<Application>>, Promise<Array<ApplicationGetPayload<T>>>>;

  reviews<T extends FindManyReviewArgs = {}>(args?: Subset<T, FindManyReviewArgs>): CheckSelect<T, Promise<Array<Review>>, Promise<Array<ReviewGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Stage findOne
 */
export type FindOneStageArgs = {
  /**
   * Select specific fields to fetch from the Stage
  **/
  select?: StageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StageInclude | null
  /**
   * Filter, which Stage to fetch.
  **/
  where: StageWhereUniqueInput
}


/**
 * Stage findMany
 */
export type FindManyStageArgs = {
  /**
   * Select specific fields to fetch from the Stage
  **/
  select?: StageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StageInclude | null
  /**
   * Filter, which Stages to fetch.
  **/
  where?: StageWhereInput
  /**
   * Determine the order of the Stages to fetch.
  **/
  orderBy?: StageOrderByInput
  /**
   * Sets the position for listing Stages.
  **/
  cursor?: StageWhereUniqueInput
  /**
   * The number of Stages to fetch. If negative number, it will take Stages before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Stages.
  **/
  skip?: number
}


/**
 * Stage create
 */
export type StageCreateArgs = {
  /**
   * Select specific fields to fetch from the Stage
  **/
  select?: StageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StageInclude | null
  /**
   * The data needed to create a Stage.
  **/
  data: StageCreateInput
}


/**
 * Stage update
 */
export type StageUpdateArgs = {
  /**
   * Select specific fields to fetch from the Stage
  **/
  select?: StageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StageInclude | null
  /**
   * The data needed to update a Stage.
  **/
  data: StageUpdateInput
  /**
   * Choose, which Stage to update.
  **/
  where: StageWhereUniqueInput
}


/**
 * Stage updateMany
 */
export type StageUpdateManyArgs = {
  data: StageUpdateManyMutationInput
  where?: StageWhereInput
}


/**
 * Stage upsert
 */
export type StageUpsertArgs = {
  /**
   * Select specific fields to fetch from the Stage
  **/
  select?: StageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StageInclude | null
  /**
   * The filter to search for the Stage to update in case it exists.
  **/
  where: StageWhereUniqueInput
  /**
   * In case the Stage found by the `where` argument doesn't exist, create a new Stage with this data.
  **/
  create: StageCreateInput
  /**
   * In case the Stage was found with the provided `where` argument, update it with this data.
  **/
  update: StageUpdateInput
}


/**
 * Stage delete
 */
export type StageDeleteArgs = {
  /**
   * Select specific fields to fetch from the Stage
  **/
  select?: StageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StageInclude | null
  /**
   * Filter which Stage to delete.
  **/
  where: StageWhereUniqueInput
}


/**
 * Stage deleteMany
 */
export type StageDeleteManyArgs = {
  where?: StageWhereInput
}


/**
 * Stage without action
 */
export type StageArgs = {
  /**
   * Select specific fields to fetch from the Stage
  **/
  select?: StageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StageInclude | null
}



/**
 * Model Review
 */

export type Review = {
  id: string
  wid: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
  message: string | null
  score: number | null
  authorId: string
  applicationId: string
  stageId: string | null
}


export type AggregateReview = {
  count: number
  avg: ReviewAvgAggregateOutputType | null
  sum: ReviewSumAggregateOutputType | null
  min: ReviewMinAggregateOutputType | null
  max: ReviewMaxAggregateOutputType | null
}

export type ReviewAvgAggregateOutputType = {
  score: number
}

export type ReviewSumAggregateOutputType = {
  score: number | null
}

export type ReviewMinAggregateOutputType = {
  score: number | null
}

export type ReviewMaxAggregateOutputType = {
  score: number | null
}


export type ReviewAvgAggregateInputType = {
  score?: true
}

export type ReviewSumAggregateInputType = {
  score?: true
}

export type ReviewMinAggregateInputType = {
  score?: true
}

export type ReviewMaxAggregateInputType = {
  score?: true
}

export type AggregateReviewArgs = {
  where?: ReviewWhereInput
  orderBy?: ReviewOrderByInput
  cursor?: ReviewWhereUniqueInput
  take?: number
  skip?: number
  count?: true
  avg?: ReviewAvgAggregateInputType
  sum?: ReviewSumAggregateInputType
  min?: ReviewMinAggregateInputType
  max?: ReviewMaxAggregateInputType
}

export type GetReviewAggregateType<T extends AggregateReviewArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetReviewAggregateScalarType<T[P]>
}

export type GetReviewAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof ReviewAvgAggregateOutputType ? ReviewAvgAggregateOutputType[P] : never
}
    
    

export type ReviewSelect = {
  id?: boolean
  node?: boolean | NodeArgs
  wid?: boolean
  workspace?: boolean | WorkspaceArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  message?: boolean
  score?: boolean
  author?: boolean | UserArgs
  authorId?: boolean
  application?: boolean | ApplicationArgs
  applicationId?: boolean
  stage?: boolean | StageArgs
  stageId?: boolean
}

export type ReviewInclude = {
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  author?: boolean | UserArgs
  application?: boolean | ApplicationArgs
  stage?: boolean | StageArgs
}

export type ReviewGetPayload<
  S extends boolean | null | undefined | ReviewArgs,
  U = keyof S
> = S extends true
  ? Review
  : S extends undefined
  ? never
  : S extends ReviewArgs | FindManyReviewArgs
  ? 'include' extends U
    ? Review  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['include'][P]> :
      P extends 'author'
      ? UserGetPayload<S['include'][P]> :
      P extends 'application'
      ? ApplicationGetPayload<S['include'][P]> :
      P extends 'stage'
      ? StageGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Review ? Review[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['select'][P]> :
      P extends 'author'
      ? UserGetPayload<S['select'][P]> :
      P extends 'application'
      ? ApplicationGetPayload<S['select'][P]> :
      P extends 'stage'
      ? StageGetPayload<S['select'][P]> | null : never
    }
  : Review
: Review


export interface ReviewDelegate {
  /**
   * Find zero or one Review.
   * @param {FindOneReviewArgs} args - Arguments to find a Review
   * @example
   * // Get one Review
   * const review = await prisma.review.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneReviewArgs>(
    args: Subset<T, FindOneReviewArgs>
  ): CheckSelect<T, Prisma__ReviewClient<Review | null>, Prisma__ReviewClient<ReviewGetPayload<T> | null>>
  /**
   * Find zero or more Reviews.
   * @param {FindManyReviewArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Reviews
   * const reviews = await prisma.review.findMany()
   * 
   * // Get first 10 Reviews
   * const reviews = await prisma.review.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyReviewArgs>(
    args?: Subset<T, FindManyReviewArgs>
  ): CheckSelect<T, Promise<Array<Review>>, Promise<Array<ReviewGetPayload<T>>>>
  /**
   * Create a Review.
   * @param {ReviewCreateArgs} args - Arguments to create a Review.
   * @example
   * // Create one Review
   * const Review = await prisma.review.create({
   *   data: {
   *     // ... data to create a Review
   *   }
   * })
   * 
  **/
  create<T extends ReviewCreateArgs>(
    args: Subset<T, ReviewCreateArgs>
  ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>
  /**
   * Delete a Review.
   * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
   * @example
   * // Delete one Review
   * const Review = await prisma.review.delete({
   *   where: {
   *     // ... filter to delete one Review
   *   }
   * })
   * 
  **/
  delete<T extends ReviewDeleteArgs>(
    args: Subset<T, ReviewDeleteArgs>
  ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>
  /**
   * Update one Review.
   * @param {ReviewUpdateArgs} args - Arguments to update one Review.
   * @example
   * // Update one Review
   * const review = await prisma.review.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ReviewUpdateArgs>(
    args: Subset<T, ReviewUpdateArgs>
  ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>
  /**
   * Delete zero or more Reviews.
   * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
   * @example
   * // Delete a few Reviews
   * const { count } = await prisma.review.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ReviewDeleteManyArgs>(
    args: Subset<T, ReviewDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Reviews.
   * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Reviews
   * const review = await prisma.review.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ReviewUpdateManyArgs>(
    args: Subset<T, ReviewUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Review.
   * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
   * @example
   * // Update or create a Review
   * const review = await prisma.review.upsert({
   *   create: {
   *     // ... data to create a Review
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Review we want to update
   *   }
   * })
  **/
  upsert<T extends ReviewUpsertArgs>(
    args: Subset<T, ReviewUpsertArgs>
  ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyReviewArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateReviewArgs>(args: Subset<T, AggregateReviewArgs>): Promise<GetReviewAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for Review.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ReviewClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>;

  author<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

  application<T extends ApplicationArgs = {}>(args?: Subset<T, ApplicationArgs>): CheckSelect<T, Prisma__ApplicationClient<Application | null>, Prisma__ApplicationClient<ApplicationGetPayload<T> | null>>;

  stage<T extends StageArgs = {}>(args?: Subset<T, StageArgs>): CheckSelect<T, Prisma__StageClient<Stage | null>, Prisma__StageClient<StageGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Review findOne
 */
export type FindOneReviewArgs = {
  /**
   * Select specific fields to fetch from the Review
  **/
  select?: ReviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ReviewInclude | null
  /**
   * Filter, which Review to fetch.
  **/
  where: ReviewWhereUniqueInput
}


/**
 * Review findMany
 */
export type FindManyReviewArgs = {
  /**
   * Select specific fields to fetch from the Review
  **/
  select?: ReviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ReviewInclude | null
  /**
   * Filter, which Reviews to fetch.
  **/
  where?: ReviewWhereInput
  /**
   * Determine the order of the Reviews to fetch.
  **/
  orderBy?: ReviewOrderByInput
  /**
   * Sets the position for listing Reviews.
  **/
  cursor?: ReviewWhereUniqueInput
  /**
   * The number of Reviews to fetch. If negative number, it will take Reviews before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Reviews.
  **/
  skip?: number
}


/**
 * Review create
 */
export type ReviewCreateArgs = {
  /**
   * Select specific fields to fetch from the Review
  **/
  select?: ReviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ReviewInclude | null
  /**
   * The data needed to create a Review.
  **/
  data: ReviewCreateInput
}


/**
 * Review update
 */
export type ReviewUpdateArgs = {
  /**
   * Select specific fields to fetch from the Review
  **/
  select?: ReviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ReviewInclude | null
  /**
   * The data needed to update a Review.
  **/
  data: ReviewUpdateInput
  /**
   * Choose, which Review to update.
  **/
  where: ReviewWhereUniqueInput
}


/**
 * Review updateMany
 */
export type ReviewUpdateManyArgs = {
  data: ReviewUpdateManyMutationInput
  where?: ReviewWhereInput
}


/**
 * Review upsert
 */
export type ReviewUpsertArgs = {
  /**
   * Select specific fields to fetch from the Review
  **/
  select?: ReviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ReviewInclude | null
  /**
   * The filter to search for the Review to update in case it exists.
  **/
  where: ReviewWhereUniqueInput
  /**
   * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
  **/
  create: ReviewCreateInput
  /**
   * In case the Review was found with the provided `where` argument, update it with this data.
  **/
  update: ReviewUpdateInput
}


/**
 * Review delete
 */
export type ReviewDeleteArgs = {
  /**
   * Select specific fields to fetch from the Review
  **/
  select?: ReviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ReviewInclude | null
  /**
   * Filter which Review to delete.
  **/
  where: ReviewWhereUniqueInput
}


/**
 * Review deleteMany
 */
export type ReviewDeleteManyArgs = {
  where?: ReviewWhereInput
}


/**
 * Review without action
 */
export type ReviewArgs = {
  /**
   * Select specific fields to fetch from the Review
  **/
  select?: ReviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ReviewInclude | null
}



/**
 * Model Client
 */

export type Client = {
  id: string
  wid: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
  name: string
  description: string | null
}


export type AggregateClient = {
  count: number
}



export type AggregateClientArgs = {
  where?: ClientWhereInput
  orderBy?: ClientOrderByInput
  cursor?: ClientWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetClientAggregateType<T extends AggregateClientArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type ClientSelect = {
  id?: boolean
  node?: boolean | NodeArgs
  wid?: boolean
  workspace?: boolean | WorkspaceArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  name?: boolean
  description?: boolean
  jobs?: boolean | FindManyJobArgs
}

export type ClientInclude = {
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  jobs?: boolean | FindManyJobArgs
}

export type ClientGetPayload<
  S extends boolean | null | undefined | ClientArgs,
  U = keyof S
> = S extends true
  ? Client
  : S extends undefined
  ? never
  : S extends ClientArgs | FindManyClientArgs
  ? 'include' extends U
    ? Client  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['include'][P]> :
      P extends 'jobs'
      ? Array<JobGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Client ? Client[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['select'][P]> :
      P extends 'jobs'
      ? Array<JobGetPayload<S['select'][P]>> : never
    }
  : Client
: Client


export interface ClientDelegate {
  /**
   * Find zero or one Client.
   * @param {FindOneClientArgs} args - Arguments to find a Client
   * @example
   * // Get one Client
   * const client = await prisma.client.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneClientArgs>(
    args: Subset<T, FindOneClientArgs>
  ): CheckSelect<T, Prisma__ClientClient<Client | null>, Prisma__ClientClient<ClientGetPayload<T> | null>>
  /**
   * Find zero or more Clients.
   * @param {FindManyClientArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Clients
   * const clients = await prisma.client.findMany()
   * 
   * // Get first 10 Clients
   * const clients = await prisma.client.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyClientArgs>(
    args?: Subset<T, FindManyClientArgs>
  ): CheckSelect<T, Promise<Array<Client>>, Promise<Array<ClientGetPayload<T>>>>
  /**
   * Create a Client.
   * @param {ClientCreateArgs} args - Arguments to create a Client.
   * @example
   * // Create one Client
   * const Client = await prisma.client.create({
   *   data: {
   *     // ... data to create a Client
   *   }
   * })
   * 
  **/
  create<T extends ClientCreateArgs>(
    args: Subset<T, ClientCreateArgs>
  ): CheckSelect<T, Prisma__ClientClient<Client>, Prisma__ClientClient<ClientGetPayload<T>>>
  /**
   * Delete a Client.
   * @param {ClientDeleteArgs} args - Arguments to delete one Client.
   * @example
   * // Delete one Client
   * const Client = await prisma.client.delete({
   *   where: {
   *     // ... filter to delete one Client
   *   }
   * })
   * 
  **/
  delete<T extends ClientDeleteArgs>(
    args: Subset<T, ClientDeleteArgs>
  ): CheckSelect<T, Prisma__ClientClient<Client>, Prisma__ClientClient<ClientGetPayload<T>>>
  /**
   * Update one Client.
   * @param {ClientUpdateArgs} args - Arguments to update one Client.
   * @example
   * // Update one Client
   * const client = await prisma.client.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ClientUpdateArgs>(
    args: Subset<T, ClientUpdateArgs>
  ): CheckSelect<T, Prisma__ClientClient<Client>, Prisma__ClientClient<ClientGetPayload<T>>>
  /**
   * Delete zero or more Clients.
   * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
   * @example
   * // Delete a few Clients
   * const { count } = await prisma.client.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ClientDeleteManyArgs>(
    args: Subset<T, ClientDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Clients.
   * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Clients
   * const client = await prisma.client.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ClientUpdateManyArgs>(
    args: Subset<T, ClientUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Client.
   * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
   * @example
   * // Update or create a Client
   * const client = await prisma.client.upsert({
   *   create: {
   *     // ... data to create a Client
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Client we want to update
   *   }
   * })
  **/
  upsert<T extends ClientUpsertArgs>(
    args: Subset<T, ClientUpsertArgs>
  ): CheckSelect<T, Prisma__ClientClient<Client>, Prisma__ClientClient<ClientGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyClientArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateClientArgs>(args: Subset<T, AggregateClientArgs>): Promise<GetClientAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for Client.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ClientClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>;

  jobs<T extends FindManyJobArgs = {}>(args?: Subset<T, FindManyJobArgs>): CheckSelect<T, Promise<Array<Job>>, Promise<Array<JobGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Client findOne
 */
export type FindOneClientArgs = {
  /**
   * Select specific fields to fetch from the Client
  **/
  select?: ClientSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ClientInclude | null
  /**
   * Filter, which Client to fetch.
  **/
  where: ClientWhereUniqueInput
}


/**
 * Client findMany
 */
export type FindManyClientArgs = {
  /**
   * Select specific fields to fetch from the Client
  **/
  select?: ClientSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ClientInclude | null
  /**
   * Filter, which Clients to fetch.
  **/
  where?: ClientWhereInput
  /**
   * Determine the order of the Clients to fetch.
  **/
  orderBy?: ClientOrderByInput
  /**
   * Sets the position for listing Clients.
  **/
  cursor?: ClientWhereUniqueInput
  /**
   * The number of Clients to fetch. If negative number, it will take Clients before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Clients.
  **/
  skip?: number
}


/**
 * Client create
 */
export type ClientCreateArgs = {
  /**
   * Select specific fields to fetch from the Client
  **/
  select?: ClientSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ClientInclude | null
  /**
   * The data needed to create a Client.
  **/
  data: ClientCreateInput
}


/**
 * Client update
 */
export type ClientUpdateArgs = {
  /**
   * Select specific fields to fetch from the Client
  **/
  select?: ClientSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ClientInclude | null
  /**
   * The data needed to update a Client.
  **/
  data: ClientUpdateInput
  /**
   * Choose, which Client to update.
  **/
  where: ClientWhereUniqueInput
}


/**
 * Client updateMany
 */
export type ClientUpdateManyArgs = {
  data: ClientUpdateManyMutationInput
  where?: ClientWhereInput
}


/**
 * Client upsert
 */
export type ClientUpsertArgs = {
  /**
   * Select specific fields to fetch from the Client
  **/
  select?: ClientSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ClientInclude | null
  /**
   * The filter to search for the Client to update in case it exists.
  **/
  where: ClientWhereUniqueInput
  /**
   * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
  **/
  create: ClientCreateInput
  /**
   * In case the Client was found with the provided `where` argument, update it with this data.
  **/
  update: ClientUpdateInput
}


/**
 * Client delete
 */
export type ClientDeleteArgs = {
  /**
   * Select specific fields to fetch from the Client
  **/
  select?: ClientSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ClientInclude | null
  /**
   * Filter which Client to delete.
  **/
  where: ClientWhereUniqueInput
}


/**
 * Client deleteMany
 */
export type ClientDeleteManyArgs = {
  where?: ClientWhereInput
}


/**
 * Client without action
 */
export type ClientArgs = {
  /**
   * Select specific fields to fetch from the Client
  **/
  select?: ClientSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ClientInclude | null
}



/**
 * Model Candidate
 */

export type Candidate = {
  id: string
  wid: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
  firstName: string | null
  lastName: string | null
  headline: string | null
  emails: string[]
  links: string[]
  phones: string[]
}


export type AggregateCandidate = {
  count: number
}



export type AggregateCandidateArgs = {
  where?: CandidateWhereInput
  orderBy?: CandidateOrderByInput
  cursor?: CandidateWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetCandidateAggregateType<T extends AggregateCandidateArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type CandidateSelect = {
  id?: boolean
  node?: boolean | NodeArgs
  wid?: boolean
  workspace?: boolean | WorkspaceArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  firstName?: boolean
  lastName?: boolean
  headline?: boolean
  emails?: boolean
  links?: boolean
  phones?: boolean
  tags?: boolean | FindManyTagArgs
  applications?: boolean | FindManyApplicationArgs
  fields?: boolean | FindManyFieldValueArgs
}

export type CandidateInclude = {
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  tags?: boolean | FindManyTagArgs
  applications?: boolean | FindManyApplicationArgs
  fields?: boolean | FindManyFieldValueArgs
}

export type CandidateGetPayload<
  S extends boolean | null | undefined | CandidateArgs,
  U = keyof S
> = S extends true
  ? Candidate
  : S extends undefined
  ? never
  : S extends CandidateArgs | FindManyCandidateArgs
  ? 'include' extends U
    ? Candidate  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['include'][P]> :
      P extends 'tags'
      ? Array<TagGetPayload<S['include'][P]>> :
      P extends 'applications'
      ? Array<ApplicationGetPayload<S['include'][P]>> :
      P extends 'fields'
      ? Array<FieldValueGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Candidate ? Candidate[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['select'][P]> :
      P extends 'tags'
      ? Array<TagGetPayload<S['select'][P]>> :
      P extends 'applications'
      ? Array<ApplicationGetPayload<S['select'][P]>> :
      P extends 'fields'
      ? Array<FieldValueGetPayload<S['select'][P]>> : never
    }
  : Candidate
: Candidate


export interface CandidateDelegate {
  /**
   * Find zero or one Candidate.
   * @param {FindOneCandidateArgs} args - Arguments to find a Candidate
   * @example
   * // Get one Candidate
   * const candidate = await prisma.candidate.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneCandidateArgs>(
    args: Subset<T, FindOneCandidateArgs>
  ): CheckSelect<T, Prisma__CandidateClient<Candidate | null>, Prisma__CandidateClient<CandidateGetPayload<T> | null>>
  /**
   * Find zero or more Candidates.
   * @param {FindManyCandidateArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Candidates
   * const candidates = await prisma.candidate.findMany()
   * 
   * // Get first 10 Candidates
   * const candidates = await prisma.candidate.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const candidateWithIdOnly = await prisma.candidate.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyCandidateArgs>(
    args?: Subset<T, FindManyCandidateArgs>
  ): CheckSelect<T, Promise<Array<Candidate>>, Promise<Array<CandidateGetPayload<T>>>>
  /**
   * Create a Candidate.
   * @param {CandidateCreateArgs} args - Arguments to create a Candidate.
   * @example
   * // Create one Candidate
   * const Candidate = await prisma.candidate.create({
   *   data: {
   *     // ... data to create a Candidate
   *   }
   * })
   * 
  **/
  create<T extends CandidateCreateArgs>(
    args: Subset<T, CandidateCreateArgs>
  ): CheckSelect<T, Prisma__CandidateClient<Candidate>, Prisma__CandidateClient<CandidateGetPayload<T>>>
  /**
   * Delete a Candidate.
   * @param {CandidateDeleteArgs} args - Arguments to delete one Candidate.
   * @example
   * // Delete one Candidate
   * const Candidate = await prisma.candidate.delete({
   *   where: {
   *     // ... filter to delete one Candidate
   *   }
   * })
   * 
  **/
  delete<T extends CandidateDeleteArgs>(
    args: Subset<T, CandidateDeleteArgs>
  ): CheckSelect<T, Prisma__CandidateClient<Candidate>, Prisma__CandidateClient<CandidateGetPayload<T>>>
  /**
   * Update one Candidate.
   * @param {CandidateUpdateArgs} args - Arguments to update one Candidate.
   * @example
   * // Update one Candidate
   * const candidate = await prisma.candidate.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends CandidateUpdateArgs>(
    args: Subset<T, CandidateUpdateArgs>
  ): CheckSelect<T, Prisma__CandidateClient<Candidate>, Prisma__CandidateClient<CandidateGetPayload<T>>>
  /**
   * Delete zero or more Candidates.
   * @param {CandidateDeleteManyArgs} args - Arguments to filter Candidates to delete.
   * @example
   * // Delete a few Candidates
   * const { count } = await prisma.candidate.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends CandidateDeleteManyArgs>(
    args: Subset<T, CandidateDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Candidates.
   * @param {CandidateUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Candidates
   * const candidate = await prisma.candidate.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends CandidateUpdateManyArgs>(
    args: Subset<T, CandidateUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Candidate.
   * @param {CandidateUpsertArgs} args - Arguments to update or create a Candidate.
   * @example
   * // Update or create a Candidate
   * const candidate = await prisma.candidate.upsert({
   *   create: {
   *     // ... data to create a Candidate
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Candidate we want to update
   *   }
   * })
  **/
  upsert<T extends CandidateUpsertArgs>(
    args: Subset<T, CandidateUpsertArgs>
  ): CheckSelect<T, Prisma__CandidateClient<Candidate>, Prisma__CandidateClient<CandidateGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyCandidateArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateCandidateArgs>(args: Subset<T, AggregateCandidateArgs>): Promise<GetCandidateAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for Candidate.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__CandidateClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>;

  tags<T extends FindManyTagArgs = {}>(args?: Subset<T, FindManyTagArgs>): CheckSelect<T, Promise<Array<Tag>>, Promise<Array<TagGetPayload<T>>>>;

  applications<T extends FindManyApplicationArgs = {}>(args?: Subset<T, FindManyApplicationArgs>): CheckSelect<T, Promise<Array<Application>>, Promise<Array<ApplicationGetPayload<T>>>>;

  fields<T extends FindManyFieldValueArgs = {}>(args?: Subset<T, FindManyFieldValueArgs>): CheckSelect<T, Promise<Array<FieldValue>>, Promise<Array<FieldValueGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Candidate findOne
 */
export type FindOneCandidateArgs = {
  /**
   * Select specific fields to fetch from the Candidate
  **/
  select?: CandidateSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CandidateInclude | null
  /**
   * Filter, which Candidate to fetch.
  **/
  where: CandidateWhereUniqueInput
}


/**
 * Candidate findMany
 */
export type FindManyCandidateArgs = {
  /**
   * Select specific fields to fetch from the Candidate
  **/
  select?: CandidateSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CandidateInclude | null
  /**
   * Filter, which Candidates to fetch.
  **/
  where?: CandidateWhereInput
  /**
   * Determine the order of the Candidates to fetch.
  **/
  orderBy?: CandidateOrderByInput
  /**
   * Sets the position for listing Candidates.
  **/
  cursor?: CandidateWhereUniqueInput
  /**
   * The number of Candidates to fetch. If negative number, it will take Candidates before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Candidates.
  **/
  skip?: number
}


/**
 * Candidate create
 */
export type CandidateCreateArgs = {
  /**
   * Select specific fields to fetch from the Candidate
  **/
  select?: CandidateSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CandidateInclude | null
  /**
   * The data needed to create a Candidate.
  **/
  data: CandidateCreateInput
}


/**
 * Candidate update
 */
export type CandidateUpdateArgs = {
  /**
   * Select specific fields to fetch from the Candidate
  **/
  select?: CandidateSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CandidateInclude | null
  /**
   * The data needed to update a Candidate.
  **/
  data: CandidateUpdateInput
  /**
   * Choose, which Candidate to update.
  **/
  where: CandidateWhereUniqueInput
}


/**
 * Candidate updateMany
 */
export type CandidateUpdateManyArgs = {
  data: CandidateUpdateManyMutationInput
  where?: CandidateWhereInput
}


/**
 * Candidate upsert
 */
export type CandidateUpsertArgs = {
  /**
   * Select specific fields to fetch from the Candidate
  **/
  select?: CandidateSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CandidateInclude | null
  /**
   * The filter to search for the Candidate to update in case it exists.
  **/
  where: CandidateWhereUniqueInput
  /**
   * In case the Candidate found by the `where` argument doesn't exist, create a new Candidate with this data.
  **/
  create: CandidateCreateInput
  /**
   * In case the Candidate was found with the provided `where` argument, update it with this data.
  **/
  update: CandidateUpdateInput
}


/**
 * Candidate delete
 */
export type CandidateDeleteArgs = {
  /**
   * Select specific fields to fetch from the Candidate
  **/
  select?: CandidateSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CandidateInclude | null
  /**
   * Filter which Candidate to delete.
  **/
  where: CandidateWhereUniqueInput
}


/**
 * Candidate deleteMany
 */
export type CandidateDeleteManyArgs = {
  where?: CandidateWhereInput
}


/**
 * Candidate without action
 */
export type CandidateArgs = {
  /**
   * Select specific fields to fetch from the Candidate
  **/
  select?: CandidateSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CandidateInclude | null
}



/**
 * Model FieldDefinition
 */

export type FieldDefinition = {
  id: string
  wid: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
  name: string
  type: FieldType
}


export type AggregateFieldDefinition = {
  count: number
}



export type AggregateFieldDefinitionArgs = {
  where?: FieldDefinitionWhereInput
  orderBy?: FieldDefinitionOrderByInput
  cursor?: FieldDefinitionWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetFieldDefinitionAggregateType<T extends AggregateFieldDefinitionArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type FieldDefinitionSelect = {
  id?: boolean
  node?: boolean | NodeArgs
  wid?: boolean
  workspace?: boolean | WorkspaceArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  name?: boolean
  type?: boolean
  values?: boolean | FindManyFieldValueArgs
}

export type FieldDefinitionInclude = {
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  values?: boolean | FindManyFieldValueArgs
}

export type FieldDefinitionGetPayload<
  S extends boolean | null | undefined | FieldDefinitionArgs,
  U = keyof S
> = S extends true
  ? FieldDefinition
  : S extends undefined
  ? never
  : S extends FieldDefinitionArgs | FindManyFieldDefinitionArgs
  ? 'include' extends U
    ? FieldDefinition  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['include'][P]> :
      P extends 'values'
      ? Array<FieldValueGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof FieldDefinition ? FieldDefinition[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['select'][P]> :
      P extends 'values'
      ? Array<FieldValueGetPayload<S['select'][P]>> : never
    }
  : FieldDefinition
: FieldDefinition


export interface FieldDefinitionDelegate {
  /**
   * Find zero or one FieldDefinition.
   * @param {FindOneFieldDefinitionArgs} args - Arguments to find a FieldDefinition
   * @example
   * // Get one FieldDefinition
   * const fieldDefinition = await prisma.fieldDefinition.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneFieldDefinitionArgs>(
    args: Subset<T, FindOneFieldDefinitionArgs>
  ): CheckSelect<T, Prisma__FieldDefinitionClient<FieldDefinition | null>, Prisma__FieldDefinitionClient<FieldDefinitionGetPayload<T> | null>>
  /**
   * Find zero or more FieldDefinitions.
   * @param {FindManyFieldDefinitionArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all FieldDefinitions
   * const fieldDefinitions = await prisma.fieldDefinition.findMany()
   * 
   * // Get first 10 FieldDefinitions
   * const fieldDefinitions = await prisma.fieldDefinition.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const fieldDefinitionWithIdOnly = await prisma.fieldDefinition.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyFieldDefinitionArgs>(
    args?: Subset<T, FindManyFieldDefinitionArgs>
  ): CheckSelect<T, Promise<Array<FieldDefinition>>, Promise<Array<FieldDefinitionGetPayload<T>>>>
  /**
   * Create a FieldDefinition.
   * @param {FieldDefinitionCreateArgs} args - Arguments to create a FieldDefinition.
   * @example
   * // Create one FieldDefinition
   * const FieldDefinition = await prisma.fieldDefinition.create({
   *   data: {
   *     // ... data to create a FieldDefinition
   *   }
   * })
   * 
  **/
  create<T extends FieldDefinitionCreateArgs>(
    args: Subset<T, FieldDefinitionCreateArgs>
  ): CheckSelect<T, Prisma__FieldDefinitionClient<FieldDefinition>, Prisma__FieldDefinitionClient<FieldDefinitionGetPayload<T>>>
  /**
   * Delete a FieldDefinition.
   * @param {FieldDefinitionDeleteArgs} args - Arguments to delete one FieldDefinition.
   * @example
   * // Delete one FieldDefinition
   * const FieldDefinition = await prisma.fieldDefinition.delete({
   *   where: {
   *     // ... filter to delete one FieldDefinition
   *   }
   * })
   * 
  **/
  delete<T extends FieldDefinitionDeleteArgs>(
    args: Subset<T, FieldDefinitionDeleteArgs>
  ): CheckSelect<T, Prisma__FieldDefinitionClient<FieldDefinition>, Prisma__FieldDefinitionClient<FieldDefinitionGetPayload<T>>>
  /**
   * Update one FieldDefinition.
   * @param {FieldDefinitionUpdateArgs} args - Arguments to update one FieldDefinition.
   * @example
   * // Update one FieldDefinition
   * const fieldDefinition = await prisma.fieldDefinition.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends FieldDefinitionUpdateArgs>(
    args: Subset<T, FieldDefinitionUpdateArgs>
  ): CheckSelect<T, Prisma__FieldDefinitionClient<FieldDefinition>, Prisma__FieldDefinitionClient<FieldDefinitionGetPayload<T>>>
  /**
   * Delete zero or more FieldDefinitions.
   * @param {FieldDefinitionDeleteManyArgs} args - Arguments to filter FieldDefinitions to delete.
   * @example
   * // Delete a few FieldDefinitions
   * const { count } = await prisma.fieldDefinition.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends FieldDefinitionDeleteManyArgs>(
    args: Subset<T, FieldDefinitionDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more FieldDefinitions.
   * @param {FieldDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many FieldDefinitions
   * const fieldDefinition = await prisma.fieldDefinition.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends FieldDefinitionUpdateManyArgs>(
    args: Subset<T, FieldDefinitionUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one FieldDefinition.
   * @param {FieldDefinitionUpsertArgs} args - Arguments to update or create a FieldDefinition.
   * @example
   * // Update or create a FieldDefinition
   * const fieldDefinition = await prisma.fieldDefinition.upsert({
   *   create: {
   *     // ... data to create a FieldDefinition
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the FieldDefinition we want to update
   *   }
   * })
  **/
  upsert<T extends FieldDefinitionUpsertArgs>(
    args: Subset<T, FieldDefinitionUpsertArgs>
  ): CheckSelect<T, Prisma__FieldDefinitionClient<FieldDefinition>, Prisma__FieldDefinitionClient<FieldDefinitionGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyFieldDefinitionArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateFieldDefinitionArgs>(args: Subset<T, AggregateFieldDefinitionArgs>): Promise<GetFieldDefinitionAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for FieldDefinition.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__FieldDefinitionClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>;

  values<T extends FindManyFieldValueArgs = {}>(args?: Subset<T, FindManyFieldValueArgs>): CheckSelect<T, Promise<Array<FieldValue>>, Promise<Array<FieldValueGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * FieldDefinition findOne
 */
export type FindOneFieldDefinitionArgs = {
  /**
   * Select specific fields to fetch from the FieldDefinition
  **/
  select?: FieldDefinitionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FieldDefinitionInclude | null
  /**
   * Filter, which FieldDefinition to fetch.
  **/
  where: FieldDefinitionWhereUniqueInput
}


/**
 * FieldDefinition findMany
 */
export type FindManyFieldDefinitionArgs = {
  /**
   * Select specific fields to fetch from the FieldDefinition
  **/
  select?: FieldDefinitionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FieldDefinitionInclude | null
  /**
   * Filter, which FieldDefinitions to fetch.
  **/
  where?: FieldDefinitionWhereInput
  /**
   * Determine the order of the FieldDefinitions to fetch.
  **/
  orderBy?: FieldDefinitionOrderByInput
  /**
   * Sets the position for listing FieldDefinitions.
  **/
  cursor?: FieldDefinitionWhereUniqueInput
  /**
   * The number of FieldDefinitions to fetch. If negative number, it will take FieldDefinitions before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` FieldDefinitions.
  **/
  skip?: number
}


/**
 * FieldDefinition create
 */
export type FieldDefinitionCreateArgs = {
  /**
   * Select specific fields to fetch from the FieldDefinition
  **/
  select?: FieldDefinitionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FieldDefinitionInclude | null
  /**
   * The data needed to create a FieldDefinition.
  **/
  data: FieldDefinitionCreateInput
}


/**
 * FieldDefinition update
 */
export type FieldDefinitionUpdateArgs = {
  /**
   * Select specific fields to fetch from the FieldDefinition
  **/
  select?: FieldDefinitionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FieldDefinitionInclude | null
  /**
   * The data needed to update a FieldDefinition.
  **/
  data: FieldDefinitionUpdateInput
  /**
   * Choose, which FieldDefinition to update.
  **/
  where: FieldDefinitionWhereUniqueInput
}


/**
 * FieldDefinition updateMany
 */
export type FieldDefinitionUpdateManyArgs = {
  data: FieldDefinitionUpdateManyMutationInput
  where?: FieldDefinitionWhereInput
}


/**
 * FieldDefinition upsert
 */
export type FieldDefinitionUpsertArgs = {
  /**
   * Select specific fields to fetch from the FieldDefinition
  **/
  select?: FieldDefinitionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FieldDefinitionInclude | null
  /**
   * The filter to search for the FieldDefinition to update in case it exists.
  **/
  where: FieldDefinitionWhereUniqueInput
  /**
   * In case the FieldDefinition found by the `where` argument doesn't exist, create a new FieldDefinition with this data.
  **/
  create: FieldDefinitionCreateInput
  /**
   * In case the FieldDefinition was found with the provided `where` argument, update it with this data.
  **/
  update: FieldDefinitionUpdateInput
}


/**
 * FieldDefinition delete
 */
export type FieldDefinitionDeleteArgs = {
  /**
   * Select specific fields to fetch from the FieldDefinition
  **/
  select?: FieldDefinitionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FieldDefinitionInclude | null
  /**
   * Filter which FieldDefinition to delete.
  **/
  where: FieldDefinitionWhereUniqueInput
}


/**
 * FieldDefinition deleteMany
 */
export type FieldDefinitionDeleteManyArgs = {
  where?: FieldDefinitionWhereInput
}


/**
 * FieldDefinition without action
 */
export type FieldDefinitionArgs = {
  /**
   * Select specific fields to fetch from the FieldDefinition
  **/
  select?: FieldDefinitionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FieldDefinitionInclude | null
}



/**
 * Model FieldValue
 */

export type FieldValue = {
  value: JsonValue
  definitionId: string
  candidateId: string
}


export type AggregateFieldValue = {
  count: number
}



export type AggregateFieldValueArgs = {
  where?: FieldValueWhereInput
  orderBy?: FieldValueOrderByInput
  cursor?: FieldValueWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetFieldValueAggregateType<T extends AggregateFieldValueArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type FieldValueSelect = {
  value?: boolean
  definition?: boolean | FieldDefinitionArgs
  definitionId?: boolean
  candidate?: boolean | CandidateArgs
  candidateId?: boolean
}

export type FieldValueInclude = {
  definition?: boolean | FieldDefinitionArgs
  candidate?: boolean | CandidateArgs
}

export type FieldValueGetPayload<
  S extends boolean | null | undefined | FieldValueArgs,
  U = keyof S
> = S extends true
  ? FieldValue
  : S extends undefined
  ? never
  : S extends FieldValueArgs | FindManyFieldValueArgs
  ? 'include' extends U
    ? FieldValue  & {
      [P in TrueKeys<S['include']>]:
      P extends 'definition'
      ? FieldDefinitionGetPayload<S['include'][P]> :
      P extends 'candidate'
      ? CandidateGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof FieldValue ? FieldValue[P]
: 
      P extends 'definition'
      ? FieldDefinitionGetPayload<S['select'][P]> :
      P extends 'candidate'
      ? CandidateGetPayload<S['select'][P]> : never
    }
  : FieldValue
: FieldValue


export interface FieldValueDelegate {
  /**
   * Find zero or one FieldValue.
   * @param {FindOneFieldValueArgs} args - Arguments to find a FieldValue
   * @example
   * // Get one FieldValue
   * const fieldValue = await prisma.fieldValue.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneFieldValueArgs>(
    args: Subset<T, FindOneFieldValueArgs>
  ): CheckSelect<T, Prisma__FieldValueClient<FieldValue | null>, Prisma__FieldValueClient<FieldValueGetPayload<T> | null>>
  /**
   * Find zero or more FieldValues.
   * @param {FindManyFieldValueArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all FieldValues
   * const fieldValues = await prisma.fieldValue.findMany()
   * 
   * // Get first 10 FieldValues
   * const fieldValues = await prisma.fieldValue.findMany({ take: 10 })
   * 
   * // Only select the `value`
   * const fieldValueWithValueOnly = await prisma.fieldValue.findMany({ select: { value: true } })
   * 
  **/
  findMany<T extends FindManyFieldValueArgs>(
    args?: Subset<T, FindManyFieldValueArgs>
  ): CheckSelect<T, Promise<Array<FieldValue>>, Promise<Array<FieldValueGetPayload<T>>>>
  /**
   * Create a FieldValue.
   * @param {FieldValueCreateArgs} args - Arguments to create a FieldValue.
   * @example
   * // Create one FieldValue
   * const FieldValue = await prisma.fieldValue.create({
   *   data: {
   *     // ... data to create a FieldValue
   *   }
   * })
   * 
  **/
  create<T extends FieldValueCreateArgs>(
    args: Subset<T, FieldValueCreateArgs>
  ): CheckSelect<T, Prisma__FieldValueClient<FieldValue>, Prisma__FieldValueClient<FieldValueGetPayload<T>>>
  /**
   * Delete a FieldValue.
   * @param {FieldValueDeleteArgs} args - Arguments to delete one FieldValue.
   * @example
   * // Delete one FieldValue
   * const FieldValue = await prisma.fieldValue.delete({
   *   where: {
   *     // ... filter to delete one FieldValue
   *   }
   * })
   * 
  **/
  delete<T extends FieldValueDeleteArgs>(
    args: Subset<T, FieldValueDeleteArgs>
  ): CheckSelect<T, Prisma__FieldValueClient<FieldValue>, Prisma__FieldValueClient<FieldValueGetPayload<T>>>
  /**
   * Update one FieldValue.
   * @param {FieldValueUpdateArgs} args - Arguments to update one FieldValue.
   * @example
   * // Update one FieldValue
   * const fieldValue = await prisma.fieldValue.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends FieldValueUpdateArgs>(
    args: Subset<T, FieldValueUpdateArgs>
  ): CheckSelect<T, Prisma__FieldValueClient<FieldValue>, Prisma__FieldValueClient<FieldValueGetPayload<T>>>
  /**
   * Delete zero or more FieldValues.
   * @param {FieldValueDeleteManyArgs} args - Arguments to filter FieldValues to delete.
   * @example
   * // Delete a few FieldValues
   * const { count } = await prisma.fieldValue.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends FieldValueDeleteManyArgs>(
    args: Subset<T, FieldValueDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more FieldValues.
   * @param {FieldValueUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many FieldValues
   * const fieldValue = await prisma.fieldValue.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends FieldValueUpdateManyArgs>(
    args: Subset<T, FieldValueUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one FieldValue.
   * @param {FieldValueUpsertArgs} args - Arguments to update or create a FieldValue.
   * @example
   * // Update or create a FieldValue
   * const fieldValue = await prisma.fieldValue.upsert({
   *   create: {
   *     // ... data to create a FieldValue
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the FieldValue we want to update
   *   }
   * })
  **/
  upsert<T extends FieldValueUpsertArgs>(
    args: Subset<T, FieldValueUpsertArgs>
  ): CheckSelect<T, Prisma__FieldValueClient<FieldValue>, Prisma__FieldValueClient<FieldValueGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyFieldValueArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateFieldValueArgs>(args: Subset<T, AggregateFieldValueArgs>): Promise<GetFieldValueAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for FieldValue.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__FieldValueClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  definition<T extends FieldDefinitionArgs = {}>(args?: Subset<T, FieldDefinitionArgs>): CheckSelect<T, Prisma__FieldDefinitionClient<FieldDefinition | null>, Prisma__FieldDefinitionClient<FieldDefinitionGetPayload<T> | null>>;

  candidate<T extends CandidateArgs = {}>(args?: Subset<T, CandidateArgs>): CheckSelect<T, Prisma__CandidateClient<Candidate | null>, Prisma__CandidateClient<CandidateGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * FieldValue findOne
 */
export type FindOneFieldValueArgs = {
  /**
   * Select specific fields to fetch from the FieldValue
  **/
  select?: FieldValueSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FieldValueInclude | null
  /**
   * Filter, which FieldValue to fetch.
  **/
  where: FieldValueWhereUniqueInput
}


/**
 * FieldValue findMany
 */
export type FindManyFieldValueArgs = {
  /**
   * Select specific fields to fetch from the FieldValue
  **/
  select?: FieldValueSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FieldValueInclude | null
  /**
   * Filter, which FieldValues to fetch.
  **/
  where?: FieldValueWhereInput
  /**
   * Determine the order of the FieldValues to fetch.
  **/
  orderBy?: FieldValueOrderByInput
  /**
   * Sets the position for listing FieldValues.
  **/
  cursor?: FieldValueWhereUniqueInput
  /**
   * The number of FieldValues to fetch. If negative number, it will take FieldValues before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` FieldValues.
  **/
  skip?: number
}


/**
 * FieldValue create
 */
export type FieldValueCreateArgs = {
  /**
   * Select specific fields to fetch from the FieldValue
  **/
  select?: FieldValueSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FieldValueInclude | null
  /**
   * The data needed to create a FieldValue.
  **/
  data: FieldValueCreateInput
}


/**
 * FieldValue update
 */
export type FieldValueUpdateArgs = {
  /**
   * Select specific fields to fetch from the FieldValue
  **/
  select?: FieldValueSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FieldValueInclude | null
  /**
   * The data needed to update a FieldValue.
  **/
  data: FieldValueUpdateInput
  /**
   * Choose, which FieldValue to update.
  **/
  where: FieldValueWhereUniqueInput
}


/**
 * FieldValue updateMany
 */
export type FieldValueUpdateManyArgs = {
  data: FieldValueUpdateManyMutationInput
  where?: FieldValueWhereInput
}


/**
 * FieldValue upsert
 */
export type FieldValueUpsertArgs = {
  /**
   * Select specific fields to fetch from the FieldValue
  **/
  select?: FieldValueSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FieldValueInclude | null
  /**
   * The filter to search for the FieldValue to update in case it exists.
  **/
  where: FieldValueWhereUniqueInput
  /**
   * In case the FieldValue found by the `where` argument doesn't exist, create a new FieldValue with this data.
  **/
  create: FieldValueCreateInput
  /**
   * In case the FieldValue was found with the provided `where` argument, update it with this data.
  **/
  update: FieldValueUpdateInput
}


/**
 * FieldValue delete
 */
export type FieldValueDeleteArgs = {
  /**
   * Select specific fields to fetch from the FieldValue
  **/
  select?: FieldValueSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FieldValueInclude | null
  /**
   * Filter which FieldValue to delete.
  **/
  where: FieldValueWhereUniqueInput
}


/**
 * FieldValue deleteMany
 */
export type FieldValueDeleteManyArgs = {
  where?: FieldValueWhereInput
}


/**
 * FieldValue without action
 */
export type FieldValueArgs = {
  /**
   * Select specific fields to fetch from the FieldValue
  **/
  select?: FieldValueSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FieldValueInclude | null
}



/**
 * Model Application
 */

export type Application = {
  id: string
  wid: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
  jobId: string
  candidateId: string
  sourceId: string
  stageId: string
}


export type AggregateApplication = {
  count: number
}



export type AggregateApplicationArgs = {
  where?: ApplicationWhereInput
  orderBy?: ApplicationOrderByInput
  cursor?: ApplicationWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetApplicationAggregateType<T extends AggregateApplicationArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type ApplicationSelect = {
  id?: boolean
  node?: boolean | NodeArgs
  wid?: boolean
  workspace?: boolean | WorkspaceArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  job?: boolean | JobArgs
  jobId?: boolean
  candidate?: boolean | CandidateArgs
  candidateId?: boolean
  source?: boolean | SourceArgs
  sourceId?: boolean
  stage?: boolean | StageArgs
  stageId?: boolean
  reviews?: boolean | FindManyReviewArgs
}

export type ApplicationInclude = {
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  job?: boolean | JobArgs
  candidate?: boolean | CandidateArgs
  source?: boolean | SourceArgs
  stage?: boolean | StageArgs
  reviews?: boolean | FindManyReviewArgs
}

export type ApplicationGetPayload<
  S extends boolean | null | undefined | ApplicationArgs,
  U = keyof S
> = S extends true
  ? Application
  : S extends undefined
  ? never
  : S extends ApplicationArgs | FindManyApplicationArgs
  ? 'include' extends U
    ? Application  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['include'][P]> :
      P extends 'job'
      ? JobGetPayload<S['include'][P]> :
      P extends 'candidate'
      ? CandidateGetPayload<S['include'][P]> :
      P extends 'source'
      ? SourceGetPayload<S['include'][P]> :
      P extends 'stage'
      ? StageGetPayload<S['include'][P]> :
      P extends 'reviews'
      ? Array<ReviewGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Application ? Application[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['select'][P]> :
      P extends 'job'
      ? JobGetPayload<S['select'][P]> :
      P extends 'candidate'
      ? CandidateGetPayload<S['select'][P]> :
      P extends 'source'
      ? SourceGetPayload<S['select'][P]> :
      P extends 'stage'
      ? StageGetPayload<S['select'][P]> :
      P extends 'reviews'
      ? Array<ReviewGetPayload<S['select'][P]>> : never
    }
  : Application
: Application


export interface ApplicationDelegate {
  /**
   * Find zero or one Application.
   * @param {FindOneApplicationArgs} args - Arguments to find a Application
   * @example
   * // Get one Application
   * const application = await prisma.application.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneApplicationArgs>(
    args: Subset<T, FindOneApplicationArgs>
  ): CheckSelect<T, Prisma__ApplicationClient<Application | null>, Prisma__ApplicationClient<ApplicationGetPayload<T> | null>>
  /**
   * Find zero or more Applications.
   * @param {FindManyApplicationArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Applications
   * const applications = await prisma.application.findMany()
   * 
   * // Get first 10 Applications
   * const applications = await prisma.application.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const applicationWithIdOnly = await prisma.application.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyApplicationArgs>(
    args?: Subset<T, FindManyApplicationArgs>
  ): CheckSelect<T, Promise<Array<Application>>, Promise<Array<ApplicationGetPayload<T>>>>
  /**
   * Create a Application.
   * @param {ApplicationCreateArgs} args - Arguments to create a Application.
   * @example
   * // Create one Application
   * const Application = await prisma.application.create({
   *   data: {
   *     // ... data to create a Application
   *   }
   * })
   * 
  **/
  create<T extends ApplicationCreateArgs>(
    args: Subset<T, ApplicationCreateArgs>
  ): CheckSelect<T, Prisma__ApplicationClient<Application>, Prisma__ApplicationClient<ApplicationGetPayload<T>>>
  /**
   * Delete a Application.
   * @param {ApplicationDeleteArgs} args - Arguments to delete one Application.
   * @example
   * // Delete one Application
   * const Application = await prisma.application.delete({
   *   where: {
   *     // ... filter to delete one Application
   *   }
   * })
   * 
  **/
  delete<T extends ApplicationDeleteArgs>(
    args: Subset<T, ApplicationDeleteArgs>
  ): CheckSelect<T, Prisma__ApplicationClient<Application>, Prisma__ApplicationClient<ApplicationGetPayload<T>>>
  /**
   * Update one Application.
   * @param {ApplicationUpdateArgs} args - Arguments to update one Application.
   * @example
   * // Update one Application
   * const application = await prisma.application.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ApplicationUpdateArgs>(
    args: Subset<T, ApplicationUpdateArgs>
  ): CheckSelect<T, Prisma__ApplicationClient<Application>, Prisma__ApplicationClient<ApplicationGetPayload<T>>>
  /**
   * Delete zero or more Applications.
   * @param {ApplicationDeleteManyArgs} args - Arguments to filter Applications to delete.
   * @example
   * // Delete a few Applications
   * const { count } = await prisma.application.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ApplicationDeleteManyArgs>(
    args: Subset<T, ApplicationDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Applications.
   * @param {ApplicationUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Applications
   * const application = await prisma.application.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ApplicationUpdateManyArgs>(
    args: Subset<T, ApplicationUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Application.
   * @param {ApplicationUpsertArgs} args - Arguments to update or create a Application.
   * @example
   * // Update or create a Application
   * const application = await prisma.application.upsert({
   *   create: {
   *     // ... data to create a Application
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Application we want to update
   *   }
   * })
  **/
  upsert<T extends ApplicationUpsertArgs>(
    args: Subset<T, ApplicationUpsertArgs>
  ): CheckSelect<T, Prisma__ApplicationClient<Application>, Prisma__ApplicationClient<ApplicationGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyApplicationArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateApplicationArgs>(args: Subset<T, AggregateApplicationArgs>): Promise<GetApplicationAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for Application.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ApplicationClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>;

  job<T extends JobArgs = {}>(args?: Subset<T, JobArgs>): CheckSelect<T, Prisma__JobClient<Job | null>, Prisma__JobClient<JobGetPayload<T> | null>>;

  candidate<T extends CandidateArgs = {}>(args?: Subset<T, CandidateArgs>): CheckSelect<T, Prisma__CandidateClient<Candidate | null>, Prisma__CandidateClient<CandidateGetPayload<T> | null>>;

  source<T extends SourceArgs = {}>(args?: Subset<T, SourceArgs>): CheckSelect<T, Prisma__SourceClient<Source | null>, Prisma__SourceClient<SourceGetPayload<T> | null>>;

  stage<T extends StageArgs = {}>(args?: Subset<T, StageArgs>): CheckSelect<T, Prisma__StageClient<Stage | null>, Prisma__StageClient<StageGetPayload<T> | null>>;

  reviews<T extends FindManyReviewArgs = {}>(args?: Subset<T, FindManyReviewArgs>): CheckSelect<T, Promise<Array<Review>>, Promise<Array<ReviewGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Application findOne
 */
export type FindOneApplicationArgs = {
  /**
   * Select specific fields to fetch from the Application
  **/
  select?: ApplicationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ApplicationInclude | null
  /**
   * Filter, which Application to fetch.
  **/
  where: ApplicationWhereUniqueInput
}


/**
 * Application findMany
 */
export type FindManyApplicationArgs = {
  /**
   * Select specific fields to fetch from the Application
  **/
  select?: ApplicationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ApplicationInclude | null
  /**
   * Filter, which Applications to fetch.
  **/
  where?: ApplicationWhereInput
  /**
   * Determine the order of the Applications to fetch.
  **/
  orderBy?: ApplicationOrderByInput
  /**
   * Sets the position for listing Applications.
  **/
  cursor?: ApplicationWhereUniqueInput
  /**
   * The number of Applications to fetch. If negative number, it will take Applications before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Applications.
  **/
  skip?: number
}


/**
 * Application create
 */
export type ApplicationCreateArgs = {
  /**
   * Select specific fields to fetch from the Application
  **/
  select?: ApplicationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ApplicationInclude | null
  /**
   * The data needed to create a Application.
  **/
  data: ApplicationCreateInput
}


/**
 * Application update
 */
export type ApplicationUpdateArgs = {
  /**
   * Select specific fields to fetch from the Application
  **/
  select?: ApplicationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ApplicationInclude | null
  /**
   * The data needed to update a Application.
  **/
  data: ApplicationUpdateInput
  /**
   * Choose, which Application to update.
  **/
  where: ApplicationWhereUniqueInput
}


/**
 * Application updateMany
 */
export type ApplicationUpdateManyArgs = {
  data: ApplicationUpdateManyMutationInput
  where?: ApplicationWhereInput
}


/**
 * Application upsert
 */
export type ApplicationUpsertArgs = {
  /**
   * Select specific fields to fetch from the Application
  **/
  select?: ApplicationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ApplicationInclude | null
  /**
   * The filter to search for the Application to update in case it exists.
  **/
  where: ApplicationWhereUniqueInput
  /**
   * In case the Application found by the `where` argument doesn't exist, create a new Application with this data.
  **/
  create: ApplicationCreateInput
  /**
   * In case the Application was found with the provided `where` argument, update it with this data.
  **/
  update: ApplicationUpdateInput
}


/**
 * Application delete
 */
export type ApplicationDeleteArgs = {
  /**
   * Select specific fields to fetch from the Application
  **/
  select?: ApplicationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ApplicationInclude | null
  /**
   * Filter which Application to delete.
  **/
  where: ApplicationWhereUniqueInput
}


/**
 * Application deleteMany
 */
export type ApplicationDeleteManyArgs = {
  where?: ApplicationWhereInput
}


/**
 * Application without action
 */
export type ApplicationArgs = {
  /**
   * Select specific fields to fetch from the Application
  **/
  select?: ApplicationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ApplicationInclude | null
}



/**
 * Model Job
 */

export type Job = {
  id: string
  wid: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
  name: string
  description: string | null
  status: JobStatus
  clientId: string
}


export type AggregateJob = {
  count: number
}



export type AggregateJobArgs = {
  where?: JobWhereInput
  orderBy?: JobOrderByInput
  cursor?: JobWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetJobAggregateType<T extends AggregateJobArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type JobSelect = {
  id?: boolean
  node?: boolean | NodeArgs
  wid?: boolean
  workspace?: boolean | WorkspaceArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  name?: boolean
  description?: boolean
  status?: boolean
  client?: boolean | ClientArgs
  clientId?: boolean
  applications?: boolean | FindManyApplicationArgs
  locations?: boolean | FindManyLocationArgs
}

export type JobInclude = {
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  client?: boolean | ClientArgs
  applications?: boolean | FindManyApplicationArgs
  locations?: boolean | FindManyLocationArgs
}

export type JobGetPayload<
  S extends boolean | null | undefined | JobArgs,
  U = keyof S
> = S extends true
  ? Job
  : S extends undefined
  ? never
  : S extends JobArgs | FindManyJobArgs
  ? 'include' extends U
    ? Job  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['include'][P]> :
      P extends 'client'
      ? ClientGetPayload<S['include'][P]> :
      P extends 'applications'
      ? Array<ApplicationGetPayload<S['include'][P]>> :
      P extends 'locations'
      ? Array<LocationGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Job ? Job[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['select'][P]> :
      P extends 'client'
      ? ClientGetPayload<S['select'][P]> :
      P extends 'applications'
      ? Array<ApplicationGetPayload<S['select'][P]>> :
      P extends 'locations'
      ? Array<LocationGetPayload<S['select'][P]>> : never
    }
  : Job
: Job


export interface JobDelegate {
  /**
   * Find zero or one Job.
   * @param {FindOneJobArgs} args - Arguments to find a Job
   * @example
   * // Get one Job
   * const job = await prisma.job.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneJobArgs>(
    args: Subset<T, FindOneJobArgs>
  ): CheckSelect<T, Prisma__JobClient<Job | null>, Prisma__JobClient<JobGetPayload<T> | null>>
  /**
   * Find zero or more Jobs.
   * @param {FindManyJobArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Jobs
   * const jobs = await prisma.job.findMany()
   * 
   * // Get first 10 Jobs
   * const jobs = await prisma.job.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const jobWithIdOnly = await prisma.job.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyJobArgs>(
    args?: Subset<T, FindManyJobArgs>
  ): CheckSelect<T, Promise<Array<Job>>, Promise<Array<JobGetPayload<T>>>>
  /**
   * Create a Job.
   * @param {JobCreateArgs} args - Arguments to create a Job.
   * @example
   * // Create one Job
   * const Job = await prisma.job.create({
   *   data: {
   *     // ... data to create a Job
   *   }
   * })
   * 
  **/
  create<T extends JobCreateArgs>(
    args: Subset<T, JobCreateArgs>
  ): CheckSelect<T, Prisma__JobClient<Job>, Prisma__JobClient<JobGetPayload<T>>>
  /**
   * Delete a Job.
   * @param {JobDeleteArgs} args - Arguments to delete one Job.
   * @example
   * // Delete one Job
   * const Job = await prisma.job.delete({
   *   where: {
   *     // ... filter to delete one Job
   *   }
   * })
   * 
  **/
  delete<T extends JobDeleteArgs>(
    args: Subset<T, JobDeleteArgs>
  ): CheckSelect<T, Prisma__JobClient<Job>, Prisma__JobClient<JobGetPayload<T>>>
  /**
   * Update one Job.
   * @param {JobUpdateArgs} args - Arguments to update one Job.
   * @example
   * // Update one Job
   * const job = await prisma.job.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends JobUpdateArgs>(
    args: Subset<T, JobUpdateArgs>
  ): CheckSelect<T, Prisma__JobClient<Job>, Prisma__JobClient<JobGetPayload<T>>>
  /**
   * Delete zero or more Jobs.
   * @param {JobDeleteManyArgs} args - Arguments to filter Jobs to delete.
   * @example
   * // Delete a few Jobs
   * const { count } = await prisma.job.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends JobDeleteManyArgs>(
    args: Subset<T, JobDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Jobs.
   * @param {JobUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Jobs
   * const job = await prisma.job.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends JobUpdateManyArgs>(
    args: Subset<T, JobUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Job.
   * @param {JobUpsertArgs} args - Arguments to update or create a Job.
   * @example
   * // Update or create a Job
   * const job = await prisma.job.upsert({
   *   create: {
   *     // ... data to create a Job
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Job we want to update
   *   }
   * })
  **/
  upsert<T extends JobUpsertArgs>(
    args: Subset<T, JobUpsertArgs>
  ): CheckSelect<T, Prisma__JobClient<Job>, Prisma__JobClient<JobGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyJobArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateJobArgs>(args: Subset<T, AggregateJobArgs>): Promise<GetJobAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for Job.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__JobClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>;

  client<T extends ClientArgs = {}>(args?: Subset<T, ClientArgs>): CheckSelect<T, Prisma__ClientClient<Client | null>, Prisma__ClientClient<ClientGetPayload<T> | null>>;

  applications<T extends FindManyApplicationArgs = {}>(args?: Subset<T, FindManyApplicationArgs>): CheckSelect<T, Promise<Array<Application>>, Promise<Array<ApplicationGetPayload<T>>>>;

  locations<T extends FindManyLocationArgs = {}>(args?: Subset<T, FindManyLocationArgs>): CheckSelect<T, Promise<Array<Location>>, Promise<Array<LocationGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Job findOne
 */
export type FindOneJobArgs = {
  /**
   * Select specific fields to fetch from the Job
  **/
  select?: JobSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: JobInclude | null
  /**
   * Filter, which Job to fetch.
  **/
  where: JobWhereUniqueInput
}


/**
 * Job findMany
 */
export type FindManyJobArgs = {
  /**
   * Select specific fields to fetch from the Job
  **/
  select?: JobSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: JobInclude | null
  /**
   * Filter, which Jobs to fetch.
  **/
  where?: JobWhereInput
  /**
   * Determine the order of the Jobs to fetch.
  **/
  orderBy?: JobOrderByInput
  /**
   * Sets the position for listing Jobs.
  **/
  cursor?: JobWhereUniqueInput
  /**
   * The number of Jobs to fetch. If negative number, it will take Jobs before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Jobs.
  **/
  skip?: number
}


/**
 * Job create
 */
export type JobCreateArgs = {
  /**
   * Select specific fields to fetch from the Job
  **/
  select?: JobSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: JobInclude | null
  /**
   * The data needed to create a Job.
  **/
  data: JobCreateInput
}


/**
 * Job update
 */
export type JobUpdateArgs = {
  /**
   * Select specific fields to fetch from the Job
  **/
  select?: JobSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: JobInclude | null
  /**
   * The data needed to update a Job.
  **/
  data: JobUpdateInput
  /**
   * Choose, which Job to update.
  **/
  where: JobWhereUniqueInput
}


/**
 * Job updateMany
 */
export type JobUpdateManyArgs = {
  data: JobUpdateManyMutationInput
  where?: JobWhereInput
}


/**
 * Job upsert
 */
export type JobUpsertArgs = {
  /**
   * Select specific fields to fetch from the Job
  **/
  select?: JobSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: JobInclude | null
  /**
   * The filter to search for the Job to update in case it exists.
  **/
  where: JobWhereUniqueInput
  /**
   * In case the Job found by the `where` argument doesn't exist, create a new Job with this data.
  **/
  create: JobCreateInput
  /**
   * In case the Job was found with the provided `where` argument, update it with this data.
  **/
  update: JobUpdateInput
}


/**
 * Job delete
 */
export type JobDeleteArgs = {
  /**
   * Select specific fields to fetch from the Job
  **/
  select?: JobSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: JobInclude | null
  /**
   * Filter which Job to delete.
  **/
  where: JobWhereUniqueInput
}


/**
 * Job deleteMany
 */
export type JobDeleteManyArgs = {
  where?: JobWhereInput
}


/**
 * Job without action
 */
export type JobArgs = {
  /**
   * Select specific fields to fetch from the Job
  **/
  select?: JobSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: JobInclude | null
}



/**
 * Model Location
 */

export type Location = {
  id: string
  wid: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
  name: string | null
  description: string | null
  country: string
  city: string | null
}


export type AggregateLocation = {
  count: number
}



export type AggregateLocationArgs = {
  where?: LocationWhereInput
  orderBy?: LocationOrderByInput
  cursor?: LocationWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetLocationAggregateType<T extends AggregateLocationArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type LocationSelect = {
  id?: boolean
  node?: boolean | NodeArgs
  wid?: boolean
  workspace?: boolean | WorkspaceArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  name?: boolean
  description?: boolean
  country?: boolean
  city?: boolean
  jobs?: boolean | FindManyJobArgs
}

export type LocationInclude = {
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  jobs?: boolean | FindManyJobArgs
}

export type LocationGetPayload<
  S extends boolean | null | undefined | LocationArgs,
  U = keyof S
> = S extends true
  ? Location
  : S extends undefined
  ? never
  : S extends LocationArgs | FindManyLocationArgs
  ? 'include' extends U
    ? Location  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['include'][P]> :
      P extends 'jobs'
      ? Array<JobGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Location ? Location[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['select'][P]> :
      P extends 'jobs'
      ? Array<JobGetPayload<S['select'][P]>> : never
    }
  : Location
: Location


export interface LocationDelegate {
  /**
   * Find zero or one Location.
   * @param {FindOneLocationArgs} args - Arguments to find a Location
   * @example
   * // Get one Location
   * const location = await prisma.location.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneLocationArgs>(
    args: Subset<T, FindOneLocationArgs>
  ): CheckSelect<T, Prisma__LocationClient<Location | null>, Prisma__LocationClient<LocationGetPayload<T> | null>>
  /**
   * Find zero or more Locations.
   * @param {FindManyLocationArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Locations
   * const locations = await prisma.location.findMany()
   * 
   * // Get first 10 Locations
   * const locations = await prisma.location.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyLocationArgs>(
    args?: Subset<T, FindManyLocationArgs>
  ): CheckSelect<T, Promise<Array<Location>>, Promise<Array<LocationGetPayload<T>>>>
  /**
   * Create a Location.
   * @param {LocationCreateArgs} args - Arguments to create a Location.
   * @example
   * // Create one Location
   * const Location = await prisma.location.create({
   *   data: {
   *     // ... data to create a Location
   *   }
   * })
   * 
  **/
  create<T extends LocationCreateArgs>(
    args: Subset<T, LocationCreateArgs>
  ): CheckSelect<T, Prisma__LocationClient<Location>, Prisma__LocationClient<LocationGetPayload<T>>>
  /**
   * Delete a Location.
   * @param {LocationDeleteArgs} args - Arguments to delete one Location.
   * @example
   * // Delete one Location
   * const Location = await prisma.location.delete({
   *   where: {
   *     // ... filter to delete one Location
   *   }
   * })
   * 
  **/
  delete<T extends LocationDeleteArgs>(
    args: Subset<T, LocationDeleteArgs>
  ): CheckSelect<T, Prisma__LocationClient<Location>, Prisma__LocationClient<LocationGetPayload<T>>>
  /**
   * Update one Location.
   * @param {LocationUpdateArgs} args - Arguments to update one Location.
   * @example
   * // Update one Location
   * const location = await prisma.location.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends LocationUpdateArgs>(
    args: Subset<T, LocationUpdateArgs>
  ): CheckSelect<T, Prisma__LocationClient<Location>, Prisma__LocationClient<LocationGetPayload<T>>>
  /**
   * Delete zero or more Locations.
   * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
   * @example
   * // Delete a few Locations
   * const { count } = await prisma.location.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends LocationDeleteManyArgs>(
    args: Subset<T, LocationDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Locations.
   * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Locations
   * const location = await prisma.location.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends LocationUpdateManyArgs>(
    args: Subset<T, LocationUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Location.
   * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
   * @example
   * // Update or create a Location
   * const location = await prisma.location.upsert({
   *   create: {
   *     // ... data to create a Location
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Location we want to update
   *   }
   * })
  **/
  upsert<T extends LocationUpsertArgs>(
    args: Subset<T, LocationUpsertArgs>
  ): CheckSelect<T, Prisma__LocationClient<Location>, Prisma__LocationClient<LocationGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyLocationArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateLocationArgs>(args: Subset<T, AggregateLocationArgs>): Promise<GetLocationAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for Location.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__LocationClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>;

  jobs<T extends FindManyJobArgs = {}>(args?: Subset<T, FindManyJobArgs>): CheckSelect<T, Promise<Array<Job>>, Promise<Array<JobGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Location findOne
 */
export type FindOneLocationArgs = {
  /**
   * Select specific fields to fetch from the Location
  **/
  select?: LocationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: LocationInclude | null
  /**
   * Filter, which Location to fetch.
  **/
  where: LocationWhereUniqueInput
}


/**
 * Location findMany
 */
export type FindManyLocationArgs = {
  /**
   * Select specific fields to fetch from the Location
  **/
  select?: LocationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: LocationInclude | null
  /**
   * Filter, which Locations to fetch.
  **/
  where?: LocationWhereInput
  /**
   * Determine the order of the Locations to fetch.
  **/
  orderBy?: LocationOrderByInput
  /**
   * Sets the position for listing Locations.
  **/
  cursor?: LocationWhereUniqueInput
  /**
   * The number of Locations to fetch. If negative number, it will take Locations before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Locations.
  **/
  skip?: number
}


/**
 * Location create
 */
export type LocationCreateArgs = {
  /**
   * Select specific fields to fetch from the Location
  **/
  select?: LocationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: LocationInclude | null
  /**
   * The data needed to create a Location.
  **/
  data: LocationCreateInput
}


/**
 * Location update
 */
export type LocationUpdateArgs = {
  /**
   * Select specific fields to fetch from the Location
  **/
  select?: LocationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: LocationInclude | null
  /**
   * The data needed to update a Location.
  **/
  data: LocationUpdateInput
  /**
   * Choose, which Location to update.
  **/
  where: LocationWhereUniqueInput
}


/**
 * Location updateMany
 */
export type LocationUpdateManyArgs = {
  data: LocationUpdateManyMutationInput
  where?: LocationWhereInput
}


/**
 * Location upsert
 */
export type LocationUpsertArgs = {
  /**
   * Select specific fields to fetch from the Location
  **/
  select?: LocationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: LocationInclude | null
  /**
   * The filter to search for the Location to update in case it exists.
  **/
  where: LocationWhereUniqueInput
  /**
   * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
  **/
  create: LocationCreateInput
  /**
   * In case the Location was found with the provided `where` argument, update it with this data.
  **/
  update: LocationUpdateInput
}


/**
 * Location delete
 */
export type LocationDeleteArgs = {
  /**
   * Select specific fields to fetch from the Location
  **/
  select?: LocationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: LocationInclude | null
  /**
   * Filter which Location to delete.
  **/
  where: LocationWhereUniqueInput
}


/**
 * Location deleteMany
 */
export type LocationDeleteManyArgs = {
  where?: LocationWhereInput
}


/**
 * Location without action
 */
export type LocationArgs = {
  /**
   * Select specific fields to fetch from the Location
  **/
  select?: LocationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: LocationInclude | null
}



/**
 * Model Tag
 */

export type Tag = {
  id: string
  wid: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
  name: string
  description: string | null
  types: TagType[]
}


export type AggregateTag = {
  count: number
}



export type AggregateTagArgs = {
  where?: TagWhereInput
  orderBy?: TagOrderByInput
  cursor?: TagWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetTagAggregateType<T extends AggregateTagArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type TagSelect = {
  id?: boolean
  wid?: boolean
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  name?: boolean
  description?: boolean
  types?: boolean
  candidates?: boolean | FindManyCandidateArgs
}

export type TagInclude = {
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  candidates?: boolean | FindManyCandidateArgs
}

export type TagGetPayload<
  S extends boolean | null | undefined | TagArgs,
  U = keyof S
> = S extends true
  ? Tag
  : S extends undefined
  ? never
  : S extends TagArgs | FindManyTagArgs
  ? 'include' extends U
    ? Tag  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['include'][P]> :
      P extends 'candidates'
      ? Array<CandidateGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Tag ? Tag[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['select'][P]> :
      P extends 'candidates'
      ? Array<CandidateGetPayload<S['select'][P]>> : never
    }
  : Tag
: Tag


export interface TagDelegate {
  /**
   * Find zero or one Tag.
   * @param {FindOneTagArgs} args - Arguments to find a Tag
   * @example
   * // Get one Tag
   * const tag = await prisma.tag.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneTagArgs>(
    args: Subset<T, FindOneTagArgs>
  ): CheckSelect<T, Prisma__TagClient<Tag | null>, Prisma__TagClient<TagGetPayload<T> | null>>
  /**
   * Find zero or more Tags.
   * @param {FindManyTagArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Tags
   * const tags = await prisma.tag.findMany()
   * 
   * // Get first 10 Tags
   * const tags = await prisma.tag.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyTagArgs>(
    args?: Subset<T, FindManyTagArgs>
  ): CheckSelect<T, Promise<Array<Tag>>, Promise<Array<TagGetPayload<T>>>>
  /**
   * Create a Tag.
   * @param {TagCreateArgs} args - Arguments to create a Tag.
   * @example
   * // Create one Tag
   * const Tag = await prisma.tag.create({
   *   data: {
   *     // ... data to create a Tag
   *   }
   * })
   * 
  **/
  create<T extends TagCreateArgs>(
    args: Subset<T, TagCreateArgs>
  ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>
  /**
   * Delete a Tag.
   * @param {TagDeleteArgs} args - Arguments to delete one Tag.
   * @example
   * // Delete one Tag
   * const Tag = await prisma.tag.delete({
   *   where: {
   *     // ... filter to delete one Tag
   *   }
   * })
   * 
  **/
  delete<T extends TagDeleteArgs>(
    args: Subset<T, TagDeleteArgs>
  ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>
  /**
   * Update one Tag.
   * @param {TagUpdateArgs} args - Arguments to update one Tag.
   * @example
   * // Update one Tag
   * const tag = await prisma.tag.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends TagUpdateArgs>(
    args: Subset<T, TagUpdateArgs>
  ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>
  /**
   * Delete zero or more Tags.
   * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
   * @example
   * // Delete a few Tags
   * const { count } = await prisma.tag.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends TagDeleteManyArgs>(
    args: Subset<T, TagDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Tags.
   * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Tags
   * const tag = await prisma.tag.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends TagUpdateManyArgs>(
    args: Subset<T, TagUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Tag.
   * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
   * @example
   * // Update or create a Tag
   * const tag = await prisma.tag.upsert({
   *   create: {
   *     // ... data to create a Tag
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Tag we want to update
   *   }
   * })
  **/
  upsert<T extends TagUpsertArgs>(
    args: Subset<T, TagUpsertArgs>
  ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyTagArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateTagArgs>(args: Subset<T, AggregateTagArgs>): Promise<GetTagAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for Tag.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__TagClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>;

  candidates<T extends FindManyCandidateArgs = {}>(args?: Subset<T, FindManyCandidateArgs>): CheckSelect<T, Promise<Array<Candidate>>, Promise<Array<CandidateGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Tag findOne
 */
export type FindOneTagArgs = {
  /**
   * Select specific fields to fetch from the Tag
  **/
  select?: TagSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TagInclude | null
  /**
   * Filter, which Tag to fetch.
  **/
  where: TagWhereUniqueInput
}


/**
 * Tag findMany
 */
export type FindManyTagArgs = {
  /**
   * Select specific fields to fetch from the Tag
  **/
  select?: TagSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TagInclude | null
  /**
   * Filter, which Tags to fetch.
  **/
  where?: TagWhereInput
  /**
   * Determine the order of the Tags to fetch.
  **/
  orderBy?: TagOrderByInput
  /**
   * Sets the position for listing Tags.
  **/
  cursor?: TagWhereUniqueInput
  /**
   * The number of Tags to fetch. If negative number, it will take Tags before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Tags.
  **/
  skip?: number
}


/**
 * Tag create
 */
export type TagCreateArgs = {
  /**
   * Select specific fields to fetch from the Tag
  **/
  select?: TagSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TagInclude | null
  /**
   * The data needed to create a Tag.
  **/
  data: TagCreateInput
}


/**
 * Tag update
 */
export type TagUpdateArgs = {
  /**
   * Select specific fields to fetch from the Tag
  **/
  select?: TagSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TagInclude | null
  /**
   * The data needed to update a Tag.
  **/
  data: TagUpdateInput
  /**
   * Choose, which Tag to update.
  **/
  where: TagWhereUniqueInput
}


/**
 * Tag updateMany
 */
export type TagUpdateManyArgs = {
  data: TagUpdateManyMutationInput
  where?: TagWhereInput
}


/**
 * Tag upsert
 */
export type TagUpsertArgs = {
  /**
   * Select specific fields to fetch from the Tag
  **/
  select?: TagSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TagInclude | null
  /**
   * The filter to search for the Tag to update in case it exists.
  **/
  where: TagWhereUniqueInput
  /**
   * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
  **/
  create: TagCreateInput
  /**
   * In case the Tag was found with the provided `where` argument, update it with this data.
  **/
  update: TagUpdateInput
}


/**
 * Tag delete
 */
export type TagDeleteArgs = {
  /**
   * Select specific fields to fetch from the Tag
  **/
  select?: TagSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TagInclude | null
  /**
   * Filter which Tag to delete.
  **/
  where: TagWhereUniqueInput
}


/**
 * Tag deleteMany
 */
export type TagDeleteManyArgs = {
  where?: TagWhereInput
}


/**
 * Tag without action
 */
export type TagArgs = {
  /**
   * Select specific fields to fetch from the Tag
  **/
  select?: TagSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TagInclude | null
}



/**
 * Model Source
 */

export type Source = {
  id: string
  wid: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
  name: string
  description: string | null
}


export type AggregateSource = {
  count: number
}



export type AggregateSourceArgs = {
  where?: SourceWhereInput
  orderBy?: SourceOrderByInput
  cursor?: SourceWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetSourceAggregateType<T extends AggregateSourceArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type SourceSelect = {
  id?: boolean
  wid?: boolean
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  name?: boolean
  description?: boolean
  applications?: boolean | FindManyApplicationArgs
}

export type SourceInclude = {
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  applications?: boolean | FindManyApplicationArgs
}

export type SourceGetPayload<
  S extends boolean | null | undefined | SourceArgs,
  U = keyof S
> = S extends true
  ? Source
  : S extends undefined
  ? never
  : S extends SourceArgs | FindManySourceArgs
  ? 'include' extends U
    ? Source  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['include'][P]> :
      P extends 'applications'
      ? Array<ApplicationGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Source ? Source[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['select'][P]> :
      P extends 'applications'
      ? Array<ApplicationGetPayload<S['select'][P]>> : never
    }
  : Source
: Source


export interface SourceDelegate {
  /**
   * Find zero or one Source.
   * @param {FindOneSourceArgs} args - Arguments to find a Source
   * @example
   * // Get one Source
   * const source = await prisma.source.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneSourceArgs>(
    args: Subset<T, FindOneSourceArgs>
  ): CheckSelect<T, Prisma__SourceClient<Source | null>, Prisma__SourceClient<SourceGetPayload<T> | null>>
  /**
   * Find zero or more Sources.
   * @param {FindManySourceArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Sources
   * const sources = await prisma.source.findMany()
   * 
   * // Get first 10 Sources
   * const sources = await prisma.source.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const sourceWithIdOnly = await prisma.source.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManySourceArgs>(
    args?: Subset<T, FindManySourceArgs>
  ): CheckSelect<T, Promise<Array<Source>>, Promise<Array<SourceGetPayload<T>>>>
  /**
   * Create a Source.
   * @param {SourceCreateArgs} args - Arguments to create a Source.
   * @example
   * // Create one Source
   * const Source = await prisma.source.create({
   *   data: {
   *     // ... data to create a Source
   *   }
   * })
   * 
  **/
  create<T extends SourceCreateArgs>(
    args: Subset<T, SourceCreateArgs>
  ): CheckSelect<T, Prisma__SourceClient<Source>, Prisma__SourceClient<SourceGetPayload<T>>>
  /**
   * Delete a Source.
   * @param {SourceDeleteArgs} args - Arguments to delete one Source.
   * @example
   * // Delete one Source
   * const Source = await prisma.source.delete({
   *   where: {
   *     // ... filter to delete one Source
   *   }
   * })
   * 
  **/
  delete<T extends SourceDeleteArgs>(
    args: Subset<T, SourceDeleteArgs>
  ): CheckSelect<T, Prisma__SourceClient<Source>, Prisma__SourceClient<SourceGetPayload<T>>>
  /**
   * Update one Source.
   * @param {SourceUpdateArgs} args - Arguments to update one Source.
   * @example
   * // Update one Source
   * const source = await prisma.source.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends SourceUpdateArgs>(
    args: Subset<T, SourceUpdateArgs>
  ): CheckSelect<T, Prisma__SourceClient<Source>, Prisma__SourceClient<SourceGetPayload<T>>>
  /**
   * Delete zero or more Sources.
   * @param {SourceDeleteManyArgs} args - Arguments to filter Sources to delete.
   * @example
   * // Delete a few Sources
   * const { count } = await prisma.source.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends SourceDeleteManyArgs>(
    args: Subset<T, SourceDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Sources.
   * @param {SourceUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Sources
   * const source = await prisma.source.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends SourceUpdateManyArgs>(
    args: Subset<T, SourceUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Source.
   * @param {SourceUpsertArgs} args - Arguments to update or create a Source.
   * @example
   * // Update or create a Source
   * const source = await prisma.source.upsert({
   *   create: {
   *     // ... data to create a Source
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Source we want to update
   *   }
   * })
  **/
  upsert<T extends SourceUpsertArgs>(
    args: Subset<T, SourceUpsertArgs>
  ): CheckSelect<T, Prisma__SourceClient<Source>, Prisma__SourceClient<SourceGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManySourceArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateSourceArgs>(args: Subset<T, AggregateSourceArgs>): Promise<GetSourceAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for Source.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__SourceClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>;

  applications<T extends FindManyApplicationArgs = {}>(args?: Subset<T, FindManyApplicationArgs>): CheckSelect<T, Promise<Array<Application>>, Promise<Array<ApplicationGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Source findOne
 */
export type FindOneSourceArgs = {
  /**
   * Select specific fields to fetch from the Source
  **/
  select?: SourceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: SourceInclude | null
  /**
   * Filter, which Source to fetch.
  **/
  where: SourceWhereUniqueInput
}


/**
 * Source findMany
 */
export type FindManySourceArgs = {
  /**
   * Select specific fields to fetch from the Source
  **/
  select?: SourceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: SourceInclude | null
  /**
   * Filter, which Sources to fetch.
  **/
  where?: SourceWhereInput
  /**
   * Determine the order of the Sources to fetch.
  **/
  orderBy?: SourceOrderByInput
  /**
   * Sets the position for listing Sources.
  **/
  cursor?: SourceWhereUniqueInput
  /**
   * The number of Sources to fetch. If negative number, it will take Sources before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Sources.
  **/
  skip?: number
}


/**
 * Source create
 */
export type SourceCreateArgs = {
  /**
   * Select specific fields to fetch from the Source
  **/
  select?: SourceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: SourceInclude | null
  /**
   * The data needed to create a Source.
  **/
  data: SourceCreateInput
}


/**
 * Source update
 */
export type SourceUpdateArgs = {
  /**
   * Select specific fields to fetch from the Source
  **/
  select?: SourceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: SourceInclude | null
  /**
   * The data needed to update a Source.
  **/
  data: SourceUpdateInput
  /**
   * Choose, which Source to update.
  **/
  where: SourceWhereUniqueInput
}


/**
 * Source updateMany
 */
export type SourceUpdateManyArgs = {
  data: SourceUpdateManyMutationInput
  where?: SourceWhereInput
}


/**
 * Source upsert
 */
export type SourceUpsertArgs = {
  /**
   * Select specific fields to fetch from the Source
  **/
  select?: SourceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: SourceInclude | null
  /**
   * The filter to search for the Source to update in case it exists.
  **/
  where: SourceWhereUniqueInput
  /**
   * In case the Source found by the `where` argument doesn't exist, create a new Source with this data.
  **/
  create: SourceCreateInput
  /**
   * In case the Source was found with the provided `where` argument, update it with this data.
  **/
  update: SourceUpdateInput
}


/**
 * Source delete
 */
export type SourceDeleteArgs = {
  /**
   * Select specific fields to fetch from the Source
  **/
  select?: SourceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: SourceInclude | null
  /**
   * Filter which Source to delete.
  **/
  where: SourceWhereUniqueInput
}


/**
 * Source deleteMany
 */
export type SourceDeleteManyArgs = {
  where?: SourceWhereInput
}


/**
 * Source without action
 */
export type SourceArgs = {
  /**
   * Select specific fields to fetch from the Source
  **/
  select?: SourceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: SourceInclude | null
}



/**
 * Model Comment
 */

export type Comment = {
  id: string
  wid: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
  message: string
  authorId: string
  parentId: string | null
}


export type AggregateComment = {
  count: number
}



export type AggregateCommentArgs = {
  where?: CommentWhereInput
  orderBy?: CommentOrderByInput
  cursor?: CommentWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetCommentAggregateType<T extends AggregateCommentArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type CommentSelect = {
  id?: boolean
  wid?: boolean
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  message?: boolean
  author?: boolean | UserArgs
  authorId?: boolean
  parent?: boolean | CommentArgs
  parentId?: boolean
  replies?: boolean | FindManyCommentArgs
}

export type CommentInclude = {
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  author?: boolean | UserArgs
  parent?: boolean | CommentArgs
  replies?: boolean | FindManyCommentArgs
}

export type CommentGetPayload<
  S extends boolean | null | undefined | CommentArgs,
  U = keyof S
> = S extends true
  ? Comment
  : S extends undefined
  ? never
  : S extends CommentArgs | FindManyCommentArgs
  ? 'include' extends U
    ? Comment  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['include'][P]> :
      P extends 'author'
      ? UserGetPayload<S['include'][P]> :
      P extends 'parent'
      ? CommentGetPayload<S['include'][P]> | null :
      P extends 'replies'
      ? Array<CommentGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Comment ? Comment[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['select'][P]> :
      P extends 'author'
      ? UserGetPayload<S['select'][P]> :
      P extends 'parent'
      ? CommentGetPayload<S['select'][P]> | null :
      P extends 'replies'
      ? Array<CommentGetPayload<S['select'][P]>> : never
    }
  : Comment
: Comment


export interface CommentDelegate {
  /**
   * Find zero or one Comment.
   * @param {FindOneCommentArgs} args - Arguments to find a Comment
   * @example
   * // Get one Comment
   * const comment = await prisma.comment.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneCommentArgs>(
    args: Subset<T, FindOneCommentArgs>
  ): CheckSelect<T, Prisma__CommentClient<Comment | null>, Prisma__CommentClient<CommentGetPayload<T> | null>>
  /**
   * Find zero or more Comments.
   * @param {FindManyCommentArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Comments
   * const comments = await prisma.comment.findMany()
   * 
   * // Get first 10 Comments
   * const comments = await prisma.comment.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyCommentArgs>(
    args?: Subset<T, FindManyCommentArgs>
  ): CheckSelect<T, Promise<Array<Comment>>, Promise<Array<CommentGetPayload<T>>>>
  /**
   * Create a Comment.
   * @param {CommentCreateArgs} args - Arguments to create a Comment.
   * @example
   * // Create one Comment
   * const Comment = await prisma.comment.create({
   *   data: {
   *     // ... data to create a Comment
   *   }
   * })
   * 
  **/
  create<T extends CommentCreateArgs>(
    args: Subset<T, CommentCreateArgs>
  ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>
  /**
   * Delete a Comment.
   * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
   * @example
   * // Delete one Comment
   * const Comment = await prisma.comment.delete({
   *   where: {
   *     // ... filter to delete one Comment
   *   }
   * })
   * 
  **/
  delete<T extends CommentDeleteArgs>(
    args: Subset<T, CommentDeleteArgs>
  ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>
  /**
   * Update one Comment.
   * @param {CommentUpdateArgs} args - Arguments to update one Comment.
   * @example
   * // Update one Comment
   * const comment = await prisma.comment.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends CommentUpdateArgs>(
    args: Subset<T, CommentUpdateArgs>
  ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>
  /**
   * Delete zero or more Comments.
   * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
   * @example
   * // Delete a few Comments
   * const { count } = await prisma.comment.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends CommentDeleteManyArgs>(
    args: Subset<T, CommentDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Comments.
   * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Comments
   * const comment = await prisma.comment.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends CommentUpdateManyArgs>(
    args: Subset<T, CommentUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Comment.
   * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
   * @example
   * // Update or create a Comment
   * const comment = await prisma.comment.upsert({
   *   create: {
   *     // ... data to create a Comment
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Comment we want to update
   *   }
   * })
  **/
  upsert<T extends CommentUpsertArgs>(
    args: Subset<T, CommentUpsertArgs>
  ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyCommentArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateCommentArgs>(args: Subset<T, AggregateCommentArgs>): Promise<GetCommentAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for Comment.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__CommentClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>;

  author<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

  parent<T extends CommentArgs = {}>(args?: Subset<T, CommentArgs>): CheckSelect<T, Prisma__CommentClient<Comment | null>, Prisma__CommentClient<CommentGetPayload<T> | null>>;

  replies<T extends FindManyCommentArgs = {}>(args?: Subset<T, FindManyCommentArgs>): CheckSelect<T, Promise<Array<Comment>>, Promise<Array<CommentGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Comment findOne
 */
export type FindOneCommentArgs = {
  /**
   * Select specific fields to fetch from the Comment
  **/
  select?: CommentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CommentInclude | null
  /**
   * Filter, which Comment to fetch.
  **/
  where: CommentWhereUniqueInput
}


/**
 * Comment findMany
 */
export type FindManyCommentArgs = {
  /**
   * Select specific fields to fetch from the Comment
  **/
  select?: CommentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CommentInclude | null
  /**
   * Filter, which Comments to fetch.
  **/
  where?: CommentWhereInput
  /**
   * Determine the order of the Comments to fetch.
  **/
  orderBy?: CommentOrderByInput
  /**
   * Sets the position for listing Comments.
  **/
  cursor?: CommentWhereUniqueInput
  /**
   * The number of Comments to fetch. If negative number, it will take Comments before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Comments.
  **/
  skip?: number
}


/**
 * Comment create
 */
export type CommentCreateArgs = {
  /**
   * Select specific fields to fetch from the Comment
  **/
  select?: CommentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CommentInclude | null
  /**
   * The data needed to create a Comment.
  **/
  data: CommentCreateInput
}


/**
 * Comment update
 */
export type CommentUpdateArgs = {
  /**
   * Select specific fields to fetch from the Comment
  **/
  select?: CommentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CommentInclude | null
  /**
   * The data needed to update a Comment.
  **/
  data: CommentUpdateInput
  /**
   * Choose, which Comment to update.
  **/
  where: CommentWhereUniqueInput
}


/**
 * Comment updateMany
 */
export type CommentUpdateManyArgs = {
  data: CommentUpdateManyMutationInput
  where?: CommentWhereInput
}


/**
 * Comment upsert
 */
export type CommentUpsertArgs = {
  /**
   * Select specific fields to fetch from the Comment
  **/
  select?: CommentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CommentInclude | null
  /**
   * The filter to search for the Comment to update in case it exists.
  **/
  where: CommentWhereUniqueInput
  /**
   * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
  **/
  create: CommentCreateInput
  /**
   * In case the Comment was found with the provided `where` argument, update it with this data.
  **/
  update: CommentUpdateInput
}


/**
 * Comment delete
 */
export type CommentDeleteArgs = {
  /**
   * Select specific fields to fetch from the Comment
  **/
  select?: CommentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CommentInclude | null
  /**
   * Filter which Comment to delete.
  **/
  where: CommentWhereUniqueInput
}


/**
 * Comment deleteMany
 */
export type CommentDeleteManyArgs = {
  where?: CommentWhereInput
}


/**
 * Comment without action
 */
export type CommentArgs = {
  /**
   * Select specific fields to fetch from the Comment
  **/
  select?: CommentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CommentInclude | null
}



/**
 * Model Appointment
 */

export type Appointment = {
  id: string
  wid: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
  name: string
  description: string | null
  ownerId: string
}


export type AggregateAppointment = {
  count: number
}



export type AggregateAppointmentArgs = {
  where?: AppointmentWhereInput
  orderBy?: AppointmentOrderByInput
  cursor?: AppointmentWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetAppointmentAggregateType<T extends AggregateAppointmentArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type AppointmentSelect = {
  id?: boolean
  node?: boolean | NodeArgs
  wid?: boolean
  workspace?: boolean | WorkspaceArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  name?: boolean
  description?: boolean
  owner?: boolean | UserArgs
  ownerId?: boolean
}

export type AppointmentInclude = {
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  owner?: boolean | UserArgs
}

export type AppointmentGetPayload<
  S extends boolean | null | undefined | AppointmentArgs,
  U = keyof S
> = S extends true
  ? Appointment
  : S extends undefined
  ? never
  : S extends AppointmentArgs | FindManyAppointmentArgs
  ? 'include' extends U
    ? Appointment  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['include'][P]> :
      P extends 'owner'
      ? UserGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Appointment ? Appointment[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['select'][P]> :
      P extends 'owner'
      ? UserGetPayload<S['select'][P]> : never
    }
  : Appointment
: Appointment


export interface AppointmentDelegate {
  /**
   * Find zero or one Appointment.
   * @param {FindOneAppointmentArgs} args - Arguments to find a Appointment
   * @example
   * // Get one Appointment
   * const appointment = await prisma.appointment.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneAppointmentArgs>(
    args: Subset<T, FindOneAppointmentArgs>
  ): CheckSelect<T, Prisma__AppointmentClient<Appointment | null>, Prisma__AppointmentClient<AppointmentGetPayload<T> | null>>
  /**
   * Find zero or more Appointments.
   * @param {FindManyAppointmentArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Appointments
   * const appointments = await prisma.appointment.findMany()
   * 
   * // Get first 10 Appointments
   * const appointments = await prisma.appointment.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyAppointmentArgs>(
    args?: Subset<T, FindManyAppointmentArgs>
  ): CheckSelect<T, Promise<Array<Appointment>>, Promise<Array<AppointmentGetPayload<T>>>>
  /**
   * Create a Appointment.
   * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
   * @example
   * // Create one Appointment
   * const Appointment = await prisma.appointment.create({
   *   data: {
   *     // ... data to create a Appointment
   *   }
   * })
   * 
  **/
  create<T extends AppointmentCreateArgs>(
    args: Subset<T, AppointmentCreateArgs>
  ): CheckSelect<T, Prisma__AppointmentClient<Appointment>, Prisma__AppointmentClient<AppointmentGetPayload<T>>>
  /**
   * Delete a Appointment.
   * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
   * @example
   * // Delete one Appointment
   * const Appointment = await prisma.appointment.delete({
   *   where: {
   *     // ... filter to delete one Appointment
   *   }
   * })
   * 
  **/
  delete<T extends AppointmentDeleteArgs>(
    args: Subset<T, AppointmentDeleteArgs>
  ): CheckSelect<T, Prisma__AppointmentClient<Appointment>, Prisma__AppointmentClient<AppointmentGetPayload<T>>>
  /**
   * Update one Appointment.
   * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
   * @example
   * // Update one Appointment
   * const appointment = await prisma.appointment.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends AppointmentUpdateArgs>(
    args: Subset<T, AppointmentUpdateArgs>
  ): CheckSelect<T, Prisma__AppointmentClient<Appointment>, Prisma__AppointmentClient<AppointmentGetPayload<T>>>
  /**
   * Delete zero or more Appointments.
   * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
   * @example
   * // Delete a few Appointments
   * const { count } = await prisma.appointment.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends AppointmentDeleteManyArgs>(
    args: Subset<T, AppointmentDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Appointments.
   * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Appointments
   * const appointment = await prisma.appointment.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends AppointmentUpdateManyArgs>(
    args: Subset<T, AppointmentUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Appointment.
   * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
   * @example
   * // Update or create a Appointment
   * const appointment = await prisma.appointment.upsert({
   *   create: {
   *     // ... data to create a Appointment
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Appointment we want to update
   *   }
   * })
  **/
  upsert<T extends AppointmentUpsertArgs>(
    args: Subset<T, AppointmentUpsertArgs>
  ): CheckSelect<T, Prisma__AppointmentClient<Appointment>, Prisma__AppointmentClient<AppointmentGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyAppointmentArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateAppointmentArgs>(args: Subset<T, AggregateAppointmentArgs>): Promise<GetAppointmentAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for Appointment.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__AppointmentClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>;

  owner<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Appointment findOne
 */
export type FindOneAppointmentArgs = {
  /**
   * Select specific fields to fetch from the Appointment
  **/
  select?: AppointmentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AppointmentInclude | null
  /**
   * Filter, which Appointment to fetch.
  **/
  where: AppointmentWhereUniqueInput
}


/**
 * Appointment findMany
 */
export type FindManyAppointmentArgs = {
  /**
   * Select specific fields to fetch from the Appointment
  **/
  select?: AppointmentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AppointmentInclude | null
  /**
   * Filter, which Appointments to fetch.
  **/
  where?: AppointmentWhereInput
  /**
   * Determine the order of the Appointments to fetch.
  **/
  orderBy?: AppointmentOrderByInput
  /**
   * Sets the position for listing Appointments.
  **/
  cursor?: AppointmentWhereUniqueInput
  /**
   * The number of Appointments to fetch. If negative number, it will take Appointments before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Appointments.
  **/
  skip?: number
}


/**
 * Appointment create
 */
export type AppointmentCreateArgs = {
  /**
   * Select specific fields to fetch from the Appointment
  **/
  select?: AppointmentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AppointmentInclude | null
  /**
   * The data needed to create a Appointment.
  **/
  data: AppointmentCreateInput
}


/**
 * Appointment update
 */
export type AppointmentUpdateArgs = {
  /**
   * Select specific fields to fetch from the Appointment
  **/
  select?: AppointmentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AppointmentInclude | null
  /**
   * The data needed to update a Appointment.
  **/
  data: AppointmentUpdateInput
  /**
   * Choose, which Appointment to update.
  **/
  where: AppointmentWhereUniqueInput
}


/**
 * Appointment updateMany
 */
export type AppointmentUpdateManyArgs = {
  data: AppointmentUpdateManyMutationInput
  where?: AppointmentWhereInput
}


/**
 * Appointment upsert
 */
export type AppointmentUpsertArgs = {
  /**
   * Select specific fields to fetch from the Appointment
  **/
  select?: AppointmentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AppointmentInclude | null
  /**
   * The filter to search for the Appointment to update in case it exists.
  **/
  where: AppointmentWhereUniqueInput
  /**
   * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
  **/
  create: AppointmentCreateInput
  /**
   * In case the Appointment was found with the provided `where` argument, update it with this data.
  **/
  update: AppointmentUpdateInput
}


/**
 * Appointment delete
 */
export type AppointmentDeleteArgs = {
  /**
   * Select specific fields to fetch from the Appointment
  **/
  select?: AppointmentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AppointmentInclude | null
  /**
   * Filter which Appointment to delete.
  **/
  where: AppointmentWhereUniqueInput
}


/**
 * Appointment deleteMany
 */
export type AppointmentDeleteManyArgs = {
  where?: AppointmentWhereInput
}


/**
 * Appointment without action
 */
export type AppointmentArgs = {
  /**
   * Select specific fields to fetch from the Appointment
  **/
  select?: AppointmentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AppointmentInclude | null
}



/**
 * Model Event
 */

export type Event = {
  id: string
  wid: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
}


export type AggregateEvent = {
  count: number
}



export type AggregateEventArgs = {
  where?: EventWhereInput
  orderBy?: EventOrderByInput
  cursor?: EventWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetEventAggregateType<T extends AggregateEventArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type EventSelect = {
  id?: boolean
  wid?: boolean
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
}

export type EventInclude = {
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
}

export type EventGetPayload<
  S extends boolean | null | undefined | EventArgs,
  U = keyof S
> = S extends true
  ? Event
  : S extends undefined
  ? never
  : S extends EventArgs | FindManyEventArgs
  ? 'include' extends U
    ? Event  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Event ? Event[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['select'][P]> : never
    }
  : Event
: Event


export interface EventDelegate {
  /**
   * Find zero or one Event.
   * @param {FindOneEventArgs} args - Arguments to find a Event
   * @example
   * // Get one Event
   * const event = await prisma.event.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneEventArgs>(
    args: Subset<T, FindOneEventArgs>
  ): CheckSelect<T, Prisma__EventClient<Event | null>, Prisma__EventClient<EventGetPayload<T> | null>>
  /**
   * Find zero or more Events.
   * @param {FindManyEventArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Events
   * const events = await prisma.event.findMany()
   * 
   * // Get first 10 Events
   * const events = await prisma.event.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyEventArgs>(
    args?: Subset<T, FindManyEventArgs>
  ): CheckSelect<T, Promise<Array<Event>>, Promise<Array<EventGetPayload<T>>>>
  /**
   * Create a Event.
   * @param {EventCreateArgs} args - Arguments to create a Event.
   * @example
   * // Create one Event
   * const Event = await prisma.event.create({
   *   data: {
   *     // ... data to create a Event
   *   }
   * })
   * 
  **/
  create<T extends EventCreateArgs>(
    args: Subset<T, EventCreateArgs>
  ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>
  /**
   * Delete a Event.
   * @param {EventDeleteArgs} args - Arguments to delete one Event.
   * @example
   * // Delete one Event
   * const Event = await prisma.event.delete({
   *   where: {
   *     // ... filter to delete one Event
   *   }
   * })
   * 
  **/
  delete<T extends EventDeleteArgs>(
    args: Subset<T, EventDeleteArgs>
  ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>
  /**
   * Update one Event.
   * @param {EventUpdateArgs} args - Arguments to update one Event.
   * @example
   * // Update one Event
   * const event = await prisma.event.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends EventUpdateArgs>(
    args: Subset<T, EventUpdateArgs>
  ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>
  /**
   * Delete zero or more Events.
   * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
   * @example
   * // Delete a few Events
   * const { count } = await prisma.event.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends EventDeleteManyArgs>(
    args: Subset<T, EventDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Events.
   * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Events
   * const event = await prisma.event.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends EventUpdateManyArgs>(
    args: Subset<T, EventUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Event.
   * @param {EventUpsertArgs} args - Arguments to update or create a Event.
   * @example
   * // Update or create a Event
   * const event = await prisma.event.upsert({
   *   create: {
   *     // ... data to create a Event
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Event we want to update
   *   }
   * })
  **/
  upsert<T extends EventUpsertArgs>(
    args: Subset<T, EventUpsertArgs>
  ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyEventArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateEventArgs>(args: Subset<T, AggregateEventArgs>): Promise<GetEventAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for Event.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__EventClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Event findOne
 */
export type FindOneEventArgs = {
  /**
   * Select specific fields to fetch from the Event
  **/
  select?: EventSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventInclude | null
  /**
   * Filter, which Event to fetch.
  **/
  where: EventWhereUniqueInput
}


/**
 * Event findMany
 */
export type FindManyEventArgs = {
  /**
   * Select specific fields to fetch from the Event
  **/
  select?: EventSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventInclude | null
  /**
   * Filter, which Events to fetch.
  **/
  where?: EventWhereInput
  /**
   * Determine the order of the Events to fetch.
  **/
  orderBy?: EventOrderByInput
  /**
   * Sets the position for listing Events.
  **/
  cursor?: EventWhereUniqueInput
  /**
   * The number of Events to fetch. If negative number, it will take Events before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Events.
  **/
  skip?: number
}


/**
 * Event create
 */
export type EventCreateArgs = {
  /**
   * Select specific fields to fetch from the Event
  **/
  select?: EventSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventInclude | null
  /**
   * The data needed to create a Event.
  **/
  data: EventCreateInput
}


/**
 * Event update
 */
export type EventUpdateArgs = {
  /**
   * Select specific fields to fetch from the Event
  **/
  select?: EventSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventInclude | null
  /**
   * The data needed to update a Event.
  **/
  data: EventUpdateInput
  /**
   * Choose, which Event to update.
  **/
  where: EventWhereUniqueInput
}


/**
 * Event updateMany
 */
export type EventUpdateManyArgs = {
  data: EventUpdateManyMutationInput
  where?: EventWhereInput
}


/**
 * Event upsert
 */
export type EventUpsertArgs = {
  /**
   * Select specific fields to fetch from the Event
  **/
  select?: EventSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventInclude | null
  /**
   * The filter to search for the Event to update in case it exists.
  **/
  where: EventWhereUniqueInput
  /**
   * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
  **/
  create: EventCreateInput
  /**
   * In case the Event was found with the provided `where` argument, update it with this data.
  **/
  update: EventUpdateInput
}


/**
 * Event delete
 */
export type EventDeleteArgs = {
  /**
   * Select specific fields to fetch from the Event
  **/
  select?: EventSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventInclude | null
  /**
   * Filter which Event to delete.
  **/
  where: EventWhereUniqueInput
}


/**
 * Event deleteMany
 */
export type EventDeleteManyArgs = {
  where?: EventWhereInput
}


/**
 * Event without action
 */
export type EventArgs = {
  /**
   * Select specific fields to fetch from the Event
  **/
  select?: EventSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventInclude | null
}



/**
 * Model Notification
 */

export type Notification = {
  id: string
  wid: string
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
}


export type AggregateNotification = {
  count: number
}



export type AggregateNotificationArgs = {
  where?: NotificationWhereInput
  orderBy?: NotificationOrderByInput
  cursor?: NotificationWhereUniqueInput
  take?: number
  skip?: number
  count?: true
}

export type GetNotificationAggregateType<T extends AggregateNotificationArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type NotificationSelect = {
  id?: boolean
  node?: boolean | NodeArgs
  wid?: boolean
  workspace?: boolean | WorkspaceArgs
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
}

export type NotificationInclude = {
  node?: boolean | NodeArgs
  workspace?: boolean | WorkspaceArgs
}

export type NotificationGetPayload<
  S extends boolean | null | undefined | NotificationArgs,
  U = keyof S
> = S extends true
  ? Notification
  : S extends undefined
  ? never
  : S extends NotificationArgs | FindManyNotificationArgs
  ? 'include' extends U
    ? Notification  & {
      [P in TrueKeys<S['include']>]:
      P extends 'node'
      ? NodeGetPayload<S['include'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Notification ? Notification[P]
: 
      P extends 'node'
      ? NodeGetPayload<S['select'][P]> :
      P extends 'workspace'
      ? WorkspaceGetPayload<S['select'][P]> : never
    }
  : Notification
: Notification


export interface NotificationDelegate {
  /**
   * Find zero or one Notification.
   * @param {FindOneNotificationArgs} args - Arguments to find a Notification
   * @example
   * // Get one Notification
   * const notification = await prisma.notification.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneNotificationArgs>(
    args: Subset<T, FindOneNotificationArgs>
  ): CheckSelect<T, Prisma__NotificationClient<Notification | null>, Prisma__NotificationClient<NotificationGetPayload<T> | null>>
  /**
   * Find zero or more Notifications.
   * @param {FindManyNotificationArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Notifications
   * const notifications = await prisma.notification.findMany()
   * 
   * // Get first 10 Notifications
   * const notifications = await prisma.notification.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyNotificationArgs>(
    args?: Subset<T, FindManyNotificationArgs>
  ): CheckSelect<T, Promise<Array<Notification>>, Promise<Array<NotificationGetPayload<T>>>>
  /**
   * Create a Notification.
   * @param {NotificationCreateArgs} args - Arguments to create a Notification.
   * @example
   * // Create one Notification
   * const Notification = await prisma.notification.create({
   *   data: {
   *     // ... data to create a Notification
   *   }
   * })
   * 
  **/
  create<T extends NotificationCreateArgs>(
    args: Subset<T, NotificationCreateArgs>
  ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>
  /**
   * Delete a Notification.
   * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
   * @example
   * // Delete one Notification
   * const Notification = await prisma.notification.delete({
   *   where: {
   *     // ... filter to delete one Notification
   *   }
   * })
   * 
  **/
  delete<T extends NotificationDeleteArgs>(
    args: Subset<T, NotificationDeleteArgs>
  ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>
  /**
   * Update one Notification.
   * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
   * @example
   * // Update one Notification
   * const notification = await prisma.notification.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends NotificationUpdateArgs>(
    args: Subset<T, NotificationUpdateArgs>
  ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>
  /**
   * Delete zero or more Notifications.
   * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
   * @example
   * // Delete a few Notifications
   * const { count } = await prisma.notification.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends NotificationDeleteManyArgs>(
    args: Subset<T, NotificationDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Notifications.
   * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Notifications
   * const notification = await prisma.notification.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends NotificationUpdateManyArgs>(
    args: Subset<T, NotificationUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Notification.
   * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
   * @example
   * // Update or create a Notification
   * const notification = await prisma.notification.upsert({
   *   create: {
   *     // ... data to create a Notification
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Notification we want to update
   *   }
   * })
  **/
  upsert<T extends NotificationUpsertArgs>(
    args: Subset<T, NotificationUpsertArgs>
  ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyNotificationArgs, 'select' | 'include'>): Promise<number>


  /**
   * Aggregate
   */
  aggregate<T extends AggregateNotificationArgs>(args: Subset<T, AggregateNotificationArgs>): Promise<GetNotificationAggregateType<T>>
    
}

/**
 * The delegate class that acts as a "Promise-like" for Notification.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__NotificationClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  node<T extends NodeArgs = {}>(args?: Subset<T, NodeArgs>): CheckSelect<T, Prisma__NodeClient<Node | null>, Prisma__NodeClient<NodeGetPayload<T> | null>>;

  workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null>, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Notification findOne
 */
export type FindOneNotificationArgs = {
  /**
   * Select specific fields to fetch from the Notification
  **/
  select?: NotificationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NotificationInclude | null
  /**
   * Filter, which Notification to fetch.
  **/
  where: NotificationWhereUniqueInput
}


/**
 * Notification findMany
 */
export type FindManyNotificationArgs = {
  /**
   * Select specific fields to fetch from the Notification
  **/
  select?: NotificationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NotificationInclude | null
  /**
   * Filter, which Notifications to fetch.
  **/
  where?: NotificationWhereInput
  /**
   * Determine the order of the Notifications to fetch.
  **/
  orderBy?: NotificationOrderByInput
  /**
   * Sets the position for listing Notifications.
  **/
  cursor?: NotificationWhereUniqueInput
  /**
   * The number of Notifications to fetch. If negative number, it will take Notifications before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Notifications.
  **/
  skip?: number
}


/**
 * Notification create
 */
export type NotificationCreateArgs = {
  /**
   * Select specific fields to fetch from the Notification
  **/
  select?: NotificationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NotificationInclude | null
  /**
   * The data needed to create a Notification.
  **/
  data: NotificationCreateInput
}


/**
 * Notification update
 */
export type NotificationUpdateArgs = {
  /**
   * Select specific fields to fetch from the Notification
  **/
  select?: NotificationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NotificationInclude | null
  /**
   * The data needed to update a Notification.
  **/
  data: NotificationUpdateInput
  /**
   * Choose, which Notification to update.
  **/
  where: NotificationWhereUniqueInput
}


/**
 * Notification updateMany
 */
export type NotificationUpdateManyArgs = {
  data: NotificationUpdateManyMutationInput
  where?: NotificationWhereInput
}


/**
 * Notification upsert
 */
export type NotificationUpsertArgs = {
  /**
   * Select specific fields to fetch from the Notification
  **/
  select?: NotificationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NotificationInclude | null
  /**
   * The filter to search for the Notification to update in case it exists.
  **/
  where: NotificationWhereUniqueInput
  /**
   * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
  **/
  create: NotificationCreateInput
  /**
   * In case the Notification was found with the provided `where` argument, update it with this data.
  **/
  update: NotificationUpdateInput
}


/**
 * Notification delete
 */
export type NotificationDeleteArgs = {
  /**
   * Select specific fields to fetch from the Notification
  **/
  select?: NotificationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NotificationInclude | null
  /**
   * Filter which Notification to delete.
  **/
  where: NotificationWhereUniqueInput
}


/**
 * Notification deleteMany
 */
export type NotificationDeleteManyArgs = {
  where?: NotificationWhereInput
}


/**
 * Notification without action
 */
export type NotificationArgs = {
  /**
   * Select specific fields to fetch from the Notification
  **/
  select?: NotificationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NotificationInclude | null
}



/**
 * Deep Input Types
 */


export type TagWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  name?: string | StringFilter
  description?: string | NullableStringFilter | null
  candidates?: CandidateFilter | null
  AND?: Enumerable<TagWhereInput>
  OR?: Array<TagWhereInput>
  NOT?: Enumerable<TagWhereInput>
  node?: NodeWhereInput | null
  workspace?: WorkspaceWhereInput | null
}

export type FieldDefinitionWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  name?: string | StringFilter
  type?: FieldType | FieldTypeFilter
  values?: FieldValueFilter | null
  AND?: Enumerable<FieldDefinitionWhereInput>
  OR?: Array<FieldDefinitionWhereInput>
  NOT?: Enumerable<FieldDefinitionWhereInput>
  node?: NodeWhereInput | null
  workspace?: WorkspaceWhereInput | null
}

export type FieldValueWhereInput = {
  value?: InputJsonValue | JsonFilter
  definitionId?: string | StringFilter
  candidateId?: string | StringFilter
  AND?: Enumerable<FieldValueWhereInput>
  OR?: Array<FieldValueWhereInput>
  NOT?: Enumerable<FieldValueWhereInput>
  definition?: FieldDefinitionWhereInput | null
  candidate?: CandidateWhereInput | null
}

export type CandidateWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  firstName?: string | NullableStringFilter | null
  lastName?: string | NullableStringFilter | null
  headline?: string | NullableStringFilter | null
  tags?: TagFilter | null
  applications?: ApplicationFilter | null
  fields?: FieldValueFilter | null
  AND?: Enumerable<CandidateWhereInput>
  OR?: Array<CandidateWhereInput>
  NOT?: Enumerable<CandidateWhereInput>
  node?: NodeWhereInput | null
  workspace?: WorkspaceWhereInput | null
}

export type SourceWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  name?: string | StringFilter
  description?: string | NullableStringFilter | null
  applications?: ApplicationFilter | null
  AND?: Enumerable<SourceWhereInput>
  OR?: Array<SourceWhereInput>
  NOT?: Enumerable<SourceWhereInput>
  node?: NodeWhereInput | null
  workspace?: WorkspaceWhereInput | null
}

export type PipelineWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  stages?: StageFilter | null
  AND?: Enumerable<PipelineWhereInput>
  OR?: Array<PipelineWhereInput>
  NOT?: Enumerable<PipelineWhereInput>
  node?: NodeWhereInput | null
  workspace?: WorkspaceWhereInput | null
}

export type ReviewWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  message?: string | NullableStringFilter | null
  score?: number | NullableIntFilter | null
  authorId?: string | StringFilter
  applicationId?: string | StringFilter
  stageId?: string | NullableStringFilter | null
  AND?: Enumerable<ReviewWhereInput>
  OR?: Array<ReviewWhereInput>
  NOT?: Enumerable<ReviewWhereInput>
  node?: NodeWhereInput | null
  workspace?: WorkspaceWhereInput | null
  author?: UserWhereInput | null
  application?: ApplicationWhereInput | null
  stage?: StageWhereInput | null
}

export type StageWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  pipelineId?: string | StringFilter
  applications?: ApplicationFilter | null
  reviews?: ReviewFilter | null
  AND?: Enumerable<StageWhereInput>
  OR?: Array<StageWhereInput>
  NOT?: Enumerable<StageWhereInput>
  node?: NodeWhereInput | null
  workspace?: WorkspaceWhereInput | null
  pipeline?: PipelineWhereInput | null
}

export type ApplicationWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  jobId?: string | StringFilter
  candidateId?: string | StringFilter
  sourceId?: string | StringFilter
  stageId?: string | StringFilter
  reviews?: ReviewFilter | null
  AND?: Enumerable<ApplicationWhereInput>
  OR?: Array<ApplicationWhereInput>
  NOT?: Enumerable<ApplicationWhereInput>
  node?: NodeWhereInput | null
  workspace?: WorkspaceWhereInput | null
  job?: JobWhereInput | null
  candidate?: CandidateWhereInput | null
  source?: SourceWhereInput | null
  stage?: StageWhereInput | null
}

export type LocationWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  name?: string | NullableStringFilter | null
  description?: string | NullableStringFilter | null
  country?: string | StringFilter
  city?: string | NullableStringFilter | null
  jobs?: JobFilter | null
  AND?: Enumerable<LocationWhereInput>
  OR?: Array<LocationWhereInput>
  NOT?: Enumerable<LocationWhereInput>
  node?: NodeWhereInput | null
  workspace?: WorkspaceWhereInput | null
}

export type JobWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  name?: string | StringFilter
  description?: string | NullableStringFilter | null
  status?: JobStatus | JobStatusFilter
  clientId?: string | StringFilter
  applications?: ApplicationFilter | null
  locations?: LocationFilter | null
  AND?: Enumerable<JobWhereInput>
  OR?: Array<JobWhereInput>
  NOT?: Enumerable<JobWhereInput>
  node?: NodeWhereInput | null
  workspace?: WorkspaceWhereInput | null
  client?: ClientWhereInput | null
}

export type ClientWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  name?: string | StringFilter
  description?: string | NullableStringFilter | null
  jobs?: JobFilter | null
  AND?: Enumerable<ClientWhereInput>
  OR?: Array<ClientWhereInput>
  NOT?: Enumerable<ClientWhereInput>
  node?: NodeWhereInput | null
  workspace?: WorkspaceWhereInput | null
}

export type CommentWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  message?: string | StringFilter
  authorId?: string | StringFilter
  parentId?: string | NullableStringFilter | null
  replies?: CommentFilter | null
  AND?: Enumerable<CommentWhereInput>
  OR?: Array<CommentWhereInput>
  NOT?: Enumerable<CommentWhereInput>
  node?: NodeWhereInput | null
  workspace?: WorkspaceWhereInput | null
  author?: UserWhereInput | null
  parent?: CommentWhereInput | null
}

export type EventWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  AND?: Enumerable<EventWhereInput>
  OR?: Array<EventWhereInput>
  NOT?: Enumerable<EventWhereInput>
  node?: NodeWhereInput | null
  workspace?: WorkspaceWhereInput | null
}

export type AppointmentWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  name?: string | StringFilter
  description?: string | NullableStringFilter | null
  ownerId?: string | StringFilter
  AND?: Enumerable<AppointmentWhereInput>
  OR?: Array<AppointmentWhereInput>
  NOT?: Enumerable<AppointmentWhereInput>
  node?: NodeWhereInput | null
  workspace?: WorkspaceWhereInput | null
  owner?: UserWhereInput | null
}

export type NotificationWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  AND?: Enumerable<NotificationWhereInput>
  OR?: Array<NotificationWhereInput>
  NOT?: Enumerable<NotificationWhereInput>
  node?: NodeWhereInput | null
  workspace?: WorkspaceWhereInput | null
}

export type WorkspaceWhereInput = {
  id?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  name?: string | StringFilter
  description?: string | NullableStringFilter | null
  website?: string | NullableStringFilter | null
  type?: WorkspaceType | WorkspaceTypeFilter
  users?: UserFilter | null
  clients?: ClientFilter | null
  candidates?: CandidateFilter | null
  applications?: ApplicationFilter | null
  job?: JobFilter | null
  tags?: TagFilter | null
  sources?: SourceFilter | null
  comments?: CommentFilter | null
  pipelines?: PipelineFilter | null
  stages?: StageFilter | null
  locations?: LocationFilter | null
  reviews?: ReviewFilter | null
  event?: EventFilter | null
  appointment?: AppointmentFilter | null
  notification?: NotificationFilter | null
  fields?: FieldDefinitionFilter | null
  AND?: Enumerable<WorkspaceWhereInput>
  OR?: Array<WorkspaceWhereInput>
  NOT?: Enumerable<WorkspaceWhereInput>
  node?: NodeWhereInput | null
}

export type UserWhereInput = {
  id?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  email?: string | StringFilter
  avatarUrl?: string | NullableStringFilter | null
  workspaces?: WorkspaceFilter | null
  comments?: CommentFilter | null
  reviews?: ReviewFilter | null
  appointments?: AppointmentFilter | null
  AND?: Enumerable<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: Enumerable<UserWhereInput>
  node?: NodeWhereInput | null
}

export type NodeWhereInput = {
  id?: string | UUIDFilter
  AND?: Enumerable<NodeWhereInput>
  OR?: Array<NodeWhereInput>
  NOT?: Enumerable<NodeWhereInput>
  user?: UserWhereInput | null
  client?: ClientWhereInput | null
  candidate?: CandidateWhereInput | null
  application?: ApplicationWhereInput | null
  job?: JobWhereInput | null
  tag?: TagWhereInput | null
  comment?: CommentWhereInput | null
  source?: SourceWhereInput | null
  pipeline?: PipelineWhereInput | null
  stage?: StageWhereInput | null
  location?: LocationWhereInput | null
  review?: ReviewWhereInput | null
  event?: EventWhereInput | null
  appointment?: AppointmentWhereInput | null
  notification?: NotificationWhereInput | null
  field?: FieldDefinitionWhereInput | null
  workspace?: WorkspaceWhereInput | null
}

export type NodeWhereUniqueInput = {
  id?: string
}

export type WorkspaceWhereUniqueInput = {
  id?: string
}

export type UserWhereUniqueInput = {
  id?: string
  email?: string
}

export type ClientWhereUniqueInput = {
  id?: string
}

export type JobWhereUniqueInput = {
  id?: string
}

export type ApplicationWhereUniqueInput = {
  id?: string
}

export type TagWhereUniqueInput = {
  id?: string
  wid?: string
}

export type CandidateWhereUniqueInput = {
  id?: string
}

export type DefinitionIdCandidateIdCompoundUniqueInput = {
  definitionId: string
  candidateId: string
}

export type FieldValueWhereUniqueInput = {
  definitionId_candidateId?: DefinitionIdCandidateIdCompoundUniqueInput
}

export type StageWhereUniqueInput = {
  id?: string
}

export type ReviewWhereUniqueInput = {
  id?: string
}

export type LocationWhereUniqueInput = {
  id?: string
}

export type SourceWhereUniqueInput = {
  id?: string
}

export type CommentWhereUniqueInput = {
  id?: string
}

export type PipelineWhereUniqueInput = {
  id?: string
}

export type IdWidCompoundUniqueInput = {
  id: string
  wid: string
}

export type EventWhereUniqueInput = {
  id_wid?: IdWidCompoundUniqueInput
}

export type AppointmentWhereUniqueInput = {
  id?: string
}

export type NotificationWhereUniqueInput = {
  id?: string
}

export type FieldDefinitionWhereUniqueInput = {
  id?: string
}

export type CandidateCreateemailsInput = {
  set?: Enumerable<string> | null
}

export type CandidateCreatelinksInput = {
  set?: Enumerable<string> | null
}

export type CandidateCreatephonesInput = {
  set?: Enumerable<string> | null
}

export type TagCreatetypesInput = {
  set?: Enumerable<TagType> | null
}

export type NodeCreateWithoutFieldInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  client?: ClientCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutFieldDefinitionInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutFieldInput
}

export type NodeCreateOneWithoutFieldInput = {
  create?: NodeCreateWithoutFieldInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutFieldDefinitionInput
}

export type TagCreateWithoutCandidatesInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  types?: TagCreatetypesInput
  node: NodeCreateOneWithoutTagInput
  workspace: WorkspaceCreateOneWithoutTagsInput
}

export type TagCreateOrConnectWithoutCandidateInput = {
  where: TagWhereUniqueInput
  create: TagCreateWithoutCandidatesInput
}

export type TagCreateManyWithoutCandidatesInput = {
  create?: Enumerable<TagCreateWithoutCandidatesInput>
  connect?: Enumerable<TagWhereUniqueInput>
  connectOrCreate?: Enumerable<TagCreateOrConnectWithoutCandidateInput>
}

export type ClientCreateWithoutJobsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  node: NodeCreateOneWithoutClientInput
  workspace: WorkspaceCreateOneWithoutClientsInput
}

export type ClientCreateOrConnectWithoutJobInput = {
  where: ClientWhereUniqueInput
  create: ClientCreateWithoutJobsInput
}

export type ClientCreateOneWithoutJobsInput = {
  create?: ClientCreateWithoutJobsInput
  connect?: ClientWhereUniqueInput
  connectOrCreate?: ClientCreateOrConnectWithoutJobInput
}

export type LocationCreateWithoutJobsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string | null
  description?: string | null
  country: string
  city?: string | null
  node: NodeCreateOneWithoutLocationInput
  workspace: WorkspaceCreateOneWithoutLocationsInput
}

export type LocationCreateOrConnectWithoutJobInput = {
  where: LocationWhereUniqueInput
  create: LocationCreateWithoutJobsInput
}

export type LocationCreateManyWithoutJobsInput = {
  create?: Enumerable<LocationCreateWithoutJobsInput>
  connect?: Enumerable<LocationWhereUniqueInput>
  connectOrCreate?: Enumerable<LocationCreateOrConnectWithoutJobInput>
}

export type JobCreateWithoutApplicationsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  status: JobStatus
  node: NodeCreateOneWithoutJobInput
  workspace: WorkspaceCreateOneWithoutJobInput
  client: ClientCreateOneWithoutJobsInput
  locations?: LocationCreateManyWithoutJobsInput | null
}

export type JobCreateOrConnectWithoutApplicationInput = {
  where: JobWhereUniqueInput
  create: JobCreateWithoutApplicationsInput
}

export type JobCreateOneWithoutApplicationsInput = {
  create?: JobCreateWithoutApplicationsInput
  connect?: JobWhereUniqueInput
  connectOrCreate?: JobCreateOrConnectWithoutApplicationInput
}

export type SourceCreateWithoutApplicationsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  node: NodeCreateOneWithoutSourceInput
  workspace: WorkspaceCreateOneWithoutSourcesInput
}

export type SourceCreateOrConnectWithoutApplicationInput = {
  where: SourceWhereUniqueInput
  create: SourceCreateWithoutApplicationsInput
}

export type SourceCreateOneWithoutApplicationsInput = {
  create?: SourceCreateWithoutApplicationsInput
  connect?: SourceWhereUniqueInput
  connectOrCreate?: SourceCreateOrConnectWithoutApplicationInput
}

export type PipelineCreateWithoutStagesInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutPipelineInput
  workspace: WorkspaceCreateOneWithoutPipelinesInput
}

export type PipelineCreateOrConnectWithoutStageInput = {
  where: PipelineWhereUniqueInput
  create: PipelineCreateWithoutStagesInput
}

export type PipelineCreateOneWithoutStagesInput = {
  create?: PipelineCreateWithoutStagesInput
  connect?: PipelineWhereUniqueInput
  connectOrCreate?: PipelineCreateOrConnectWithoutStageInput
}

export type FieldDefinitionCreateWithoutValuesInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  type: FieldType
  node: NodeCreateOneWithoutFieldInput
  workspace: WorkspaceCreateOneWithoutFieldsInput
}

export type FieldDefinitionCreateOrConnectWithoutFieldValueInput = {
  where: FieldDefinitionWhereUniqueInput
  create: FieldDefinitionCreateWithoutValuesInput
}

export type FieldDefinitionCreateOneWithoutValuesInput = {
  create?: FieldDefinitionCreateWithoutValuesInput
  connect?: FieldDefinitionWhereUniqueInput
  connectOrCreate?: FieldDefinitionCreateOrConnectWithoutFieldValueInput
}

export type FieldValueCreateWithoutCandidateInput = {
  value: InputJsonValue
  definition: FieldDefinitionCreateOneWithoutValuesInput
}

export type FieldValueCreateOrConnectWithoutCandidateInput = {
  where: FieldValueWhereUniqueInput
  create: FieldValueCreateWithoutCandidateInput
}

export type FieldValueCreateManyWithoutCandidateInput = {
  create?: Enumerable<FieldValueCreateWithoutCandidateInput>
  connect?: Enumerable<FieldValueWhereUniqueInput>
  connectOrCreate?: Enumerable<FieldValueCreateOrConnectWithoutCandidateInput>
}

export type CandidateCreateWithoutApplicationsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  firstName?: string | null
  lastName?: string | null
  headline?: string | null
  emails?: CandidateCreateemailsInput
  links?: CandidateCreatelinksInput
  phones?: CandidateCreatephonesInput
  node: NodeCreateOneWithoutCandidateInput
  workspace: WorkspaceCreateOneWithoutCandidatesInput
  tags?: TagCreateManyWithoutCandidatesInput | null
  fields?: FieldValueCreateManyWithoutCandidateInput | null
}

export type CandidateCreateOrConnectWithoutApplicationInput = {
  where: CandidateWhereUniqueInput
  create: CandidateCreateWithoutApplicationsInput
}

export type CandidateCreateOneWithoutApplicationsInput = {
  create?: CandidateCreateWithoutApplicationsInput
  connect?: CandidateWhereUniqueInput
  connectOrCreate?: CandidateCreateOrConnectWithoutApplicationInput
}

export type ApplicationCreateWithoutReviewsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutApplicationInput
  workspace: WorkspaceCreateOneWithoutApplicationsInput
  job: JobCreateOneWithoutApplicationsInput
  candidate: CandidateCreateOneWithoutApplicationsInput
  source: SourceCreateOneWithoutApplicationsInput
  stage: StageCreateOneWithoutApplicationsInput
}

export type ApplicationCreateOrConnectWithoutReviewInput = {
  where: ApplicationWhereUniqueInput
  create: ApplicationCreateWithoutReviewsInput
}

export type ApplicationCreateOneWithoutReviewsInput = {
  create?: ApplicationCreateWithoutReviewsInput
  connect?: ApplicationWhereUniqueInput
  connectOrCreate?: ApplicationCreateOrConnectWithoutReviewInput
}

export type ReviewCreateWithoutApplicationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string | null
  score?: number | null
  node: NodeCreateOneWithoutReviewInput
  workspace: WorkspaceCreateOneWithoutReviewsInput
  author: UserCreateOneWithoutReviewsInput
  stage?: StageCreateOneWithoutReviewsInput | null
}

export type ReviewCreateOrConnectWithoutApplicationInput = {
  where: ReviewWhereUniqueInput
  create: ReviewCreateWithoutApplicationInput
}

export type ReviewCreateManyWithoutApplicationInput = {
  create?: Enumerable<ReviewCreateWithoutApplicationInput>
  connect?: Enumerable<ReviewWhereUniqueInput>
  connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutApplicationInput>
}

export type ApplicationCreateWithoutStageInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutApplicationInput
  workspace: WorkspaceCreateOneWithoutApplicationsInput
  job: JobCreateOneWithoutApplicationsInput
  candidate: CandidateCreateOneWithoutApplicationsInput
  source: SourceCreateOneWithoutApplicationsInput
  reviews?: ReviewCreateManyWithoutApplicationInput | null
}

export type ApplicationCreateOrConnectWithoutStageInput = {
  where: ApplicationWhereUniqueInput
  create: ApplicationCreateWithoutStageInput
}

export type ApplicationCreateManyWithoutStageInput = {
  create?: Enumerable<ApplicationCreateWithoutStageInput>
  connect?: Enumerable<ApplicationWhereUniqueInput>
  connectOrCreate?: Enumerable<ApplicationCreateOrConnectWithoutStageInput>
}

export type StageCreateWithoutReviewsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutStageInput
  workspace: WorkspaceCreateOneWithoutStagesInput
  pipeline: PipelineCreateOneWithoutStagesInput
  applications?: ApplicationCreateManyWithoutStageInput | null
}

export type StageCreateOrConnectWithoutReviewInput = {
  where: StageWhereUniqueInput
  create: StageCreateWithoutReviewsInput
}

export type StageCreateOneWithoutReviewsInput = {
  create?: StageCreateWithoutReviewsInput
  connect?: StageWhereUniqueInput
  connectOrCreate?: StageCreateOrConnectWithoutReviewInput
}

export type ReviewCreateWithoutAuthorInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string | null
  score?: number | null
  node: NodeCreateOneWithoutReviewInput
  workspace: WorkspaceCreateOneWithoutReviewsInput
  application: ApplicationCreateOneWithoutReviewsInput
  stage?: StageCreateOneWithoutReviewsInput | null
}

export type ReviewCreateOrConnectWithoutUserInput = {
  where: ReviewWhereUniqueInput
  create: ReviewCreateWithoutAuthorInput
}

export type ReviewCreateManyWithoutAuthorInput = {
  create?: Enumerable<ReviewCreateWithoutAuthorInput>
  connect?: Enumerable<ReviewWhereUniqueInput>
  connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutUserInput>
}

export type AppointmentCreateWithoutOwnerInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  node: NodeCreateOneWithoutAppointmentInput
  workspace: WorkspaceCreateOneWithoutAppointmentInput
}

export type AppointmentCreateOrConnectWithoutUserInput = {
  where: AppointmentWhereUniqueInput
  create: AppointmentCreateWithoutOwnerInput
}

export type AppointmentCreateManyWithoutOwnerInput = {
  create?: Enumerable<AppointmentCreateWithoutOwnerInput>
  connect?: Enumerable<AppointmentWhereUniqueInput>
  connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutUserInput>
}

export type UserCreateWithoutCommentsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  email: string
  avatarUrl?: string | null
  node: NodeCreateOneWithoutUserInput
  workspaces?: WorkspaceCreateManyWithoutUsersInput | null
  reviews?: ReviewCreateManyWithoutAuthorInput | null
  appointments?: AppointmentCreateManyWithoutOwnerInput | null
}

export type UserCreateOrConnectWithoutCommentInput = {
  where: UserWhereUniqueInput
  create: UserCreateWithoutCommentsInput
}

export type UserCreateOneWithoutCommentsInput = {
  create?: UserCreateWithoutCommentsInput
  connect?: UserWhereUniqueInput
  connectOrCreate?: UserCreateOrConnectWithoutCommentInput
}

export type CommentCreateWithoutRepliesInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message: string
  node: NodeCreateOneWithoutCommentInput
  workspace: WorkspaceCreateOneWithoutCommentsInput
  author: UserCreateOneWithoutCommentsInput
  parent?: CommentCreateOneWithoutRepliesInput | null
}

export type CommentCreateOrConnectWithoutCommentInput = {
  where: CommentWhereUniqueInput
  create: CommentCreateWithoutRepliesInput
}

export type CommentCreateOneWithoutRepliesInput = {
  create?: CommentCreateWithoutRepliesInput
  connect?: CommentWhereUniqueInput
  connectOrCreate?: CommentCreateOrConnectWithoutCommentInput
}

export type CommentCreateWithoutParentInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message: string
  node: NodeCreateOneWithoutCommentInput
  workspace: WorkspaceCreateOneWithoutCommentsInput
  author: UserCreateOneWithoutCommentsInput
  replies?: CommentCreateManyWithoutParentInput | null
}

export type CommentCreateManyWithoutParentInput = {
  create?: Enumerable<CommentCreateWithoutParentInput>
  connect?: Enumerable<CommentWhereUniqueInput>
  connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCommentInput>
}

export type CommentCreateWithoutAuthorInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message: string
  node: NodeCreateOneWithoutCommentInput
  workspace: WorkspaceCreateOneWithoutCommentsInput
  parent?: CommentCreateOneWithoutRepliesInput | null
  replies?: CommentCreateManyWithoutParentInput | null
}

export type CommentCreateOrConnectWithoutUserInput = {
  where: CommentWhereUniqueInput
  create: CommentCreateWithoutAuthorInput
}

export type CommentCreateManyWithoutAuthorInput = {
  create?: Enumerable<CommentCreateWithoutAuthorInput>
  connect?: Enumerable<CommentWhereUniqueInput>
  connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutUserInput>
}

export type UserCreateWithoutReviewsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  email: string
  avatarUrl?: string | null
  node: NodeCreateOneWithoutUserInput
  workspaces?: WorkspaceCreateManyWithoutUsersInput | null
  comments?: CommentCreateManyWithoutAuthorInput | null
  appointments?: AppointmentCreateManyWithoutOwnerInput | null
}

export type UserCreateOrConnectWithoutReviewInput = {
  where: UserWhereUniqueInput
  create: UserCreateWithoutReviewsInput
}

export type UserCreateOneWithoutReviewsInput = {
  create?: UserCreateWithoutReviewsInput
  connect?: UserWhereUniqueInput
  connectOrCreate?: UserCreateOrConnectWithoutReviewInput
}

export type ReviewCreateWithoutStageInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string | null
  score?: number | null
  node: NodeCreateOneWithoutReviewInput
  workspace: WorkspaceCreateOneWithoutReviewsInput
  author: UserCreateOneWithoutReviewsInput
  application: ApplicationCreateOneWithoutReviewsInput
}

export type ReviewCreateOrConnectWithoutStageInput = {
  where: ReviewWhereUniqueInput
  create: ReviewCreateWithoutStageInput
}

export type ReviewCreateManyWithoutStageInput = {
  create?: Enumerable<ReviewCreateWithoutStageInput>
  connect?: Enumerable<ReviewWhereUniqueInput>
  connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutStageInput>
}

export type StageCreateWithoutApplicationsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutStageInput
  workspace: WorkspaceCreateOneWithoutStagesInput
  pipeline: PipelineCreateOneWithoutStagesInput
  reviews?: ReviewCreateManyWithoutStageInput | null
}

export type StageCreateOrConnectWithoutApplicationInput = {
  where: StageWhereUniqueInput
  create: StageCreateWithoutApplicationsInput
}

export type StageCreateOneWithoutApplicationsInput = {
  create?: StageCreateWithoutApplicationsInput
  connect?: StageWhereUniqueInput
  connectOrCreate?: StageCreateOrConnectWithoutApplicationInput
}

export type ApplicationCreateWithoutCandidateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutApplicationInput
  workspace: WorkspaceCreateOneWithoutApplicationsInput
  job: JobCreateOneWithoutApplicationsInput
  source: SourceCreateOneWithoutApplicationsInput
  stage: StageCreateOneWithoutApplicationsInput
  reviews?: ReviewCreateManyWithoutApplicationInput | null
}

export type ApplicationCreateOrConnectWithoutCandidateInput = {
  where: ApplicationWhereUniqueInput
  create: ApplicationCreateWithoutCandidateInput
}

export type ApplicationCreateManyWithoutCandidateInput = {
  create?: Enumerable<ApplicationCreateWithoutCandidateInput>
  connect?: Enumerable<ApplicationWhereUniqueInput>
  connectOrCreate?: Enumerable<ApplicationCreateOrConnectWithoutCandidateInput>
}

export type CandidateCreateWithoutFieldsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  firstName?: string | null
  lastName?: string | null
  headline?: string | null
  emails?: CandidateCreateemailsInput
  links?: CandidateCreatelinksInput
  phones?: CandidateCreatephonesInput
  node: NodeCreateOneWithoutCandidateInput
  workspace: WorkspaceCreateOneWithoutCandidatesInput
  tags?: TagCreateManyWithoutCandidatesInput | null
  applications?: ApplicationCreateManyWithoutCandidateInput | null
}

export type CandidateCreateOrConnectWithoutFieldValueInput = {
  where: CandidateWhereUniqueInput
  create: CandidateCreateWithoutFieldsInput
}

export type CandidateCreateOneWithoutFieldsInput = {
  create?: CandidateCreateWithoutFieldsInput
  connect?: CandidateWhereUniqueInput
  connectOrCreate?: CandidateCreateOrConnectWithoutFieldValueInput
}

export type FieldValueCreateWithoutDefinitionInput = {
  value: InputJsonValue
  candidate: CandidateCreateOneWithoutFieldsInput
}

export type FieldValueCreateOrConnectWithoutFieldDefinitionInput = {
  where: FieldValueWhereUniqueInput
  create: FieldValueCreateWithoutDefinitionInput
}

export type FieldValueCreateManyWithoutDefinitionInput = {
  create?: Enumerable<FieldValueCreateWithoutDefinitionInput>
  connect?: Enumerable<FieldValueWhereUniqueInput>
  connectOrCreate?: Enumerable<FieldValueCreateOrConnectWithoutFieldDefinitionInput>
}

export type FieldDefinitionCreateWithoutWorkspaceInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  type: FieldType
  node: NodeCreateOneWithoutFieldInput
  values?: FieldValueCreateManyWithoutDefinitionInput | null
}

export type FieldDefinitionCreateOrConnectWithoutWorkspaceInput = {
  where: FieldDefinitionWhereUniqueInput
  create: FieldDefinitionCreateWithoutWorkspaceInput
}

export type FieldDefinitionCreateManyWithoutWorkspaceInput = {
  create?: Enumerable<FieldDefinitionCreateWithoutWorkspaceInput>
  connect?: Enumerable<FieldDefinitionWhereUniqueInput>
  connectOrCreate?: Enumerable<FieldDefinitionCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  users?: UserCreateManyWithoutWorkspacesInput | null
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutNodeInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutNodeInput
}

export type WorkspaceCreateOneWithoutNodeInput = {
  create?: WorkspaceCreateWithoutNodeInput
  connect?: WorkspaceWhereUniqueInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutNodeInput
}

export type NodeCreateWithoutNotificationInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  client?: ClientCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutNotificationInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutNotificationInput
}

export type NodeCreateOneWithoutNotificationInput = {
  create?: NodeCreateWithoutNotificationInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutNotificationInput
}

export type NotificationCreateWithoutWorkspaceInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutNotificationInput
}

export type NotificationCreateOrConnectWithoutWorkspaceInput = {
  where: NotificationWhereUniqueInput
  create: NotificationCreateWithoutWorkspaceInput
}

export type NotificationCreateManyWithoutWorkspaceInput = {
  create?: Enumerable<NotificationCreateWithoutWorkspaceInput>
  connect?: Enumerable<NotificationWhereUniqueInput>
  connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceCreateWithoutFieldsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  users?: UserCreateManyWithoutWorkspacesInput | null
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutFieldDefinitionInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutFieldsInput
}

export type WorkspaceCreateOneWithoutFieldsInput = {
  create?: WorkspaceCreateWithoutFieldsInput
  connect?: WorkspaceWhereUniqueInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutFieldDefinitionInput
}

export type FieldDefinitionCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  type: FieldType
  workspace: WorkspaceCreateOneWithoutFieldsInput
  values?: FieldValueCreateManyWithoutDefinitionInput | null
}

export type FieldDefinitionCreateOrConnectWithoutNodeInput = {
  where: FieldDefinitionWhereUniqueInput
  create: FieldDefinitionCreateWithoutNodeInput
}

export type FieldDefinitionCreateOneWithoutNodeInput = {
  create?: FieldDefinitionCreateWithoutNodeInput
  connect?: FieldDefinitionWhereUniqueInput
  connectOrCreate?: FieldDefinitionCreateOrConnectWithoutNodeInput
}

export type NodeCreateWithoutAppointmentInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  client?: ClientCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutAppointmentInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutAppointmentInput
}

export type NodeCreateOneWithoutAppointmentInput = {
  create?: NodeCreateWithoutAppointmentInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutAppointmentInput
}

export type UserCreateWithoutAppointmentsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  email: string
  avatarUrl?: string | null
  node: NodeCreateOneWithoutUserInput
  workspaces?: WorkspaceCreateManyWithoutUsersInput | null
  comments?: CommentCreateManyWithoutAuthorInput | null
  reviews?: ReviewCreateManyWithoutAuthorInput | null
}

export type UserCreateOrConnectWithoutAppointmentInput = {
  where: UserWhereUniqueInput
  create: UserCreateWithoutAppointmentsInput
}

export type UserCreateOneWithoutAppointmentsInput = {
  create?: UserCreateWithoutAppointmentsInput
  connect?: UserWhereUniqueInput
  connectOrCreate?: UserCreateOrConnectWithoutAppointmentInput
}

export type AppointmentCreateWithoutWorkspaceInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  node: NodeCreateOneWithoutAppointmentInput
  owner: UserCreateOneWithoutAppointmentsInput
}

export type AppointmentCreateOrConnectWithoutWorkspaceInput = {
  where: AppointmentWhereUniqueInput
  create: AppointmentCreateWithoutWorkspaceInput
}

export type AppointmentCreateManyWithoutWorkspaceInput = {
  create?: Enumerable<AppointmentCreateWithoutWorkspaceInput>
  connect?: Enumerable<AppointmentWhereUniqueInput>
  connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceCreateWithoutNotificationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  users?: UserCreateManyWithoutWorkspacesInput | null
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutNotificationInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutNotificationInput
}

export type WorkspaceCreateOneWithoutNotificationInput = {
  create?: WorkspaceCreateWithoutNotificationInput
  connect?: WorkspaceWhereUniqueInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutNotificationInput
}

export type NotificationCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  workspace: WorkspaceCreateOneWithoutNotificationInput
}

export type NotificationCreateOrConnectWithoutNodeInput = {
  where: NotificationWhereUniqueInput
  create: NotificationCreateWithoutNodeInput
}

export type NotificationCreateOneWithoutNodeInput = {
  create?: NotificationCreateWithoutNodeInput
  connect?: NotificationWhereUniqueInput
  connectOrCreate?: NotificationCreateOrConnectWithoutNodeInput
}

export type NodeCreateWithoutEventInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  client?: ClientCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutEventInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutEventInput
}

export type NodeCreateOneWithoutEventInput = {
  create?: NodeCreateWithoutEventInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutEventInput
}

export type EventCreateWithoutWorkspaceInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutEventInput
}

export type EventCreateOrConnectWithoutWorkspaceInput = {
  where: EventWhereUniqueInput
  create: EventCreateWithoutWorkspaceInput
}

export type EventCreateManyWithoutWorkspaceInput = {
  create?: Enumerable<EventCreateWithoutWorkspaceInput>
  connect?: Enumerable<EventWhereUniqueInput>
  connectOrCreate?: Enumerable<EventCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceCreateWithoutAppointmentInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  users?: UserCreateManyWithoutWorkspacesInput | null
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutAppointmentInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutAppointmentInput
}

export type WorkspaceCreateOneWithoutAppointmentInput = {
  create?: WorkspaceCreateWithoutAppointmentInput
  connect?: WorkspaceWhereUniqueInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutAppointmentInput
}

export type AppointmentCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  workspace: WorkspaceCreateOneWithoutAppointmentInput
  owner: UserCreateOneWithoutAppointmentsInput
}

export type AppointmentCreateOrConnectWithoutNodeInput = {
  where: AppointmentWhereUniqueInput
  create: AppointmentCreateWithoutNodeInput
}

export type AppointmentCreateOneWithoutNodeInput = {
  create?: AppointmentCreateWithoutNodeInput
  connect?: AppointmentWhereUniqueInput
  connectOrCreate?: AppointmentCreateOrConnectWithoutNodeInput
}

export type NodeCreateWithoutReviewInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  client?: ClientCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutReviewInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutReviewInput
}

export type NodeCreateOneWithoutReviewInput = {
  create?: NodeCreateWithoutReviewInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutReviewInput
}

export type ReviewCreateWithoutWorkspaceInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string | null
  score?: number | null
  node: NodeCreateOneWithoutReviewInput
  author: UserCreateOneWithoutReviewsInput
  application: ApplicationCreateOneWithoutReviewsInput
  stage?: StageCreateOneWithoutReviewsInput | null
}

export type ReviewCreateOrConnectWithoutWorkspaceInput = {
  where: ReviewWhereUniqueInput
  create: ReviewCreateWithoutWorkspaceInput
}

export type ReviewCreateManyWithoutWorkspaceInput = {
  create?: Enumerable<ReviewCreateWithoutWorkspaceInput>
  connect?: Enumerable<ReviewWhereUniqueInput>
  connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceCreateWithoutEventInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  users?: UserCreateManyWithoutWorkspacesInput | null
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutEventInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutEventInput
}

export type WorkspaceCreateOneWithoutEventInput = {
  create?: WorkspaceCreateWithoutEventInput
  connect?: WorkspaceWhereUniqueInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutEventInput
}

export type EventCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  workspace: WorkspaceCreateOneWithoutEventInput
}

export type EventCreateOrConnectWithoutNodeInput = {
  where: EventWhereUniqueInput
  create: EventCreateWithoutNodeInput
}

export type EventCreateOneWithoutNodeInput = {
  create?: EventCreateWithoutNodeInput
  connect?: EventWhereUniqueInput
  connectOrCreate?: EventCreateOrConnectWithoutNodeInput
}

export type NodeCreateWithoutLocationInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  client?: ClientCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutLocationInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutLocationInput
}

export type NodeCreateOneWithoutLocationInput = {
  create?: NodeCreateWithoutLocationInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutLocationInput
}

export type ApplicationCreateWithoutJobInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutApplicationInput
  workspace: WorkspaceCreateOneWithoutApplicationsInput
  candidate: CandidateCreateOneWithoutApplicationsInput
  source: SourceCreateOneWithoutApplicationsInput
  stage: StageCreateOneWithoutApplicationsInput
  reviews?: ReviewCreateManyWithoutApplicationInput | null
}

export type ApplicationCreateOrConnectWithoutJobInput = {
  where: ApplicationWhereUniqueInput
  create: ApplicationCreateWithoutJobInput
}

export type ApplicationCreateManyWithoutJobInput = {
  create?: Enumerable<ApplicationCreateWithoutJobInput>
  connect?: Enumerable<ApplicationWhereUniqueInput>
  connectOrCreate?: Enumerable<ApplicationCreateOrConnectWithoutJobInput>
}

export type JobCreateWithoutLocationsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  status: JobStatus
  node: NodeCreateOneWithoutJobInput
  workspace: WorkspaceCreateOneWithoutJobInput
  client: ClientCreateOneWithoutJobsInput
  applications?: ApplicationCreateManyWithoutJobInput | null
}

export type JobCreateOrConnectWithoutLocationInput = {
  where: JobWhereUniqueInput
  create: JobCreateWithoutLocationsInput
}

export type JobCreateManyWithoutLocationsInput = {
  create?: Enumerable<JobCreateWithoutLocationsInput>
  connect?: Enumerable<JobWhereUniqueInput>
  connectOrCreate?: Enumerable<JobCreateOrConnectWithoutLocationInput>
}

export type LocationCreateWithoutWorkspaceInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string | null
  description?: string | null
  country: string
  city?: string | null
  node: NodeCreateOneWithoutLocationInput
  jobs?: JobCreateManyWithoutLocationsInput | null
}

export type LocationCreateOrConnectWithoutWorkspaceInput = {
  where: LocationWhereUniqueInput
  create: LocationCreateWithoutWorkspaceInput
}

export type LocationCreateManyWithoutWorkspaceInput = {
  create?: Enumerable<LocationCreateWithoutWorkspaceInput>
  connect?: Enumerable<LocationWhereUniqueInput>
  connectOrCreate?: Enumerable<LocationCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceCreateWithoutReviewsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  users?: UserCreateManyWithoutWorkspacesInput | null
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutReviewInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutReviewsInput
}

export type WorkspaceCreateOneWithoutReviewsInput = {
  create?: WorkspaceCreateWithoutReviewsInput
  connect?: WorkspaceWhereUniqueInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutReviewInput
}

export type ReviewCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string | null
  score?: number | null
  workspace: WorkspaceCreateOneWithoutReviewsInput
  author: UserCreateOneWithoutReviewsInput
  application: ApplicationCreateOneWithoutReviewsInput
  stage?: StageCreateOneWithoutReviewsInput | null
}

export type ReviewCreateOrConnectWithoutNodeInput = {
  where: ReviewWhereUniqueInput
  create: ReviewCreateWithoutNodeInput
}

export type ReviewCreateOneWithoutNodeInput = {
  create?: ReviewCreateWithoutNodeInput
  connect?: ReviewWhereUniqueInput
  connectOrCreate?: ReviewCreateOrConnectWithoutNodeInput
}

export type NodeCreateWithoutStageInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  client?: ClientCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutStageInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutStageInput
}

export type NodeCreateOneWithoutStageInput = {
  create?: NodeCreateWithoutStageInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutStageInput
}

export type StageCreateWithoutWorkspaceInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutStageInput
  pipeline: PipelineCreateOneWithoutStagesInput
  applications?: ApplicationCreateManyWithoutStageInput | null
  reviews?: ReviewCreateManyWithoutStageInput | null
}

export type StageCreateOrConnectWithoutWorkspaceInput = {
  where: StageWhereUniqueInput
  create: StageCreateWithoutWorkspaceInput
}

export type StageCreateManyWithoutWorkspaceInput = {
  create?: Enumerable<StageCreateWithoutWorkspaceInput>
  connect?: Enumerable<StageWhereUniqueInput>
  connectOrCreate?: Enumerable<StageCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceCreateWithoutLocationsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  users?: UserCreateManyWithoutWorkspacesInput | null
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutLocationInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutLocationsInput
}

export type WorkspaceCreateOneWithoutLocationsInput = {
  create?: WorkspaceCreateWithoutLocationsInput
  connect?: WorkspaceWhereUniqueInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutLocationInput
}

export type LocationCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string | null
  description?: string | null
  country: string
  city?: string | null
  workspace: WorkspaceCreateOneWithoutLocationsInput
  jobs?: JobCreateManyWithoutLocationsInput | null
}

export type LocationCreateOrConnectWithoutNodeInput = {
  where: LocationWhereUniqueInput
  create: LocationCreateWithoutNodeInput
}

export type LocationCreateOneWithoutNodeInput = {
  create?: LocationCreateWithoutNodeInput
  connect?: LocationWhereUniqueInput
  connectOrCreate?: LocationCreateOrConnectWithoutNodeInput
}

export type NodeCreateWithoutPipelineInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  client?: ClientCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutPipelineInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutPipelineInput
}

export type NodeCreateOneWithoutPipelineInput = {
  create?: NodeCreateWithoutPipelineInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutPipelineInput
}

export type StageCreateWithoutPipelineInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutStageInput
  workspace: WorkspaceCreateOneWithoutStagesInput
  applications?: ApplicationCreateManyWithoutStageInput | null
  reviews?: ReviewCreateManyWithoutStageInput | null
}

export type StageCreateOrConnectWithoutPipelineInput = {
  where: StageWhereUniqueInput
  create: StageCreateWithoutPipelineInput
}

export type StageCreateManyWithoutPipelineInput = {
  create?: Enumerable<StageCreateWithoutPipelineInput>
  connect?: Enumerable<StageWhereUniqueInput>
  connectOrCreate?: Enumerable<StageCreateOrConnectWithoutPipelineInput>
}

export type PipelineCreateWithoutWorkspaceInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutPipelineInput
  stages?: StageCreateManyWithoutPipelineInput | null
}

export type PipelineCreateOrConnectWithoutWorkspaceInput = {
  where: PipelineWhereUniqueInput
  create: PipelineCreateWithoutWorkspaceInput
}

export type PipelineCreateManyWithoutWorkspaceInput = {
  create?: Enumerable<PipelineCreateWithoutWorkspaceInput>
  connect?: Enumerable<PipelineWhereUniqueInput>
  connectOrCreate?: Enumerable<PipelineCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceCreateWithoutStagesInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  users?: UserCreateManyWithoutWorkspacesInput | null
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutStageInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutStagesInput
}

export type WorkspaceCreateOneWithoutStagesInput = {
  create?: WorkspaceCreateWithoutStagesInput
  connect?: WorkspaceWhereUniqueInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutStageInput
}

export type StageCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  workspace: WorkspaceCreateOneWithoutStagesInput
  pipeline: PipelineCreateOneWithoutStagesInput
  applications?: ApplicationCreateManyWithoutStageInput | null
  reviews?: ReviewCreateManyWithoutStageInput | null
}

export type StageCreateOrConnectWithoutNodeInput = {
  where: StageWhereUniqueInput
  create: StageCreateWithoutNodeInput
}

export type StageCreateOneWithoutNodeInput = {
  create?: StageCreateWithoutNodeInput
  connect?: StageWhereUniqueInput
  connectOrCreate?: StageCreateOrConnectWithoutNodeInput
}

export type NodeCreateWithoutSourceInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  client?: ClientCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutSourceInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutSourceInput
}

export type NodeCreateOneWithoutSourceInput = {
  create?: NodeCreateWithoutSourceInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutSourceInput
}

export type ApplicationCreateWithoutSourceInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutApplicationInput
  workspace: WorkspaceCreateOneWithoutApplicationsInput
  job: JobCreateOneWithoutApplicationsInput
  candidate: CandidateCreateOneWithoutApplicationsInput
  stage: StageCreateOneWithoutApplicationsInput
  reviews?: ReviewCreateManyWithoutApplicationInput | null
}

export type ApplicationCreateOrConnectWithoutSourceInput = {
  where: ApplicationWhereUniqueInput
  create: ApplicationCreateWithoutSourceInput
}

export type ApplicationCreateManyWithoutSourceInput = {
  create?: Enumerable<ApplicationCreateWithoutSourceInput>
  connect?: Enumerable<ApplicationWhereUniqueInput>
  connectOrCreate?: Enumerable<ApplicationCreateOrConnectWithoutSourceInput>
}

export type SourceCreateWithoutWorkspaceInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  node: NodeCreateOneWithoutSourceInput
  applications?: ApplicationCreateManyWithoutSourceInput | null
}

export type SourceCreateOrConnectWithoutWorkspaceInput = {
  where: SourceWhereUniqueInput
  create: SourceCreateWithoutWorkspaceInput
}

export type SourceCreateManyWithoutWorkspaceInput = {
  create?: Enumerable<SourceCreateWithoutWorkspaceInput>
  connect?: Enumerable<SourceWhereUniqueInput>
  connectOrCreate?: Enumerable<SourceCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceCreateWithoutPipelinesInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  users?: UserCreateManyWithoutWorkspacesInput | null
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutPipelineInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutPipelinesInput
}

export type WorkspaceCreateOneWithoutPipelinesInput = {
  create?: WorkspaceCreateWithoutPipelinesInput
  connect?: WorkspaceWhereUniqueInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutPipelineInput
}

export type PipelineCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  workspace: WorkspaceCreateOneWithoutPipelinesInput
  stages?: StageCreateManyWithoutPipelineInput | null
}

export type PipelineCreateOrConnectWithoutNodeInput = {
  where: PipelineWhereUniqueInput
  create: PipelineCreateWithoutNodeInput
}

export type PipelineCreateOneWithoutNodeInput = {
  create?: PipelineCreateWithoutNodeInput
  connect?: PipelineWhereUniqueInput
  connectOrCreate?: PipelineCreateOrConnectWithoutNodeInput
}

export type NodeCreateWithoutCommentInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  client?: ClientCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutCommentInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutCommentInput
}

export type NodeCreateOneWithoutCommentInput = {
  create?: NodeCreateWithoutCommentInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutCommentInput
}

export type CommentCreateWithoutWorkspaceInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message: string
  node: NodeCreateOneWithoutCommentInput
  author: UserCreateOneWithoutCommentsInput
  parent?: CommentCreateOneWithoutRepliesInput | null
  replies?: CommentCreateManyWithoutParentInput | null
}

export type CommentCreateOrConnectWithoutWorkspaceInput = {
  where: CommentWhereUniqueInput
  create: CommentCreateWithoutWorkspaceInput
}

export type CommentCreateManyWithoutWorkspaceInput = {
  create?: Enumerable<CommentCreateWithoutWorkspaceInput>
  connect?: Enumerable<CommentWhereUniqueInput>
  connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceCreateWithoutSourcesInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  users?: UserCreateManyWithoutWorkspacesInput | null
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutSourceInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutSourcesInput
}

export type WorkspaceCreateOneWithoutSourcesInput = {
  create?: WorkspaceCreateWithoutSourcesInput
  connect?: WorkspaceWhereUniqueInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutSourceInput
}

export type SourceCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  workspace: WorkspaceCreateOneWithoutSourcesInput
  applications?: ApplicationCreateManyWithoutSourceInput | null
}

export type SourceCreateOrConnectWithoutNodeInput = {
  where: SourceWhereUniqueInput
  create: SourceCreateWithoutNodeInput
}

export type SourceCreateOneWithoutNodeInput = {
  create?: SourceCreateWithoutNodeInput
  connect?: SourceWhereUniqueInput
  connectOrCreate?: SourceCreateOrConnectWithoutNodeInput
}

export type NodeCreateWithoutTagInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  client?: ClientCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutTagInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutTagInput
}

export type NodeCreateOneWithoutTagInput = {
  create?: NodeCreateWithoutTagInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutTagInput
}

export type CandidateCreateWithoutTagsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  firstName?: string | null
  lastName?: string | null
  headline?: string | null
  emails?: CandidateCreateemailsInput
  links?: CandidateCreatelinksInput
  phones?: CandidateCreatephonesInput
  node: NodeCreateOneWithoutCandidateInput
  workspace: WorkspaceCreateOneWithoutCandidatesInput
  applications?: ApplicationCreateManyWithoutCandidateInput | null
  fields?: FieldValueCreateManyWithoutCandidateInput | null
}

export type CandidateCreateOrConnectWithoutTagInput = {
  where: CandidateWhereUniqueInput
  create: CandidateCreateWithoutTagsInput
}

export type CandidateCreateManyWithoutTagsInput = {
  create?: Enumerable<CandidateCreateWithoutTagsInput>
  connect?: Enumerable<CandidateWhereUniqueInput>
  connectOrCreate?: Enumerable<CandidateCreateOrConnectWithoutTagInput>
}

export type TagCreateWithoutWorkspaceInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  types?: TagCreatetypesInput
  node: NodeCreateOneWithoutTagInput
  candidates?: CandidateCreateManyWithoutTagsInput | null
}

export type TagCreateOrConnectWithoutWorkspaceInput = {
  where: TagWhereUniqueInput
  create: TagCreateWithoutWorkspaceInput
}

export type TagCreateManyWithoutWorkspaceInput = {
  create?: Enumerable<TagCreateWithoutWorkspaceInput>
  connect?: Enumerable<TagWhereUniqueInput>
  connectOrCreate?: Enumerable<TagCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceCreateWithoutCommentsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  users?: UserCreateManyWithoutWorkspacesInput | null
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutCommentInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutCommentsInput
}

export type WorkspaceCreateOneWithoutCommentsInput = {
  create?: WorkspaceCreateWithoutCommentsInput
  connect?: WorkspaceWhereUniqueInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutCommentInput
}

export type CommentCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message: string
  workspace: WorkspaceCreateOneWithoutCommentsInput
  author: UserCreateOneWithoutCommentsInput
  parent?: CommentCreateOneWithoutRepliesInput | null
  replies?: CommentCreateManyWithoutParentInput | null
}

export type CommentCreateOrConnectWithoutNodeInput = {
  where: CommentWhereUniqueInput
  create: CommentCreateWithoutNodeInput
}

export type CommentCreateOneWithoutNodeInput = {
  create?: CommentCreateWithoutNodeInput
  connect?: CommentWhereUniqueInput
  connectOrCreate?: CommentCreateOrConnectWithoutNodeInput
}

export type NodeCreateWithoutJobInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  client?: ClientCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutJobInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutJobInput
}

export type NodeCreateOneWithoutJobInput = {
  create?: NodeCreateWithoutJobInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutJobInput
}

export type JobCreateWithoutWorkspaceInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  status: JobStatus
  node: NodeCreateOneWithoutJobInput
  client: ClientCreateOneWithoutJobsInput
  applications?: ApplicationCreateManyWithoutJobInput | null
  locations?: LocationCreateManyWithoutJobsInput | null
}

export type JobCreateOrConnectWithoutWorkspaceInput = {
  where: JobWhereUniqueInput
  create: JobCreateWithoutWorkspaceInput
}

export type JobCreateManyWithoutWorkspaceInput = {
  create?: Enumerable<JobCreateWithoutWorkspaceInput>
  connect?: Enumerable<JobWhereUniqueInput>
  connectOrCreate?: Enumerable<JobCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceCreateWithoutTagsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  users?: UserCreateManyWithoutWorkspacesInput | null
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutTagInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutTagsInput
}

export type WorkspaceCreateOneWithoutTagsInput = {
  create?: WorkspaceCreateWithoutTagsInput
  connect?: WorkspaceWhereUniqueInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutTagInput
}

export type TagCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  types?: TagCreatetypesInput
  workspace: WorkspaceCreateOneWithoutTagsInput
  candidates?: CandidateCreateManyWithoutTagsInput | null
}

export type TagCreateOrConnectWithoutNodeInput = {
  where: TagWhereUniqueInput
  create: TagCreateWithoutNodeInput
}

export type TagCreateOneWithoutNodeInput = {
  create?: TagCreateWithoutNodeInput
  connect?: TagWhereUniqueInput
  connectOrCreate?: TagCreateOrConnectWithoutNodeInput
}

export type NodeCreateWithoutApplicationInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  client?: ClientCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutApplicationInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutApplicationInput
}

export type NodeCreateOneWithoutApplicationInput = {
  create?: NodeCreateWithoutApplicationInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutApplicationInput
}

export type ApplicationCreateWithoutWorkspaceInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutApplicationInput
  job: JobCreateOneWithoutApplicationsInput
  candidate: CandidateCreateOneWithoutApplicationsInput
  source: SourceCreateOneWithoutApplicationsInput
  stage: StageCreateOneWithoutApplicationsInput
  reviews?: ReviewCreateManyWithoutApplicationInput | null
}

export type ApplicationCreateOrConnectWithoutWorkspaceInput = {
  where: ApplicationWhereUniqueInput
  create: ApplicationCreateWithoutWorkspaceInput
}

export type ApplicationCreateManyWithoutWorkspaceInput = {
  create?: Enumerable<ApplicationCreateWithoutWorkspaceInput>
  connect?: Enumerable<ApplicationWhereUniqueInput>
  connectOrCreate?: Enumerable<ApplicationCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceCreateWithoutJobInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  users?: UserCreateManyWithoutWorkspacesInput | null
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutJobInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutJobInput
}

export type WorkspaceCreateOneWithoutJobInput = {
  create?: WorkspaceCreateWithoutJobInput
  connect?: WorkspaceWhereUniqueInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutJobInput
}

export type JobCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  status: JobStatus
  workspace: WorkspaceCreateOneWithoutJobInput
  client: ClientCreateOneWithoutJobsInput
  applications?: ApplicationCreateManyWithoutJobInput | null
  locations?: LocationCreateManyWithoutJobsInput | null
}

export type JobCreateOrConnectWithoutNodeInput = {
  where: JobWhereUniqueInput
  create: JobCreateWithoutNodeInput
}

export type JobCreateOneWithoutNodeInput = {
  create?: JobCreateWithoutNodeInput
  connect?: JobWhereUniqueInput
  connectOrCreate?: JobCreateOrConnectWithoutNodeInput
}

export type NodeCreateWithoutCandidateInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  client?: ClientCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutCandidateInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutCandidateInput
}

export type NodeCreateOneWithoutCandidateInput = {
  create?: NodeCreateWithoutCandidateInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutCandidateInput
}

export type CandidateCreateWithoutWorkspaceInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  firstName?: string | null
  lastName?: string | null
  headline?: string | null
  emails?: CandidateCreateemailsInput
  links?: CandidateCreatelinksInput
  phones?: CandidateCreatephonesInput
  node: NodeCreateOneWithoutCandidateInput
  tags?: TagCreateManyWithoutCandidatesInput | null
  applications?: ApplicationCreateManyWithoutCandidateInput | null
  fields?: FieldValueCreateManyWithoutCandidateInput | null
}

export type CandidateCreateOrConnectWithoutWorkspaceInput = {
  where: CandidateWhereUniqueInput
  create: CandidateCreateWithoutWorkspaceInput
}

export type CandidateCreateManyWithoutWorkspaceInput = {
  create?: Enumerable<CandidateCreateWithoutWorkspaceInput>
  connect?: Enumerable<CandidateWhereUniqueInput>
  connectOrCreate?: Enumerable<CandidateCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceCreateWithoutApplicationsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  users?: UserCreateManyWithoutWorkspacesInput | null
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutApplicationInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutApplicationsInput
}

export type WorkspaceCreateOneWithoutApplicationsInput = {
  create?: WorkspaceCreateWithoutApplicationsInput
  connect?: WorkspaceWhereUniqueInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutApplicationInput
}

export type ApplicationCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  workspace: WorkspaceCreateOneWithoutApplicationsInput
  job: JobCreateOneWithoutApplicationsInput
  candidate: CandidateCreateOneWithoutApplicationsInput
  source: SourceCreateOneWithoutApplicationsInput
  stage: StageCreateOneWithoutApplicationsInput
  reviews?: ReviewCreateManyWithoutApplicationInput | null
}

export type ApplicationCreateOrConnectWithoutNodeInput = {
  where: ApplicationWhereUniqueInput
  create: ApplicationCreateWithoutNodeInput
}

export type ApplicationCreateOneWithoutNodeInput = {
  create?: ApplicationCreateWithoutNodeInput
  connect?: ApplicationWhereUniqueInput
  connectOrCreate?: ApplicationCreateOrConnectWithoutNodeInput
}

export type NodeCreateWithoutClientInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutClientInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutClientInput
}

export type NodeCreateOneWithoutClientInput = {
  create?: NodeCreateWithoutClientInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutClientInput
}

export type JobCreateWithoutClientInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  status: JobStatus
  node: NodeCreateOneWithoutJobInput
  workspace: WorkspaceCreateOneWithoutJobInput
  applications?: ApplicationCreateManyWithoutJobInput | null
  locations?: LocationCreateManyWithoutJobsInput | null
}

export type JobCreateOrConnectWithoutClientInput = {
  where: JobWhereUniqueInput
  create: JobCreateWithoutClientInput
}

export type JobCreateManyWithoutClientInput = {
  create?: Enumerable<JobCreateWithoutClientInput>
  connect?: Enumerable<JobWhereUniqueInput>
  connectOrCreate?: Enumerable<JobCreateOrConnectWithoutClientInput>
}

export type ClientCreateWithoutWorkspaceInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  node: NodeCreateOneWithoutClientInput
  jobs?: JobCreateManyWithoutClientInput | null
}

export type ClientCreateOrConnectWithoutWorkspaceInput = {
  where: ClientWhereUniqueInput
  create: ClientCreateWithoutWorkspaceInput
}

export type ClientCreateManyWithoutWorkspaceInput = {
  create?: Enumerable<ClientCreateWithoutWorkspaceInput>
  connect?: Enumerable<ClientWhereUniqueInput>
  connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceCreateWithoutCandidatesInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  users?: UserCreateManyWithoutWorkspacesInput | null
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutCandidateInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutCandidatesInput
}

export type WorkspaceCreateOneWithoutCandidatesInput = {
  create?: WorkspaceCreateWithoutCandidatesInput
  connect?: WorkspaceWhereUniqueInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutCandidateInput
}

export type CandidateCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  firstName?: string | null
  lastName?: string | null
  headline?: string | null
  emails?: CandidateCreateemailsInput
  links?: CandidateCreatelinksInput
  phones?: CandidateCreatephonesInput
  workspace: WorkspaceCreateOneWithoutCandidatesInput
  tags?: TagCreateManyWithoutCandidatesInput | null
  applications?: ApplicationCreateManyWithoutCandidateInput | null
  fields?: FieldValueCreateManyWithoutCandidateInput | null
}

export type CandidateCreateOrConnectWithoutNodeInput = {
  where: CandidateWhereUniqueInput
  create: CandidateCreateWithoutNodeInput
}

export type CandidateCreateOneWithoutNodeInput = {
  create?: CandidateCreateWithoutNodeInput
  connect?: CandidateWhereUniqueInput
  connectOrCreate?: CandidateCreateOrConnectWithoutNodeInput
}

export type NodeCreateWithoutUserInput = {
  id?: string
  client?: ClientCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutUserInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutUserInput
}

export type NodeCreateOneWithoutUserInput = {
  create?: NodeCreateWithoutUserInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutUserInput
}

export type UserCreateWithoutWorkspacesInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  email: string
  avatarUrl?: string | null
  node: NodeCreateOneWithoutUserInput
  comments?: CommentCreateManyWithoutAuthorInput | null
  reviews?: ReviewCreateManyWithoutAuthorInput | null
  appointments?: AppointmentCreateManyWithoutOwnerInput | null
}

export type UserCreateOrConnectWithoutWorkspaceInput = {
  where: UserWhereUniqueInput
  create: UserCreateWithoutWorkspacesInput
}

export type UserCreateManyWithoutWorkspacesInput = {
  create?: Enumerable<UserCreateWithoutWorkspacesInput>
  connect?: Enumerable<UserWhereUniqueInput>
  connectOrCreate?: Enumerable<UserCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceCreateWithoutClientsInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  users?: UserCreateManyWithoutWorkspacesInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutClientInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutClientsInput
}

export type WorkspaceCreateOneWithoutClientsInput = {
  create?: WorkspaceCreateWithoutClientsInput
  connect?: WorkspaceWhereUniqueInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutClientInput
}

export type ClientCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  workspace: WorkspaceCreateOneWithoutClientsInput
  jobs?: JobCreateManyWithoutClientInput | null
}

export type ClientCreateOrConnectWithoutNodeInput = {
  where: ClientWhereUniqueInput
  create: ClientCreateWithoutNodeInput
}

export type ClientCreateOneWithoutNodeInput = {
  create?: ClientCreateWithoutNodeInput
  connect?: ClientWhereUniqueInput
  connectOrCreate?: ClientCreateOrConnectWithoutNodeInput
}

export type NodeCreateWithoutWorkspaceInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  client?: ClientCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
}

export type NodeCreateOrConnectWithoutWorkspaceInput = {
  where: NodeWhereUniqueInput
  create: NodeCreateWithoutWorkspaceInput
}

export type NodeCreateOneWithoutWorkspaceInput = {
  create?: NodeCreateWithoutWorkspaceInput
  connect?: NodeWhereUniqueInput
  connectOrCreate?: NodeCreateOrConnectWithoutWorkspaceInput
}

export type WorkspaceCreateWithoutUsersInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceCreateOrConnectWithoutUserInput = {
  where: WorkspaceWhereUniqueInput
  create: WorkspaceCreateWithoutUsersInput
}

export type WorkspaceCreateManyWithoutUsersInput = {
  create?: Enumerable<WorkspaceCreateWithoutUsersInput>
  connect?: Enumerable<WorkspaceWhereUniqueInput>
  connectOrCreate?: Enumerable<WorkspaceCreateOrConnectWithoutUserInput>
}

export type UserCreateWithoutNodeInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  email: string
  avatarUrl?: string | null
  workspaces?: WorkspaceCreateManyWithoutUsersInput | null
  comments?: CommentCreateManyWithoutAuthorInput | null
  reviews?: ReviewCreateManyWithoutAuthorInput | null
  appointments?: AppointmentCreateManyWithoutOwnerInput | null
}

export type UserCreateOrConnectWithoutNodeInput = {
  where: UserWhereUniqueInput
  create: UserCreateWithoutNodeInput
}

export type UserCreateOneWithoutNodeInput = {
  create?: UserCreateWithoutNodeInput
  connect?: UserWhereUniqueInput
  connectOrCreate?: UserCreateOrConnectWithoutNodeInput
}

export type NodeCreateInput = {
  id?: string
  user?: UserCreateOneWithoutNodeInput | null
  client?: ClientCreateOneWithoutNodeInput | null
  candidate?: CandidateCreateOneWithoutNodeInput | null
  application?: ApplicationCreateOneWithoutNodeInput | null
  job?: JobCreateOneWithoutNodeInput | null
  tag?: TagCreateOneWithoutNodeInput | null
  comment?: CommentCreateOneWithoutNodeInput | null
  source?: SourceCreateOneWithoutNodeInput | null
  pipeline?: PipelineCreateOneWithoutNodeInput | null
  stage?: StageCreateOneWithoutNodeInput | null
  location?: LocationCreateOneWithoutNodeInput | null
  review?: ReviewCreateOneWithoutNodeInput | null
  event?: EventCreateOneWithoutNodeInput | null
  appointment?: AppointmentCreateOneWithoutNodeInput | null
  notification?: NotificationCreateOneWithoutNodeInput | null
  field?: FieldDefinitionCreateOneWithoutNodeInput | null
  workspace?: WorkspaceCreateOneWithoutNodeInput | null
}

export type CandidateUpdateemailsInput = {
  set?: Enumerable<string> | null
}

export type CandidateUpdatelinksInput = {
  set?: Enumerable<string> | null
}

export type CandidateUpdatephonesInput = {
  set?: Enumerable<string> | null
}

export type TagUpdatetypesInput = {
  set?: Enumerable<TagType> | null
}

export type NodeUpdateWithoutFieldDataInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  client?: ClientUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutFieldInput = {
  update: NodeUpdateWithoutFieldDataInput
  create: NodeCreateWithoutFieldInput
}

export type NodeUpdateOneRequiredWithoutFieldInput = {
  create?: NodeCreateWithoutFieldInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutFieldDataInput
  upsert?: NodeUpsertWithoutFieldInput
  connectOrCreate?: NodeCreateOrConnectWithoutFieldDefinitionInput
}

export type TagUpdateWithoutCandidatesDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  types?: TagUpdatetypesInput
  node?: NodeUpdateOneRequiredWithoutTagInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutTagsInput | null
}

export type TagUpdateWithWhereUniqueWithoutCandidatesInput = {
  where: TagWhereUniqueInput
  data: TagUpdateWithoutCandidatesDataInput
}

export type TagScalarWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  name?: string | StringFilter
  description?: string | NullableStringFilter | null
  candidates?: CandidateFilter | null
  AND?: Enumerable<TagScalarWhereInput>
  OR?: Array<TagScalarWhereInput>
  NOT?: Enumerable<TagScalarWhereInput>
}

export type TagUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  types?: TagUpdatetypesInput
}

export type TagUpdateManyWithWhereNestedInput = {
  where: TagScalarWhereInput
  data: TagUpdateManyDataInput
}

export type TagUpsertWithWhereUniqueWithoutCandidatesInput = {
  where: TagWhereUniqueInput
  update: TagUpdateWithoutCandidatesDataInput
  create: TagCreateWithoutCandidatesInput
}

export type TagUpdateManyWithoutCandidatesInput = {
  create?: Enumerable<TagCreateWithoutCandidatesInput>
  connect?: Enumerable<TagWhereUniqueInput>
  set?: Enumerable<TagWhereUniqueInput>
  disconnect?: Enumerable<TagWhereUniqueInput>
  delete?: Enumerable<TagWhereUniqueInput>
  update?: Enumerable<TagUpdateWithWhereUniqueWithoutCandidatesInput>
  updateMany?: Enumerable<TagUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<TagScalarWhereInput>
  upsert?: Enumerable<TagUpsertWithWhereUniqueWithoutCandidatesInput>
  connectOrCreate?: Enumerable<TagCreateOrConnectWithoutCandidateInput>
}

export type ClientUpdateWithoutJobsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  node?: NodeUpdateOneRequiredWithoutClientInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutClientsInput | null
}

export type ClientUpsertWithoutJobsInput = {
  update: ClientUpdateWithoutJobsDataInput
  create: ClientCreateWithoutJobsInput
}

export type ClientUpdateOneRequiredWithoutJobsInput = {
  create?: ClientCreateWithoutJobsInput
  connect?: ClientWhereUniqueInput
  update?: ClientUpdateWithoutJobsDataInput
  upsert?: ClientUpsertWithoutJobsInput
  connectOrCreate?: ClientCreateOrConnectWithoutJobInput
}

export type LocationUpdateWithoutJobsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string | null
  description?: string | null
  country?: string
  city?: string | null
  node?: NodeUpdateOneRequiredWithoutLocationInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutLocationsInput | null
}

export type LocationUpdateWithWhereUniqueWithoutJobsInput = {
  where: LocationWhereUniqueInput
  data: LocationUpdateWithoutJobsDataInput
}

export type LocationScalarWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  name?: string | NullableStringFilter | null
  description?: string | NullableStringFilter | null
  country?: string | StringFilter
  city?: string | NullableStringFilter | null
  jobs?: JobFilter | null
  AND?: Enumerable<LocationScalarWhereInput>
  OR?: Array<LocationScalarWhereInput>
  NOT?: Enumerable<LocationScalarWhereInput>
}

export type LocationUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string | null
  description?: string | null
  country?: string
  city?: string | null
}

export type LocationUpdateManyWithWhereNestedInput = {
  where: LocationScalarWhereInput
  data: LocationUpdateManyDataInput
}

export type LocationUpsertWithWhereUniqueWithoutJobsInput = {
  where: LocationWhereUniqueInput
  update: LocationUpdateWithoutJobsDataInput
  create: LocationCreateWithoutJobsInput
}

export type LocationUpdateManyWithoutJobsInput = {
  create?: Enumerable<LocationCreateWithoutJobsInput>
  connect?: Enumerable<LocationWhereUniqueInput>
  set?: Enumerable<LocationWhereUniqueInput>
  disconnect?: Enumerable<LocationWhereUniqueInput>
  delete?: Enumerable<LocationWhereUniqueInput>
  update?: Enumerable<LocationUpdateWithWhereUniqueWithoutJobsInput>
  updateMany?: Enumerable<LocationUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<LocationScalarWhereInput>
  upsert?: Enumerable<LocationUpsertWithWhereUniqueWithoutJobsInput>
  connectOrCreate?: Enumerable<LocationCreateOrConnectWithoutJobInput>
}

export type JobUpdateWithoutApplicationsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  status?: JobStatus
  node?: NodeUpdateOneRequiredWithoutJobInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutJobInput | null
  client?: ClientUpdateOneRequiredWithoutJobsInput | null
  locations?: LocationUpdateManyWithoutJobsInput | null
}

export type JobUpsertWithoutApplicationsInput = {
  update: JobUpdateWithoutApplicationsDataInput
  create: JobCreateWithoutApplicationsInput
}

export type JobUpdateOneRequiredWithoutApplicationsInput = {
  create?: JobCreateWithoutApplicationsInput
  connect?: JobWhereUniqueInput
  update?: JobUpdateWithoutApplicationsDataInput
  upsert?: JobUpsertWithoutApplicationsInput
  connectOrCreate?: JobCreateOrConnectWithoutApplicationInput
}

export type SourceUpdateWithoutApplicationsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  node?: NodeUpdateOneRequiredWithoutSourceInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutSourcesInput | null
}

export type SourceUpsertWithoutApplicationsInput = {
  update: SourceUpdateWithoutApplicationsDataInput
  create: SourceCreateWithoutApplicationsInput
}

export type SourceUpdateOneRequiredWithoutApplicationsInput = {
  create?: SourceCreateWithoutApplicationsInput
  connect?: SourceWhereUniqueInput
  update?: SourceUpdateWithoutApplicationsDataInput
  upsert?: SourceUpsertWithoutApplicationsInput
  connectOrCreate?: SourceCreateOrConnectWithoutApplicationInput
}

export type PipelineUpdateWithoutStagesDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutPipelineInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutPipelinesInput | null
}

export type PipelineUpsertWithoutStagesInput = {
  update: PipelineUpdateWithoutStagesDataInput
  create: PipelineCreateWithoutStagesInput
}

export type PipelineUpdateOneRequiredWithoutStagesInput = {
  create?: PipelineCreateWithoutStagesInput
  connect?: PipelineWhereUniqueInput
  update?: PipelineUpdateWithoutStagesDataInput
  upsert?: PipelineUpsertWithoutStagesInput
  connectOrCreate?: PipelineCreateOrConnectWithoutStageInput
}

export type FieldDefinitionUpdateWithoutValuesDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  type?: FieldType
  node?: NodeUpdateOneRequiredWithoutFieldInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutFieldsInput | null
}

export type FieldDefinitionUpsertWithoutValuesInput = {
  update: FieldDefinitionUpdateWithoutValuesDataInput
  create: FieldDefinitionCreateWithoutValuesInput
}

export type FieldDefinitionUpdateOneRequiredWithoutValuesInput = {
  create?: FieldDefinitionCreateWithoutValuesInput
  connect?: FieldDefinitionWhereUniqueInput
  update?: FieldDefinitionUpdateWithoutValuesDataInput
  upsert?: FieldDefinitionUpsertWithoutValuesInput
  connectOrCreate?: FieldDefinitionCreateOrConnectWithoutFieldValueInput
}

export type FieldValueUpdateWithoutCandidateDataInput = {
  value?: InputJsonValue
  definition?: FieldDefinitionUpdateOneRequiredWithoutValuesInput | null
}

export type FieldValueUpdateWithWhereUniqueWithoutCandidateInput = {
  where: FieldValueWhereUniqueInput
  data: FieldValueUpdateWithoutCandidateDataInput
}

export type FieldValueScalarWhereInput = {
  value?: InputJsonValue | JsonFilter
  definitionId?: string | StringFilter
  candidateId?: string | StringFilter
  AND?: Enumerable<FieldValueScalarWhereInput>
  OR?: Array<FieldValueScalarWhereInput>
  NOT?: Enumerable<FieldValueScalarWhereInput>
}

export type FieldValueUpdateManyDataInput = {
  value?: InputJsonValue
}

export type FieldValueUpdateManyWithWhereNestedInput = {
  where: FieldValueScalarWhereInput
  data: FieldValueUpdateManyDataInput
}

export type FieldValueUpsertWithWhereUniqueWithoutCandidateInput = {
  where: FieldValueWhereUniqueInput
  update: FieldValueUpdateWithoutCandidateDataInput
  create: FieldValueCreateWithoutCandidateInput
}

export type FieldValueUpdateManyWithoutCandidateInput = {
  create?: Enumerable<FieldValueCreateWithoutCandidateInput>
  connect?: Enumerable<FieldValueWhereUniqueInput>
  set?: Enumerable<FieldValueWhereUniqueInput>
  disconnect?: Enumerable<FieldValueWhereUniqueInput>
  delete?: Enumerable<FieldValueWhereUniqueInput>
  update?: Enumerable<FieldValueUpdateWithWhereUniqueWithoutCandidateInput>
  updateMany?: Enumerable<FieldValueUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<FieldValueScalarWhereInput>
  upsert?: Enumerable<FieldValueUpsertWithWhereUniqueWithoutCandidateInput>
  connectOrCreate?: Enumerable<FieldValueCreateOrConnectWithoutCandidateInput>
}

export type CandidateUpdateWithoutApplicationsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  firstName?: string | null
  lastName?: string | null
  headline?: string | null
  emails?: CandidateUpdateemailsInput
  links?: CandidateUpdatelinksInput
  phones?: CandidateUpdatephonesInput
  node?: NodeUpdateOneRequiredWithoutCandidateInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutCandidatesInput | null
  tags?: TagUpdateManyWithoutCandidatesInput | null
  fields?: FieldValueUpdateManyWithoutCandidateInput | null
}

export type CandidateUpsertWithoutApplicationsInput = {
  update: CandidateUpdateWithoutApplicationsDataInput
  create: CandidateCreateWithoutApplicationsInput
}

export type CandidateUpdateOneRequiredWithoutApplicationsInput = {
  create?: CandidateCreateWithoutApplicationsInput
  connect?: CandidateWhereUniqueInput
  update?: CandidateUpdateWithoutApplicationsDataInput
  upsert?: CandidateUpsertWithoutApplicationsInput
  connectOrCreate?: CandidateCreateOrConnectWithoutApplicationInput
}

export type ApplicationUpdateWithoutReviewsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutApplicationInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutApplicationsInput | null
  job?: JobUpdateOneRequiredWithoutApplicationsInput | null
  candidate?: CandidateUpdateOneRequiredWithoutApplicationsInput | null
  source?: SourceUpdateOneRequiredWithoutApplicationsInput | null
  stage?: StageUpdateOneRequiredWithoutApplicationsInput | null
}

export type ApplicationUpsertWithoutReviewsInput = {
  update: ApplicationUpdateWithoutReviewsDataInput
  create: ApplicationCreateWithoutReviewsInput
}

export type ApplicationUpdateOneRequiredWithoutReviewsInput = {
  create?: ApplicationCreateWithoutReviewsInput
  connect?: ApplicationWhereUniqueInput
  update?: ApplicationUpdateWithoutReviewsDataInput
  upsert?: ApplicationUpsertWithoutReviewsInput
  connectOrCreate?: ApplicationCreateOrConnectWithoutReviewInput
}

export type ReviewUpdateWithoutApplicationDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string | null
  score?: number | null
  node?: NodeUpdateOneRequiredWithoutReviewInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutReviewsInput | null
  author?: UserUpdateOneRequiredWithoutReviewsInput | null
  stage?: StageUpdateOneWithoutReviewsInput | null
}

export type ReviewUpdateWithWhereUniqueWithoutApplicationInput = {
  where: ReviewWhereUniqueInput
  data: ReviewUpdateWithoutApplicationDataInput
}

export type ReviewScalarWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  message?: string | NullableStringFilter | null
  score?: number | NullableIntFilter | null
  authorId?: string | StringFilter
  applicationId?: string | StringFilter
  stageId?: string | NullableStringFilter | null
  AND?: Enumerable<ReviewScalarWhereInput>
  OR?: Array<ReviewScalarWhereInput>
  NOT?: Enumerable<ReviewScalarWhereInput>
}

export type ReviewUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string | null
  score?: number | null
}

export type ReviewUpdateManyWithWhereNestedInput = {
  where: ReviewScalarWhereInput
  data: ReviewUpdateManyDataInput
}

export type ReviewUpsertWithWhereUniqueWithoutApplicationInput = {
  where: ReviewWhereUniqueInput
  update: ReviewUpdateWithoutApplicationDataInput
  create: ReviewCreateWithoutApplicationInput
}

export type ReviewUpdateManyWithoutApplicationInput = {
  create?: Enumerable<ReviewCreateWithoutApplicationInput>
  connect?: Enumerable<ReviewWhereUniqueInput>
  set?: Enumerable<ReviewWhereUniqueInput>
  disconnect?: Enumerable<ReviewWhereUniqueInput>
  delete?: Enumerable<ReviewWhereUniqueInput>
  update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutApplicationInput>
  updateMany?: Enumerable<ReviewUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<ReviewScalarWhereInput>
  upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutApplicationInput>
  connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutApplicationInput>
}

export type ApplicationUpdateWithoutStageDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutApplicationInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutApplicationsInput | null
  job?: JobUpdateOneRequiredWithoutApplicationsInput | null
  candidate?: CandidateUpdateOneRequiredWithoutApplicationsInput | null
  source?: SourceUpdateOneRequiredWithoutApplicationsInput | null
  reviews?: ReviewUpdateManyWithoutApplicationInput | null
}

export type ApplicationUpdateWithWhereUniqueWithoutStageInput = {
  where: ApplicationWhereUniqueInput
  data: ApplicationUpdateWithoutStageDataInput
}

export type ApplicationScalarWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  jobId?: string | StringFilter
  candidateId?: string | StringFilter
  sourceId?: string | StringFilter
  stageId?: string | StringFilter
  reviews?: ReviewFilter | null
  AND?: Enumerable<ApplicationScalarWhereInput>
  OR?: Array<ApplicationScalarWhereInput>
  NOT?: Enumerable<ApplicationScalarWhereInput>
}

export type ApplicationUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
}

export type ApplicationUpdateManyWithWhereNestedInput = {
  where: ApplicationScalarWhereInput
  data: ApplicationUpdateManyDataInput
}

export type ApplicationUpsertWithWhereUniqueWithoutStageInput = {
  where: ApplicationWhereUniqueInput
  update: ApplicationUpdateWithoutStageDataInput
  create: ApplicationCreateWithoutStageInput
}

export type ApplicationUpdateManyWithoutStageInput = {
  create?: Enumerable<ApplicationCreateWithoutStageInput>
  connect?: Enumerable<ApplicationWhereUniqueInput>
  set?: Enumerable<ApplicationWhereUniqueInput>
  disconnect?: Enumerable<ApplicationWhereUniqueInput>
  delete?: Enumerable<ApplicationWhereUniqueInput>
  update?: Enumerable<ApplicationUpdateWithWhereUniqueWithoutStageInput>
  updateMany?: Enumerable<ApplicationUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<ApplicationScalarWhereInput>
  upsert?: Enumerable<ApplicationUpsertWithWhereUniqueWithoutStageInput>
  connectOrCreate?: Enumerable<ApplicationCreateOrConnectWithoutStageInput>
}

export type StageUpdateWithoutReviewsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutStageInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutStagesInput | null
  pipeline?: PipelineUpdateOneRequiredWithoutStagesInput | null
  applications?: ApplicationUpdateManyWithoutStageInput | null
}

export type StageUpsertWithoutReviewsInput = {
  update: StageUpdateWithoutReviewsDataInput
  create: StageCreateWithoutReviewsInput
}

export type StageUpdateOneWithoutReviewsInput = {
  create?: StageCreateWithoutReviewsInput
  connect?: StageWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: StageUpdateWithoutReviewsDataInput
  upsert?: StageUpsertWithoutReviewsInput
  connectOrCreate?: StageCreateOrConnectWithoutReviewInput
}

export type ReviewUpdateWithoutAuthorDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string | null
  score?: number | null
  node?: NodeUpdateOneRequiredWithoutReviewInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutReviewsInput | null
  application?: ApplicationUpdateOneRequiredWithoutReviewsInput | null
  stage?: StageUpdateOneWithoutReviewsInput | null
}

export type ReviewUpdateWithWhereUniqueWithoutAuthorInput = {
  where: ReviewWhereUniqueInput
  data: ReviewUpdateWithoutAuthorDataInput
}

export type ReviewUpsertWithWhereUniqueWithoutAuthorInput = {
  where: ReviewWhereUniqueInput
  update: ReviewUpdateWithoutAuthorDataInput
  create: ReviewCreateWithoutAuthorInput
}

export type ReviewUpdateManyWithoutAuthorInput = {
  create?: Enumerable<ReviewCreateWithoutAuthorInput>
  connect?: Enumerable<ReviewWhereUniqueInput>
  set?: Enumerable<ReviewWhereUniqueInput>
  disconnect?: Enumerable<ReviewWhereUniqueInput>
  delete?: Enumerable<ReviewWhereUniqueInput>
  update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutAuthorInput>
  updateMany?: Enumerable<ReviewUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<ReviewScalarWhereInput>
  upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutAuthorInput>
  connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutUserInput>
}

export type AppointmentUpdateWithoutOwnerDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  node?: NodeUpdateOneRequiredWithoutAppointmentInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutAppointmentInput | null
}

export type AppointmentUpdateWithWhereUniqueWithoutOwnerInput = {
  where: AppointmentWhereUniqueInput
  data: AppointmentUpdateWithoutOwnerDataInput
}

export type AppointmentScalarWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  name?: string | StringFilter
  description?: string | NullableStringFilter | null
  ownerId?: string | StringFilter
  AND?: Enumerable<AppointmentScalarWhereInput>
  OR?: Array<AppointmentScalarWhereInput>
  NOT?: Enumerable<AppointmentScalarWhereInput>
}

export type AppointmentUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
}

export type AppointmentUpdateManyWithWhereNestedInput = {
  where: AppointmentScalarWhereInput
  data: AppointmentUpdateManyDataInput
}

export type AppointmentUpsertWithWhereUniqueWithoutOwnerInput = {
  where: AppointmentWhereUniqueInput
  update: AppointmentUpdateWithoutOwnerDataInput
  create: AppointmentCreateWithoutOwnerInput
}

export type AppointmentUpdateManyWithoutOwnerInput = {
  create?: Enumerable<AppointmentCreateWithoutOwnerInput>
  connect?: Enumerable<AppointmentWhereUniqueInput>
  set?: Enumerable<AppointmentWhereUniqueInput>
  disconnect?: Enumerable<AppointmentWhereUniqueInput>
  delete?: Enumerable<AppointmentWhereUniqueInput>
  update?: Enumerable<AppointmentUpdateWithWhereUniqueWithoutOwnerInput>
  updateMany?: Enumerable<AppointmentUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<AppointmentScalarWhereInput>
  upsert?: Enumerable<AppointmentUpsertWithWhereUniqueWithoutOwnerInput>
  connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutUserInput>
}

export type UserUpdateWithoutCommentsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  email?: string
  avatarUrl?: string | null
  node?: NodeUpdateOneRequiredWithoutUserInput | null
  workspaces?: WorkspaceUpdateManyWithoutUsersInput | null
  reviews?: ReviewUpdateManyWithoutAuthorInput | null
  appointments?: AppointmentUpdateManyWithoutOwnerInput | null
}

export type UserUpsertWithoutCommentsInput = {
  update: UserUpdateWithoutCommentsDataInput
  create: UserCreateWithoutCommentsInput
}

export type UserUpdateOneRequiredWithoutCommentsInput = {
  create?: UserCreateWithoutCommentsInput
  connect?: UserWhereUniqueInput
  update?: UserUpdateWithoutCommentsDataInput
  upsert?: UserUpsertWithoutCommentsInput
  connectOrCreate?: UserCreateOrConnectWithoutCommentInput
}

export type CommentUpdateWithoutRepliesDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string
  node?: NodeUpdateOneRequiredWithoutCommentInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutCommentsInput | null
  author?: UserUpdateOneRequiredWithoutCommentsInput | null
  parent?: CommentUpdateOneWithoutRepliesInput | null
}

export type CommentUpsertWithoutRepliesInput = {
  update: CommentUpdateWithoutRepliesDataInput
  create: CommentCreateWithoutRepliesInput
}

export type CommentUpdateOneWithoutRepliesInput = {
  create?: CommentCreateWithoutRepliesInput
  connect?: CommentWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: CommentUpdateWithoutRepliesDataInput
  upsert?: CommentUpsertWithoutRepliesInput
  connectOrCreate?: CommentCreateOrConnectWithoutCommentInput
}

export type CommentUpdateWithoutParentDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string
  node?: NodeUpdateOneRequiredWithoutCommentInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutCommentsInput | null
  author?: UserUpdateOneRequiredWithoutCommentsInput | null
  replies?: CommentUpdateManyWithoutParentInput | null
}

export type CommentUpdateWithWhereUniqueWithoutParentInput = {
  where: CommentWhereUniqueInput
  data: CommentUpdateWithoutParentDataInput
}

export type CommentScalarWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  message?: string | StringFilter
  authorId?: string | StringFilter
  parentId?: string | NullableStringFilter | null
  replies?: CommentFilter | null
  AND?: Enumerable<CommentScalarWhereInput>
  OR?: Array<CommentScalarWhereInput>
  NOT?: Enumerable<CommentScalarWhereInput>
}

export type CommentUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string
}

export type CommentUpdateManyWithWhereNestedInput = {
  where: CommentScalarWhereInput
  data: CommentUpdateManyDataInput
}

export type CommentUpsertWithWhereUniqueWithoutParentInput = {
  where: CommentWhereUniqueInput
  update: CommentUpdateWithoutParentDataInput
  create: CommentCreateWithoutParentInput
}

export type CommentUpdateManyWithoutParentInput = {
  create?: Enumerable<CommentCreateWithoutParentInput>
  connect?: Enumerable<CommentWhereUniqueInput>
  set?: Enumerable<CommentWhereUniqueInput>
  disconnect?: Enumerable<CommentWhereUniqueInput>
  delete?: Enumerable<CommentWhereUniqueInput>
  update?: Enumerable<CommentUpdateWithWhereUniqueWithoutParentInput>
  updateMany?: Enumerable<CommentUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<CommentScalarWhereInput>
  upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutParentInput>
  connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCommentInput>
}

export type CommentUpdateWithoutAuthorDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string
  node?: NodeUpdateOneRequiredWithoutCommentInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutCommentsInput | null
  parent?: CommentUpdateOneWithoutRepliesInput | null
  replies?: CommentUpdateManyWithoutParentInput | null
}

export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
  where: CommentWhereUniqueInput
  data: CommentUpdateWithoutAuthorDataInput
}

export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
  where: CommentWhereUniqueInput
  update: CommentUpdateWithoutAuthorDataInput
  create: CommentCreateWithoutAuthorInput
}

export type CommentUpdateManyWithoutAuthorInput = {
  create?: Enumerable<CommentCreateWithoutAuthorInput>
  connect?: Enumerable<CommentWhereUniqueInput>
  set?: Enumerable<CommentWhereUniqueInput>
  disconnect?: Enumerable<CommentWhereUniqueInput>
  delete?: Enumerable<CommentWhereUniqueInput>
  update?: Enumerable<CommentUpdateWithWhereUniqueWithoutAuthorInput>
  updateMany?: Enumerable<CommentUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<CommentScalarWhereInput>
  upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutAuthorInput>
  connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutUserInput>
}

export type UserUpdateWithoutReviewsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  email?: string
  avatarUrl?: string | null
  node?: NodeUpdateOneRequiredWithoutUserInput | null
  workspaces?: WorkspaceUpdateManyWithoutUsersInput | null
  comments?: CommentUpdateManyWithoutAuthorInput | null
  appointments?: AppointmentUpdateManyWithoutOwnerInput | null
}

export type UserUpsertWithoutReviewsInput = {
  update: UserUpdateWithoutReviewsDataInput
  create: UserCreateWithoutReviewsInput
}

export type UserUpdateOneRequiredWithoutReviewsInput = {
  create?: UserCreateWithoutReviewsInput
  connect?: UserWhereUniqueInput
  update?: UserUpdateWithoutReviewsDataInput
  upsert?: UserUpsertWithoutReviewsInput
  connectOrCreate?: UserCreateOrConnectWithoutReviewInput
}

export type ReviewUpdateWithoutStageDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string | null
  score?: number | null
  node?: NodeUpdateOneRequiredWithoutReviewInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutReviewsInput | null
  author?: UserUpdateOneRequiredWithoutReviewsInput | null
  application?: ApplicationUpdateOneRequiredWithoutReviewsInput | null
}

export type ReviewUpdateWithWhereUniqueWithoutStageInput = {
  where: ReviewWhereUniqueInput
  data: ReviewUpdateWithoutStageDataInput
}

export type ReviewUpsertWithWhereUniqueWithoutStageInput = {
  where: ReviewWhereUniqueInput
  update: ReviewUpdateWithoutStageDataInput
  create: ReviewCreateWithoutStageInput
}

export type ReviewUpdateManyWithoutStageInput = {
  create?: Enumerable<ReviewCreateWithoutStageInput>
  connect?: Enumerable<ReviewWhereUniqueInput>
  set?: Enumerable<ReviewWhereUniqueInput>
  disconnect?: Enumerable<ReviewWhereUniqueInput>
  delete?: Enumerable<ReviewWhereUniqueInput>
  update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutStageInput>
  updateMany?: Enumerable<ReviewUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<ReviewScalarWhereInput>
  upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutStageInput>
  connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutStageInput>
}

export type StageUpdateWithoutApplicationsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutStageInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutStagesInput | null
  pipeline?: PipelineUpdateOneRequiredWithoutStagesInput | null
  reviews?: ReviewUpdateManyWithoutStageInput | null
}

export type StageUpsertWithoutApplicationsInput = {
  update: StageUpdateWithoutApplicationsDataInput
  create: StageCreateWithoutApplicationsInput
}

export type StageUpdateOneRequiredWithoutApplicationsInput = {
  create?: StageCreateWithoutApplicationsInput
  connect?: StageWhereUniqueInput
  update?: StageUpdateWithoutApplicationsDataInput
  upsert?: StageUpsertWithoutApplicationsInput
  connectOrCreate?: StageCreateOrConnectWithoutApplicationInput
}

export type ApplicationUpdateWithoutCandidateDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutApplicationInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutApplicationsInput | null
  job?: JobUpdateOneRequiredWithoutApplicationsInput | null
  source?: SourceUpdateOneRequiredWithoutApplicationsInput | null
  stage?: StageUpdateOneRequiredWithoutApplicationsInput | null
  reviews?: ReviewUpdateManyWithoutApplicationInput | null
}

export type ApplicationUpdateWithWhereUniqueWithoutCandidateInput = {
  where: ApplicationWhereUniqueInput
  data: ApplicationUpdateWithoutCandidateDataInput
}

export type ApplicationUpsertWithWhereUniqueWithoutCandidateInput = {
  where: ApplicationWhereUniqueInput
  update: ApplicationUpdateWithoutCandidateDataInput
  create: ApplicationCreateWithoutCandidateInput
}

export type ApplicationUpdateManyWithoutCandidateInput = {
  create?: Enumerable<ApplicationCreateWithoutCandidateInput>
  connect?: Enumerable<ApplicationWhereUniqueInput>
  set?: Enumerable<ApplicationWhereUniqueInput>
  disconnect?: Enumerable<ApplicationWhereUniqueInput>
  delete?: Enumerable<ApplicationWhereUniqueInput>
  update?: Enumerable<ApplicationUpdateWithWhereUniqueWithoutCandidateInput>
  updateMany?: Enumerable<ApplicationUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<ApplicationScalarWhereInput>
  upsert?: Enumerable<ApplicationUpsertWithWhereUniqueWithoutCandidateInput>
  connectOrCreate?: Enumerable<ApplicationCreateOrConnectWithoutCandidateInput>
}

export type CandidateUpdateWithoutFieldsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  firstName?: string | null
  lastName?: string | null
  headline?: string | null
  emails?: CandidateUpdateemailsInput
  links?: CandidateUpdatelinksInput
  phones?: CandidateUpdatephonesInput
  node?: NodeUpdateOneRequiredWithoutCandidateInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutCandidatesInput | null
  tags?: TagUpdateManyWithoutCandidatesInput | null
  applications?: ApplicationUpdateManyWithoutCandidateInput | null
}

export type CandidateUpsertWithoutFieldsInput = {
  update: CandidateUpdateWithoutFieldsDataInput
  create: CandidateCreateWithoutFieldsInput
}

export type CandidateUpdateOneRequiredWithoutFieldsInput = {
  create?: CandidateCreateWithoutFieldsInput
  connect?: CandidateWhereUniqueInput
  update?: CandidateUpdateWithoutFieldsDataInput
  upsert?: CandidateUpsertWithoutFieldsInput
  connectOrCreate?: CandidateCreateOrConnectWithoutFieldValueInput
}

export type FieldValueUpdateWithoutDefinitionDataInput = {
  value?: InputJsonValue
  candidate?: CandidateUpdateOneRequiredWithoutFieldsInput | null
}

export type FieldValueUpdateWithWhereUniqueWithoutDefinitionInput = {
  where: FieldValueWhereUniqueInput
  data: FieldValueUpdateWithoutDefinitionDataInput
}

export type FieldValueUpsertWithWhereUniqueWithoutDefinitionInput = {
  where: FieldValueWhereUniqueInput
  update: FieldValueUpdateWithoutDefinitionDataInput
  create: FieldValueCreateWithoutDefinitionInput
}

export type FieldValueUpdateManyWithoutDefinitionInput = {
  create?: Enumerable<FieldValueCreateWithoutDefinitionInput>
  connect?: Enumerable<FieldValueWhereUniqueInput>
  set?: Enumerable<FieldValueWhereUniqueInput>
  disconnect?: Enumerable<FieldValueWhereUniqueInput>
  delete?: Enumerable<FieldValueWhereUniqueInput>
  update?: Enumerable<FieldValueUpdateWithWhereUniqueWithoutDefinitionInput>
  updateMany?: Enumerable<FieldValueUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<FieldValueScalarWhereInput>
  upsert?: Enumerable<FieldValueUpsertWithWhereUniqueWithoutDefinitionInput>
  connectOrCreate?: Enumerable<FieldValueCreateOrConnectWithoutFieldDefinitionInput>
}

export type FieldDefinitionUpdateWithoutWorkspaceDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  type?: FieldType
  node?: NodeUpdateOneRequiredWithoutFieldInput | null
  values?: FieldValueUpdateManyWithoutDefinitionInput | null
}

export type FieldDefinitionUpdateWithWhereUniqueWithoutWorkspaceInput = {
  where: FieldDefinitionWhereUniqueInput
  data: FieldDefinitionUpdateWithoutWorkspaceDataInput
}

export type FieldDefinitionScalarWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  name?: string | StringFilter
  type?: FieldType | FieldTypeFilter
  values?: FieldValueFilter | null
  AND?: Enumerable<FieldDefinitionScalarWhereInput>
  OR?: Array<FieldDefinitionScalarWhereInput>
  NOT?: Enumerable<FieldDefinitionScalarWhereInput>
}

export type FieldDefinitionUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  type?: FieldType
}

export type FieldDefinitionUpdateManyWithWhereNestedInput = {
  where: FieldDefinitionScalarWhereInput
  data: FieldDefinitionUpdateManyDataInput
}

export type FieldDefinitionUpsertWithWhereUniqueWithoutWorkspaceInput = {
  where: FieldDefinitionWhereUniqueInput
  update: FieldDefinitionUpdateWithoutWorkspaceDataInput
  create: FieldDefinitionCreateWithoutWorkspaceInput
}

export type FieldDefinitionUpdateManyWithoutWorkspaceInput = {
  create?: Enumerable<FieldDefinitionCreateWithoutWorkspaceInput>
  connect?: Enumerable<FieldDefinitionWhereUniqueInput>
  set?: Enumerable<FieldDefinitionWhereUniqueInput>
  disconnect?: Enumerable<FieldDefinitionWhereUniqueInput>
  delete?: Enumerable<FieldDefinitionWhereUniqueInput>
  update?: Enumerable<FieldDefinitionUpdateWithWhereUniqueWithoutWorkspaceInput>
  updateMany?: Enumerable<FieldDefinitionUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<FieldDefinitionScalarWhereInput>
  upsert?: Enumerable<FieldDefinitionUpsertWithWhereUniqueWithoutWorkspaceInput>
  connectOrCreate?: Enumerable<FieldDefinitionCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  users?: UserUpdateManyWithoutWorkspacesInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpsertWithoutNodeInput = {
  update: WorkspaceUpdateWithoutNodeDataInput
  create: WorkspaceCreateWithoutNodeInput
}

export type WorkspaceUpdateOneWithoutNodeInput = {
  create?: WorkspaceCreateWithoutNodeInput
  connect?: WorkspaceWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: WorkspaceUpdateWithoutNodeDataInput
  upsert?: WorkspaceUpsertWithoutNodeInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutNodeInput
}

export type NodeUpdateWithoutNotificationDataInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  client?: ClientUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutNotificationInput = {
  update: NodeUpdateWithoutNotificationDataInput
  create: NodeCreateWithoutNotificationInput
}

export type NodeUpdateOneRequiredWithoutNotificationInput = {
  create?: NodeCreateWithoutNotificationInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutNotificationDataInput
  upsert?: NodeUpsertWithoutNotificationInput
  connectOrCreate?: NodeCreateOrConnectWithoutNotificationInput
}

export type NotificationUpdateWithoutWorkspaceDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutNotificationInput | null
}

export type NotificationUpdateWithWhereUniqueWithoutWorkspaceInput = {
  where: NotificationWhereUniqueInput
  data: NotificationUpdateWithoutWorkspaceDataInput
}

export type NotificationScalarWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  AND?: Enumerable<NotificationScalarWhereInput>
  OR?: Array<NotificationScalarWhereInput>
  NOT?: Enumerable<NotificationScalarWhereInput>
}

export type NotificationUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
}

export type NotificationUpdateManyWithWhereNestedInput = {
  where: NotificationScalarWhereInput
  data: NotificationUpdateManyDataInput
}

export type NotificationUpsertWithWhereUniqueWithoutWorkspaceInput = {
  where: NotificationWhereUniqueInput
  update: NotificationUpdateWithoutWorkspaceDataInput
  create: NotificationCreateWithoutWorkspaceInput
}

export type NotificationUpdateManyWithoutWorkspaceInput = {
  create?: Enumerable<NotificationCreateWithoutWorkspaceInput>
  connect?: Enumerable<NotificationWhereUniqueInput>
  set?: Enumerable<NotificationWhereUniqueInput>
  disconnect?: Enumerable<NotificationWhereUniqueInput>
  delete?: Enumerable<NotificationWhereUniqueInput>
  update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutWorkspaceInput>
  updateMany?: Enumerable<NotificationUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<NotificationScalarWhereInput>
  upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutWorkspaceInput>
  connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceUpdateWithoutFieldsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  users?: UserUpdateManyWithoutWorkspacesInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpsertWithoutFieldsInput = {
  update: WorkspaceUpdateWithoutFieldsDataInput
  create: WorkspaceCreateWithoutFieldsInput
}

export type WorkspaceUpdateOneRequiredWithoutFieldsInput = {
  create?: WorkspaceCreateWithoutFieldsInput
  connect?: WorkspaceWhereUniqueInput
  update?: WorkspaceUpdateWithoutFieldsDataInput
  upsert?: WorkspaceUpsertWithoutFieldsInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutFieldDefinitionInput
}

export type FieldDefinitionUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  type?: FieldType
  workspace?: WorkspaceUpdateOneRequiredWithoutFieldsInput | null
  values?: FieldValueUpdateManyWithoutDefinitionInput | null
}

export type FieldDefinitionUpsertWithoutNodeInput = {
  update: FieldDefinitionUpdateWithoutNodeDataInput
  create: FieldDefinitionCreateWithoutNodeInput
}

export type FieldDefinitionUpdateOneWithoutNodeInput = {
  create?: FieldDefinitionCreateWithoutNodeInput
  connect?: FieldDefinitionWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: FieldDefinitionUpdateWithoutNodeDataInput
  upsert?: FieldDefinitionUpsertWithoutNodeInput
  connectOrCreate?: FieldDefinitionCreateOrConnectWithoutNodeInput
}

export type NodeUpdateWithoutAppointmentDataInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  client?: ClientUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutAppointmentInput = {
  update: NodeUpdateWithoutAppointmentDataInput
  create: NodeCreateWithoutAppointmentInput
}

export type NodeUpdateOneRequiredWithoutAppointmentInput = {
  create?: NodeCreateWithoutAppointmentInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutAppointmentDataInput
  upsert?: NodeUpsertWithoutAppointmentInput
  connectOrCreate?: NodeCreateOrConnectWithoutAppointmentInput
}

export type UserUpdateWithoutAppointmentsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  email?: string
  avatarUrl?: string | null
  node?: NodeUpdateOneRequiredWithoutUserInput | null
  workspaces?: WorkspaceUpdateManyWithoutUsersInput | null
  comments?: CommentUpdateManyWithoutAuthorInput | null
  reviews?: ReviewUpdateManyWithoutAuthorInput | null
}

export type UserUpsertWithoutAppointmentsInput = {
  update: UserUpdateWithoutAppointmentsDataInput
  create: UserCreateWithoutAppointmentsInput
}

export type UserUpdateOneRequiredWithoutAppointmentsInput = {
  create?: UserCreateWithoutAppointmentsInput
  connect?: UserWhereUniqueInput
  update?: UserUpdateWithoutAppointmentsDataInput
  upsert?: UserUpsertWithoutAppointmentsInput
  connectOrCreate?: UserCreateOrConnectWithoutAppointmentInput
}

export type AppointmentUpdateWithoutWorkspaceDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  node?: NodeUpdateOneRequiredWithoutAppointmentInput | null
  owner?: UserUpdateOneRequiredWithoutAppointmentsInput | null
}

export type AppointmentUpdateWithWhereUniqueWithoutWorkspaceInput = {
  where: AppointmentWhereUniqueInput
  data: AppointmentUpdateWithoutWorkspaceDataInput
}

export type AppointmentUpsertWithWhereUniqueWithoutWorkspaceInput = {
  where: AppointmentWhereUniqueInput
  update: AppointmentUpdateWithoutWorkspaceDataInput
  create: AppointmentCreateWithoutWorkspaceInput
}

export type AppointmentUpdateManyWithoutWorkspaceInput = {
  create?: Enumerable<AppointmentCreateWithoutWorkspaceInput>
  connect?: Enumerable<AppointmentWhereUniqueInput>
  set?: Enumerable<AppointmentWhereUniqueInput>
  disconnect?: Enumerable<AppointmentWhereUniqueInput>
  delete?: Enumerable<AppointmentWhereUniqueInput>
  update?: Enumerable<AppointmentUpdateWithWhereUniqueWithoutWorkspaceInput>
  updateMany?: Enumerable<AppointmentUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<AppointmentScalarWhereInput>
  upsert?: Enumerable<AppointmentUpsertWithWhereUniqueWithoutWorkspaceInput>
  connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceUpdateWithoutNotificationDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  users?: UserUpdateManyWithoutWorkspacesInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpsertWithoutNotificationInput = {
  update: WorkspaceUpdateWithoutNotificationDataInput
  create: WorkspaceCreateWithoutNotificationInput
}

export type WorkspaceUpdateOneRequiredWithoutNotificationInput = {
  create?: WorkspaceCreateWithoutNotificationInput
  connect?: WorkspaceWhereUniqueInput
  update?: WorkspaceUpdateWithoutNotificationDataInput
  upsert?: WorkspaceUpsertWithoutNotificationInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutNotificationInput
}

export type NotificationUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  workspace?: WorkspaceUpdateOneRequiredWithoutNotificationInput | null
}

export type NotificationUpsertWithoutNodeInput = {
  update: NotificationUpdateWithoutNodeDataInput
  create: NotificationCreateWithoutNodeInput
}

export type NotificationUpdateOneWithoutNodeInput = {
  create?: NotificationCreateWithoutNodeInput
  connect?: NotificationWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: NotificationUpdateWithoutNodeDataInput
  upsert?: NotificationUpsertWithoutNodeInput
  connectOrCreate?: NotificationCreateOrConnectWithoutNodeInput
}

export type NodeUpdateWithoutEventDataInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  client?: ClientUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutEventInput = {
  update: NodeUpdateWithoutEventDataInput
  create: NodeCreateWithoutEventInput
}

export type NodeUpdateOneRequiredWithoutEventInput = {
  create?: NodeCreateWithoutEventInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutEventDataInput
  upsert?: NodeUpsertWithoutEventInput
  connectOrCreate?: NodeCreateOrConnectWithoutEventInput
}

export type EventUpdateWithoutWorkspaceDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutEventInput | null
}

export type EventUpdateWithWhereUniqueWithoutWorkspaceInput = {
  where: EventWhereUniqueInput
  data: EventUpdateWithoutWorkspaceDataInput
}

export type EventScalarWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  AND?: Enumerable<EventScalarWhereInput>
  OR?: Array<EventScalarWhereInput>
  NOT?: Enumerable<EventScalarWhereInput>
}

export type EventUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
}

export type EventUpdateManyWithWhereNestedInput = {
  where: EventScalarWhereInput
  data: EventUpdateManyDataInput
}

export type EventUpsertWithWhereUniqueWithoutWorkspaceInput = {
  where: EventWhereUniqueInput
  update: EventUpdateWithoutWorkspaceDataInput
  create: EventCreateWithoutWorkspaceInput
}

export type EventUpdateManyWithoutWorkspaceInput = {
  create?: Enumerable<EventCreateWithoutWorkspaceInput>
  connect?: Enumerable<EventWhereUniqueInput>
  set?: Enumerable<EventWhereUniqueInput>
  disconnect?: Enumerable<EventWhereUniqueInput>
  delete?: Enumerable<EventWhereUniqueInput>
  update?: Enumerable<EventUpdateWithWhereUniqueWithoutWorkspaceInput>
  updateMany?: Enumerable<EventUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<EventScalarWhereInput>
  upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutWorkspaceInput>
  connectOrCreate?: Enumerable<EventCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceUpdateWithoutAppointmentDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  users?: UserUpdateManyWithoutWorkspacesInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpsertWithoutAppointmentInput = {
  update: WorkspaceUpdateWithoutAppointmentDataInput
  create: WorkspaceCreateWithoutAppointmentInput
}

export type WorkspaceUpdateOneRequiredWithoutAppointmentInput = {
  create?: WorkspaceCreateWithoutAppointmentInput
  connect?: WorkspaceWhereUniqueInput
  update?: WorkspaceUpdateWithoutAppointmentDataInput
  upsert?: WorkspaceUpsertWithoutAppointmentInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutAppointmentInput
}

export type AppointmentUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  workspace?: WorkspaceUpdateOneRequiredWithoutAppointmentInput | null
  owner?: UserUpdateOneRequiredWithoutAppointmentsInput | null
}

export type AppointmentUpsertWithoutNodeInput = {
  update: AppointmentUpdateWithoutNodeDataInput
  create: AppointmentCreateWithoutNodeInput
}

export type AppointmentUpdateOneWithoutNodeInput = {
  create?: AppointmentCreateWithoutNodeInput
  connect?: AppointmentWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: AppointmentUpdateWithoutNodeDataInput
  upsert?: AppointmentUpsertWithoutNodeInput
  connectOrCreate?: AppointmentCreateOrConnectWithoutNodeInput
}

export type NodeUpdateWithoutReviewDataInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  client?: ClientUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutReviewInput = {
  update: NodeUpdateWithoutReviewDataInput
  create: NodeCreateWithoutReviewInput
}

export type NodeUpdateOneRequiredWithoutReviewInput = {
  create?: NodeCreateWithoutReviewInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutReviewDataInput
  upsert?: NodeUpsertWithoutReviewInput
  connectOrCreate?: NodeCreateOrConnectWithoutReviewInput
}

export type ReviewUpdateWithoutWorkspaceDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string | null
  score?: number | null
  node?: NodeUpdateOneRequiredWithoutReviewInput | null
  author?: UserUpdateOneRequiredWithoutReviewsInput | null
  application?: ApplicationUpdateOneRequiredWithoutReviewsInput | null
  stage?: StageUpdateOneWithoutReviewsInput | null
}

export type ReviewUpdateWithWhereUniqueWithoutWorkspaceInput = {
  where: ReviewWhereUniqueInput
  data: ReviewUpdateWithoutWorkspaceDataInput
}

export type ReviewUpsertWithWhereUniqueWithoutWorkspaceInput = {
  where: ReviewWhereUniqueInput
  update: ReviewUpdateWithoutWorkspaceDataInput
  create: ReviewCreateWithoutWorkspaceInput
}

export type ReviewUpdateManyWithoutWorkspaceInput = {
  create?: Enumerable<ReviewCreateWithoutWorkspaceInput>
  connect?: Enumerable<ReviewWhereUniqueInput>
  set?: Enumerable<ReviewWhereUniqueInput>
  disconnect?: Enumerable<ReviewWhereUniqueInput>
  delete?: Enumerable<ReviewWhereUniqueInput>
  update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutWorkspaceInput>
  updateMany?: Enumerable<ReviewUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<ReviewScalarWhereInput>
  upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutWorkspaceInput>
  connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceUpdateWithoutEventDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  users?: UserUpdateManyWithoutWorkspacesInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpsertWithoutEventInput = {
  update: WorkspaceUpdateWithoutEventDataInput
  create: WorkspaceCreateWithoutEventInput
}

export type WorkspaceUpdateOneRequiredWithoutEventInput = {
  create?: WorkspaceCreateWithoutEventInput
  connect?: WorkspaceWhereUniqueInput
  update?: WorkspaceUpdateWithoutEventDataInput
  upsert?: WorkspaceUpsertWithoutEventInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutEventInput
}

export type EventUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  workspace?: WorkspaceUpdateOneRequiredWithoutEventInput | null
}

export type EventUpsertWithoutNodeInput = {
  update: EventUpdateWithoutNodeDataInput
  create: EventCreateWithoutNodeInput
}

export type EventUpdateOneWithoutNodeInput = {
  create?: EventCreateWithoutNodeInput
  connect?: EventWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: EventUpdateWithoutNodeDataInput
  upsert?: EventUpsertWithoutNodeInput
  connectOrCreate?: EventCreateOrConnectWithoutNodeInput
}

export type NodeUpdateWithoutLocationDataInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  client?: ClientUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutLocationInput = {
  update: NodeUpdateWithoutLocationDataInput
  create: NodeCreateWithoutLocationInput
}

export type NodeUpdateOneRequiredWithoutLocationInput = {
  create?: NodeCreateWithoutLocationInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutLocationDataInput
  upsert?: NodeUpsertWithoutLocationInput
  connectOrCreate?: NodeCreateOrConnectWithoutLocationInput
}

export type ApplicationUpdateWithoutJobDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutApplicationInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutApplicationsInput | null
  candidate?: CandidateUpdateOneRequiredWithoutApplicationsInput | null
  source?: SourceUpdateOneRequiredWithoutApplicationsInput | null
  stage?: StageUpdateOneRequiredWithoutApplicationsInput | null
  reviews?: ReviewUpdateManyWithoutApplicationInput | null
}

export type ApplicationUpdateWithWhereUniqueWithoutJobInput = {
  where: ApplicationWhereUniqueInput
  data: ApplicationUpdateWithoutJobDataInput
}

export type ApplicationUpsertWithWhereUniqueWithoutJobInput = {
  where: ApplicationWhereUniqueInput
  update: ApplicationUpdateWithoutJobDataInput
  create: ApplicationCreateWithoutJobInput
}

export type ApplicationUpdateManyWithoutJobInput = {
  create?: Enumerable<ApplicationCreateWithoutJobInput>
  connect?: Enumerable<ApplicationWhereUniqueInput>
  set?: Enumerable<ApplicationWhereUniqueInput>
  disconnect?: Enumerable<ApplicationWhereUniqueInput>
  delete?: Enumerable<ApplicationWhereUniqueInput>
  update?: Enumerable<ApplicationUpdateWithWhereUniqueWithoutJobInput>
  updateMany?: Enumerable<ApplicationUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<ApplicationScalarWhereInput>
  upsert?: Enumerable<ApplicationUpsertWithWhereUniqueWithoutJobInput>
  connectOrCreate?: Enumerable<ApplicationCreateOrConnectWithoutJobInput>
}

export type JobUpdateWithoutLocationsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  status?: JobStatus
  node?: NodeUpdateOneRequiredWithoutJobInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutJobInput | null
  client?: ClientUpdateOneRequiredWithoutJobsInput | null
  applications?: ApplicationUpdateManyWithoutJobInput | null
}

export type JobUpdateWithWhereUniqueWithoutLocationsInput = {
  where: JobWhereUniqueInput
  data: JobUpdateWithoutLocationsDataInput
}

export type JobScalarWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  name?: string | StringFilter
  description?: string | NullableStringFilter | null
  status?: JobStatus | JobStatusFilter
  clientId?: string | StringFilter
  applications?: ApplicationFilter | null
  locations?: LocationFilter | null
  AND?: Enumerable<JobScalarWhereInput>
  OR?: Array<JobScalarWhereInput>
  NOT?: Enumerable<JobScalarWhereInput>
}

export type JobUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  status?: JobStatus
}

export type JobUpdateManyWithWhereNestedInput = {
  where: JobScalarWhereInput
  data: JobUpdateManyDataInput
}

export type JobUpsertWithWhereUniqueWithoutLocationsInput = {
  where: JobWhereUniqueInput
  update: JobUpdateWithoutLocationsDataInput
  create: JobCreateWithoutLocationsInput
}

export type JobUpdateManyWithoutLocationsInput = {
  create?: Enumerable<JobCreateWithoutLocationsInput>
  connect?: Enumerable<JobWhereUniqueInput>
  set?: Enumerable<JobWhereUniqueInput>
  disconnect?: Enumerable<JobWhereUniqueInput>
  delete?: Enumerable<JobWhereUniqueInput>
  update?: Enumerable<JobUpdateWithWhereUniqueWithoutLocationsInput>
  updateMany?: Enumerable<JobUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<JobScalarWhereInput>
  upsert?: Enumerable<JobUpsertWithWhereUniqueWithoutLocationsInput>
  connectOrCreate?: Enumerable<JobCreateOrConnectWithoutLocationInput>
}

export type LocationUpdateWithoutWorkspaceDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string | null
  description?: string | null
  country?: string
  city?: string | null
  node?: NodeUpdateOneRequiredWithoutLocationInput | null
  jobs?: JobUpdateManyWithoutLocationsInput | null
}

export type LocationUpdateWithWhereUniqueWithoutWorkspaceInput = {
  where: LocationWhereUniqueInput
  data: LocationUpdateWithoutWorkspaceDataInput
}

export type LocationUpsertWithWhereUniqueWithoutWorkspaceInput = {
  where: LocationWhereUniqueInput
  update: LocationUpdateWithoutWorkspaceDataInput
  create: LocationCreateWithoutWorkspaceInput
}

export type LocationUpdateManyWithoutWorkspaceInput = {
  create?: Enumerable<LocationCreateWithoutWorkspaceInput>
  connect?: Enumerable<LocationWhereUniqueInput>
  set?: Enumerable<LocationWhereUniqueInput>
  disconnect?: Enumerable<LocationWhereUniqueInput>
  delete?: Enumerable<LocationWhereUniqueInput>
  update?: Enumerable<LocationUpdateWithWhereUniqueWithoutWorkspaceInput>
  updateMany?: Enumerable<LocationUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<LocationScalarWhereInput>
  upsert?: Enumerable<LocationUpsertWithWhereUniqueWithoutWorkspaceInput>
  connectOrCreate?: Enumerable<LocationCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceUpdateWithoutReviewsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  users?: UserUpdateManyWithoutWorkspacesInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpsertWithoutReviewsInput = {
  update: WorkspaceUpdateWithoutReviewsDataInput
  create: WorkspaceCreateWithoutReviewsInput
}

export type WorkspaceUpdateOneRequiredWithoutReviewsInput = {
  create?: WorkspaceCreateWithoutReviewsInput
  connect?: WorkspaceWhereUniqueInput
  update?: WorkspaceUpdateWithoutReviewsDataInput
  upsert?: WorkspaceUpsertWithoutReviewsInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutReviewInput
}

export type ReviewUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string | null
  score?: number | null
  workspace?: WorkspaceUpdateOneRequiredWithoutReviewsInput | null
  author?: UserUpdateOneRequiredWithoutReviewsInput | null
  application?: ApplicationUpdateOneRequiredWithoutReviewsInput | null
  stage?: StageUpdateOneWithoutReviewsInput | null
}

export type ReviewUpsertWithoutNodeInput = {
  update: ReviewUpdateWithoutNodeDataInput
  create: ReviewCreateWithoutNodeInput
}

export type ReviewUpdateOneWithoutNodeInput = {
  create?: ReviewCreateWithoutNodeInput
  connect?: ReviewWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: ReviewUpdateWithoutNodeDataInput
  upsert?: ReviewUpsertWithoutNodeInput
  connectOrCreate?: ReviewCreateOrConnectWithoutNodeInput
}

export type NodeUpdateWithoutStageDataInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  client?: ClientUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutStageInput = {
  update: NodeUpdateWithoutStageDataInput
  create: NodeCreateWithoutStageInput
}

export type NodeUpdateOneRequiredWithoutStageInput = {
  create?: NodeCreateWithoutStageInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutStageDataInput
  upsert?: NodeUpsertWithoutStageInput
  connectOrCreate?: NodeCreateOrConnectWithoutStageInput
}

export type StageUpdateWithoutWorkspaceDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutStageInput | null
  pipeline?: PipelineUpdateOneRequiredWithoutStagesInput | null
  applications?: ApplicationUpdateManyWithoutStageInput | null
  reviews?: ReviewUpdateManyWithoutStageInput | null
}

export type StageUpdateWithWhereUniqueWithoutWorkspaceInput = {
  where: StageWhereUniqueInput
  data: StageUpdateWithoutWorkspaceDataInput
}

export type StageScalarWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  pipelineId?: string | StringFilter
  applications?: ApplicationFilter | null
  reviews?: ReviewFilter | null
  AND?: Enumerable<StageScalarWhereInput>
  OR?: Array<StageScalarWhereInput>
  NOT?: Enumerable<StageScalarWhereInput>
}

export type StageUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
}

export type StageUpdateManyWithWhereNestedInput = {
  where: StageScalarWhereInput
  data: StageUpdateManyDataInput
}

export type StageUpsertWithWhereUniqueWithoutWorkspaceInput = {
  where: StageWhereUniqueInput
  update: StageUpdateWithoutWorkspaceDataInput
  create: StageCreateWithoutWorkspaceInput
}

export type StageUpdateManyWithoutWorkspaceInput = {
  create?: Enumerable<StageCreateWithoutWorkspaceInput>
  connect?: Enumerable<StageWhereUniqueInput>
  set?: Enumerable<StageWhereUniqueInput>
  disconnect?: Enumerable<StageWhereUniqueInput>
  delete?: Enumerable<StageWhereUniqueInput>
  update?: Enumerable<StageUpdateWithWhereUniqueWithoutWorkspaceInput>
  updateMany?: Enumerable<StageUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<StageScalarWhereInput>
  upsert?: Enumerable<StageUpsertWithWhereUniqueWithoutWorkspaceInput>
  connectOrCreate?: Enumerable<StageCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceUpdateWithoutLocationsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  users?: UserUpdateManyWithoutWorkspacesInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpsertWithoutLocationsInput = {
  update: WorkspaceUpdateWithoutLocationsDataInput
  create: WorkspaceCreateWithoutLocationsInput
}

export type WorkspaceUpdateOneRequiredWithoutLocationsInput = {
  create?: WorkspaceCreateWithoutLocationsInput
  connect?: WorkspaceWhereUniqueInput
  update?: WorkspaceUpdateWithoutLocationsDataInput
  upsert?: WorkspaceUpsertWithoutLocationsInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutLocationInput
}

export type LocationUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string | null
  description?: string | null
  country?: string
  city?: string | null
  workspace?: WorkspaceUpdateOneRequiredWithoutLocationsInput | null
  jobs?: JobUpdateManyWithoutLocationsInput | null
}

export type LocationUpsertWithoutNodeInput = {
  update: LocationUpdateWithoutNodeDataInput
  create: LocationCreateWithoutNodeInput
}

export type LocationUpdateOneWithoutNodeInput = {
  create?: LocationCreateWithoutNodeInput
  connect?: LocationWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: LocationUpdateWithoutNodeDataInput
  upsert?: LocationUpsertWithoutNodeInput
  connectOrCreate?: LocationCreateOrConnectWithoutNodeInput
}

export type NodeUpdateWithoutPipelineDataInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  client?: ClientUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutPipelineInput = {
  update: NodeUpdateWithoutPipelineDataInput
  create: NodeCreateWithoutPipelineInput
}

export type NodeUpdateOneRequiredWithoutPipelineInput = {
  create?: NodeCreateWithoutPipelineInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutPipelineDataInput
  upsert?: NodeUpsertWithoutPipelineInput
  connectOrCreate?: NodeCreateOrConnectWithoutPipelineInput
}

export type StageUpdateWithoutPipelineDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutStageInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutStagesInput | null
  applications?: ApplicationUpdateManyWithoutStageInput | null
  reviews?: ReviewUpdateManyWithoutStageInput | null
}

export type StageUpdateWithWhereUniqueWithoutPipelineInput = {
  where: StageWhereUniqueInput
  data: StageUpdateWithoutPipelineDataInput
}

export type StageUpsertWithWhereUniqueWithoutPipelineInput = {
  where: StageWhereUniqueInput
  update: StageUpdateWithoutPipelineDataInput
  create: StageCreateWithoutPipelineInput
}

export type StageUpdateManyWithoutPipelineInput = {
  create?: Enumerable<StageCreateWithoutPipelineInput>
  connect?: Enumerable<StageWhereUniqueInput>
  set?: Enumerable<StageWhereUniqueInput>
  disconnect?: Enumerable<StageWhereUniqueInput>
  delete?: Enumerable<StageWhereUniqueInput>
  update?: Enumerable<StageUpdateWithWhereUniqueWithoutPipelineInput>
  updateMany?: Enumerable<StageUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<StageScalarWhereInput>
  upsert?: Enumerable<StageUpsertWithWhereUniqueWithoutPipelineInput>
  connectOrCreate?: Enumerable<StageCreateOrConnectWithoutPipelineInput>
}

export type PipelineUpdateWithoutWorkspaceDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutPipelineInput | null
  stages?: StageUpdateManyWithoutPipelineInput | null
}

export type PipelineUpdateWithWhereUniqueWithoutWorkspaceInput = {
  where: PipelineWhereUniqueInput
  data: PipelineUpdateWithoutWorkspaceDataInput
}

export type PipelineScalarWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  stages?: StageFilter | null
  AND?: Enumerable<PipelineScalarWhereInput>
  OR?: Array<PipelineScalarWhereInput>
  NOT?: Enumerable<PipelineScalarWhereInput>
}

export type PipelineUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
}

export type PipelineUpdateManyWithWhereNestedInput = {
  where: PipelineScalarWhereInput
  data: PipelineUpdateManyDataInput
}

export type PipelineUpsertWithWhereUniqueWithoutWorkspaceInput = {
  where: PipelineWhereUniqueInput
  update: PipelineUpdateWithoutWorkspaceDataInput
  create: PipelineCreateWithoutWorkspaceInput
}

export type PipelineUpdateManyWithoutWorkspaceInput = {
  create?: Enumerable<PipelineCreateWithoutWorkspaceInput>
  connect?: Enumerable<PipelineWhereUniqueInput>
  set?: Enumerable<PipelineWhereUniqueInput>
  disconnect?: Enumerable<PipelineWhereUniqueInput>
  delete?: Enumerable<PipelineWhereUniqueInput>
  update?: Enumerable<PipelineUpdateWithWhereUniqueWithoutWorkspaceInput>
  updateMany?: Enumerable<PipelineUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<PipelineScalarWhereInput>
  upsert?: Enumerable<PipelineUpsertWithWhereUniqueWithoutWorkspaceInput>
  connectOrCreate?: Enumerable<PipelineCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceUpdateWithoutStagesDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  users?: UserUpdateManyWithoutWorkspacesInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpsertWithoutStagesInput = {
  update: WorkspaceUpdateWithoutStagesDataInput
  create: WorkspaceCreateWithoutStagesInput
}

export type WorkspaceUpdateOneRequiredWithoutStagesInput = {
  create?: WorkspaceCreateWithoutStagesInput
  connect?: WorkspaceWhereUniqueInput
  update?: WorkspaceUpdateWithoutStagesDataInput
  upsert?: WorkspaceUpsertWithoutStagesInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutStageInput
}

export type StageUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  workspace?: WorkspaceUpdateOneRequiredWithoutStagesInput | null
  pipeline?: PipelineUpdateOneRequiredWithoutStagesInput | null
  applications?: ApplicationUpdateManyWithoutStageInput | null
  reviews?: ReviewUpdateManyWithoutStageInput | null
}

export type StageUpsertWithoutNodeInput = {
  update: StageUpdateWithoutNodeDataInput
  create: StageCreateWithoutNodeInput
}

export type StageUpdateOneWithoutNodeInput = {
  create?: StageCreateWithoutNodeInput
  connect?: StageWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: StageUpdateWithoutNodeDataInput
  upsert?: StageUpsertWithoutNodeInput
  connectOrCreate?: StageCreateOrConnectWithoutNodeInput
}

export type NodeUpdateWithoutSourceDataInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  client?: ClientUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutSourceInput = {
  update: NodeUpdateWithoutSourceDataInput
  create: NodeCreateWithoutSourceInput
}

export type NodeUpdateOneRequiredWithoutSourceInput = {
  create?: NodeCreateWithoutSourceInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutSourceDataInput
  upsert?: NodeUpsertWithoutSourceInput
  connectOrCreate?: NodeCreateOrConnectWithoutSourceInput
}

export type ApplicationUpdateWithoutSourceDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutApplicationInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutApplicationsInput | null
  job?: JobUpdateOneRequiredWithoutApplicationsInput | null
  candidate?: CandidateUpdateOneRequiredWithoutApplicationsInput | null
  stage?: StageUpdateOneRequiredWithoutApplicationsInput | null
  reviews?: ReviewUpdateManyWithoutApplicationInput | null
}

export type ApplicationUpdateWithWhereUniqueWithoutSourceInput = {
  where: ApplicationWhereUniqueInput
  data: ApplicationUpdateWithoutSourceDataInput
}

export type ApplicationUpsertWithWhereUniqueWithoutSourceInput = {
  where: ApplicationWhereUniqueInput
  update: ApplicationUpdateWithoutSourceDataInput
  create: ApplicationCreateWithoutSourceInput
}

export type ApplicationUpdateManyWithoutSourceInput = {
  create?: Enumerable<ApplicationCreateWithoutSourceInput>
  connect?: Enumerable<ApplicationWhereUniqueInput>
  set?: Enumerable<ApplicationWhereUniqueInput>
  disconnect?: Enumerable<ApplicationWhereUniqueInput>
  delete?: Enumerable<ApplicationWhereUniqueInput>
  update?: Enumerable<ApplicationUpdateWithWhereUniqueWithoutSourceInput>
  updateMany?: Enumerable<ApplicationUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<ApplicationScalarWhereInput>
  upsert?: Enumerable<ApplicationUpsertWithWhereUniqueWithoutSourceInput>
  connectOrCreate?: Enumerable<ApplicationCreateOrConnectWithoutSourceInput>
}

export type SourceUpdateWithoutWorkspaceDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  node?: NodeUpdateOneRequiredWithoutSourceInput | null
  applications?: ApplicationUpdateManyWithoutSourceInput | null
}

export type SourceUpdateWithWhereUniqueWithoutWorkspaceInput = {
  where: SourceWhereUniqueInput
  data: SourceUpdateWithoutWorkspaceDataInput
}

export type SourceScalarWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  name?: string | StringFilter
  description?: string | NullableStringFilter | null
  applications?: ApplicationFilter | null
  AND?: Enumerable<SourceScalarWhereInput>
  OR?: Array<SourceScalarWhereInput>
  NOT?: Enumerable<SourceScalarWhereInput>
}

export type SourceUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
}

export type SourceUpdateManyWithWhereNestedInput = {
  where: SourceScalarWhereInput
  data: SourceUpdateManyDataInput
}

export type SourceUpsertWithWhereUniqueWithoutWorkspaceInput = {
  where: SourceWhereUniqueInput
  update: SourceUpdateWithoutWorkspaceDataInput
  create: SourceCreateWithoutWorkspaceInput
}

export type SourceUpdateManyWithoutWorkspaceInput = {
  create?: Enumerable<SourceCreateWithoutWorkspaceInput>
  connect?: Enumerable<SourceWhereUniqueInput>
  set?: Enumerable<SourceWhereUniqueInput>
  disconnect?: Enumerable<SourceWhereUniqueInput>
  delete?: Enumerable<SourceWhereUniqueInput>
  update?: Enumerable<SourceUpdateWithWhereUniqueWithoutWorkspaceInput>
  updateMany?: Enumerable<SourceUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<SourceScalarWhereInput>
  upsert?: Enumerable<SourceUpsertWithWhereUniqueWithoutWorkspaceInput>
  connectOrCreate?: Enumerable<SourceCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceUpdateWithoutPipelinesDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  users?: UserUpdateManyWithoutWorkspacesInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpsertWithoutPipelinesInput = {
  update: WorkspaceUpdateWithoutPipelinesDataInput
  create: WorkspaceCreateWithoutPipelinesInput
}

export type WorkspaceUpdateOneRequiredWithoutPipelinesInput = {
  create?: WorkspaceCreateWithoutPipelinesInput
  connect?: WorkspaceWhereUniqueInput
  update?: WorkspaceUpdateWithoutPipelinesDataInput
  upsert?: WorkspaceUpsertWithoutPipelinesInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutPipelineInput
}

export type PipelineUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  workspace?: WorkspaceUpdateOneRequiredWithoutPipelinesInput | null
  stages?: StageUpdateManyWithoutPipelineInput | null
}

export type PipelineUpsertWithoutNodeInput = {
  update: PipelineUpdateWithoutNodeDataInput
  create: PipelineCreateWithoutNodeInput
}

export type PipelineUpdateOneWithoutNodeInput = {
  create?: PipelineCreateWithoutNodeInput
  connect?: PipelineWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: PipelineUpdateWithoutNodeDataInput
  upsert?: PipelineUpsertWithoutNodeInput
  connectOrCreate?: PipelineCreateOrConnectWithoutNodeInput
}

export type NodeUpdateWithoutCommentDataInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  client?: ClientUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutCommentInput = {
  update: NodeUpdateWithoutCommentDataInput
  create: NodeCreateWithoutCommentInput
}

export type NodeUpdateOneRequiredWithoutCommentInput = {
  create?: NodeCreateWithoutCommentInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutCommentDataInput
  upsert?: NodeUpsertWithoutCommentInput
  connectOrCreate?: NodeCreateOrConnectWithoutCommentInput
}

export type CommentUpdateWithoutWorkspaceDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string
  node?: NodeUpdateOneRequiredWithoutCommentInput | null
  author?: UserUpdateOneRequiredWithoutCommentsInput | null
  parent?: CommentUpdateOneWithoutRepliesInput | null
  replies?: CommentUpdateManyWithoutParentInput | null
}

export type CommentUpdateWithWhereUniqueWithoutWorkspaceInput = {
  where: CommentWhereUniqueInput
  data: CommentUpdateWithoutWorkspaceDataInput
}

export type CommentUpsertWithWhereUniqueWithoutWorkspaceInput = {
  where: CommentWhereUniqueInput
  update: CommentUpdateWithoutWorkspaceDataInput
  create: CommentCreateWithoutWorkspaceInput
}

export type CommentUpdateManyWithoutWorkspaceInput = {
  create?: Enumerable<CommentCreateWithoutWorkspaceInput>
  connect?: Enumerable<CommentWhereUniqueInput>
  set?: Enumerable<CommentWhereUniqueInput>
  disconnect?: Enumerable<CommentWhereUniqueInput>
  delete?: Enumerable<CommentWhereUniqueInput>
  update?: Enumerable<CommentUpdateWithWhereUniqueWithoutWorkspaceInput>
  updateMany?: Enumerable<CommentUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<CommentScalarWhereInput>
  upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutWorkspaceInput>
  connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceUpdateWithoutSourcesDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  users?: UserUpdateManyWithoutWorkspacesInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpsertWithoutSourcesInput = {
  update: WorkspaceUpdateWithoutSourcesDataInput
  create: WorkspaceCreateWithoutSourcesInput
}

export type WorkspaceUpdateOneRequiredWithoutSourcesInput = {
  create?: WorkspaceCreateWithoutSourcesInput
  connect?: WorkspaceWhereUniqueInput
  update?: WorkspaceUpdateWithoutSourcesDataInput
  upsert?: WorkspaceUpsertWithoutSourcesInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutSourceInput
}

export type SourceUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  workspace?: WorkspaceUpdateOneRequiredWithoutSourcesInput | null
  applications?: ApplicationUpdateManyWithoutSourceInput | null
}

export type SourceUpsertWithoutNodeInput = {
  update: SourceUpdateWithoutNodeDataInput
  create: SourceCreateWithoutNodeInput
}

export type SourceUpdateOneWithoutNodeInput = {
  create?: SourceCreateWithoutNodeInput
  connect?: SourceWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: SourceUpdateWithoutNodeDataInput
  upsert?: SourceUpsertWithoutNodeInput
  connectOrCreate?: SourceCreateOrConnectWithoutNodeInput
}

export type NodeUpdateWithoutTagDataInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  client?: ClientUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutTagInput = {
  update: NodeUpdateWithoutTagDataInput
  create: NodeCreateWithoutTagInput
}

export type NodeUpdateOneRequiredWithoutTagInput = {
  create?: NodeCreateWithoutTagInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutTagDataInput
  upsert?: NodeUpsertWithoutTagInput
  connectOrCreate?: NodeCreateOrConnectWithoutTagInput
}

export type CandidateUpdateWithoutTagsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  firstName?: string | null
  lastName?: string | null
  headline?: string | null
  emails?: CandidateUpdateemailsInput
  links?: CandidateUpdatelinksInput
  phones?: CandidateUpdatephonesInput
  node?: NodeUpdateOneRequiredWithoutCandidateInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutCandidatesInput | null
  applications?: ApplicationUpdateManyWithoutCandidateInput | null
  fields?: FieldValueUpdateManyWithoutCandidateInput | null
}

export type CandidateUpdateWithWhereUniqueWithoutTagsInput = {
  where: CandidateWhereUniqueInput
  data: CandidateUpdateWithoutTagsDataInput
}

export type CandidateScalarWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  firstName?: string | NullableStringFilter | null
  lastName?: string | NullableStringFilter | null
  headline?: string | NullableStringFilter | null
  tags?: TagFilter | null
  applications?: ApplicationFilter | null
  fields?: FieldValueFilter | null
  AND?: Enumerable<CandidateScalarWhereInput>
  OR?: Array<CandidateScalarWhereInput>
  NOT?: Enumerable<CandidateScalarWhereInput>
}

export type CandidateUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  firstName?: string | null
  lastName?: string | null
  headline?: string | null
  emails?: CandidateUpdateemailsInput
  links?: CandidateUpdatelinksInput
  phones?: CandidateUpdatephonesInput
}

export type CandidateUpdateManyWithWhereNestedInput = {
  where: CandidateScalarWhereInput
  data: CandidateUpdateManyDataInput
}

export type CandidateUpsertWithWhereUniqueWithoutTagsInput = {
  where: CandidateWhereUniqueInput
  update: CandidateUpdateWithoutTagsDataInput
  create: CandidateCreateWithoutTagsInput
}

export type CandidateUpdateManyWithoutTagsInput = {
  create?: Enumerable<CandidateCreateWithoutTagsInput>
  connect?: Enumerable<CandidateWhereUniqueInput>
  set?: Enumerable<CandidateWhereUniqueInput>
  disconnect?: Enumerable<CandidateWhereUniqueInput>
  delete?: Enumerable<CandidateWhereUniqueInput>
  update?: Enumerable<CandidateUpdateWithWhereUniqueWithoutTagsInput>
  updateMany?: Enumerable<CandidateUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<CandidateScalarWhereInput>
  upsert?: Enumerable<CandidateUpsertWithWhereUniqueWithoutTagsInput>
  connectOrCreate?: Enumerable<CandidateCreateOrConnectWithoutTagInput>
}

export type TagUpdateWithoutWorkspaceDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  types?: TagUpdatetypesInput
  node?: NodeUpdateOneRequiredWithoutTagInput | null
  candidates?: CandidateUpdateManyWithoutTagsInput | null
}

export type TagUpdateWithWhereUniqueWithoutWorkspaceInput = {
  where: TagWhereUniqueInput
  data: TagUpdateWithoutWorkspaceDataInput
}

export type TagUpsertWithWhereUniqueWithoutWorkspaceInput = {
  where: TagWhereUniqueInput
  update: TagUpdateWithoutWorkspaceDataInput
  create: TagCreateWithoutWorkspaceInput
}

export type TagUpdateManyWithoutWorkspaceInput = {
  create?: Enumerable<TagCreateWithoutWorkspaceInput>
  connect?: Enumerable<TagWhereUniqueInput>
  set?: Enumerable<TagWhereUniqueInput>
  disconnect?: Enumerable<TagWhereUniqueInput>
  delete?: Enumerable<TagWhereUniqueInput>
  update?: Enumerable<TagUpdateWithWhereUniqueWithoutWorkspaceInput>
  updateMany?: Enumerable<TagUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<TagScalarWhereInput>
  upsert?: Enumerable<TagUpsertWithWhereUniqueWithoutWorkspaceInput>
  connectOrCreate?: Enumerable<TagCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceUpdateWithoutCommentsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  users?: UserUpdateManyWithoutWorkspacesInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpsertWithoutCommentsInput = {
  update: WorkspaceUpdateWithoutCommentsDataInput
  create: WorkspaceCreateWithoutCommentsInput
}

export type WorkspaceUpdateOneRequiredWithoutCommentsInput = {
  create?: WorkspaceCreateWithoutCommentsInput
  connect?: WorkspaceWhereUniqueInput
  update?: WorkspaceUpdateWithoutCommentsDataInput
  upsert?: WorkspaceUpsertWithoutCommentsInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutCommentInput
}

export type CommentUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string
  workspace?: WorkspaceUpdateOneRequiredWithoutCommentsInput | null
  author?: UserUpdateOneRequiredWithoutCommentsInput | null
  parent?: CommentUpdateOneWithoutRepliesInput | null
  replies?: CommentUpdateManyWithoutParentInput | null
}

export type CommentUpsertWithoutNodeInput = {
  update: CommentUpdateWithoutNodeDataInput
  create: CommentCreateWithoutNodeInput
}

export type CommentUpdateOneWithoutNodeInput = {
  create?: CommentCreateWithoutNodeInput
  connect?: CommentWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: CommentUpdateWithoutNodeDataInput
  upsert?: CommentUpsertWithoutNodeInput
  connectOrCreate?: CommentCreateOrConnectWithoutNodeInput
}

export type NodeUpdateWithoutJobDataInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  client?: ClientUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutJobInput = {
  update: NodeUpdateWithoutJobDataInput
  create: NodeCreateWithoutJobInput
}

export type NodeUpdateOneRequiredWithoutJobInput = {
  create?: NodeCreateWithoutJobInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutJobDataInput
  upsert?: NodeUpsertWithoutJobInput
  connectOrCreate?: NodeCreateOrConnectWithoutJobInput
}

export type JobUpdateWithoutWorkspaceDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  status?: JobStatus
  node?: NodeUpdateOneRequiredWithoutJobInput | null
  client?: ClientUpdateOneRequiredWithoutJobsInput | null
  applications?: ApplicationUpdateManyWithoutJobInput | null
  locations?: LocationUpdateManyWithoutJobsInput | null
}

export type JobUpdateWithWhereUniqueWithoutWorkspaceInput = {
  where: JobWhereUniqueInput
  data: JobUpdateWithoutWorkspaceDataInput
}

export type JobUpsertWithWhereUniqueWithoutWorkspaceInput = {
  where: JobWhereUniqueInput
  update: JobUpdateWithoutWorkspaceDataInput
  create: JobCreateWithoutWorkspaceInput
}

export type JobUpdateManyWithoutWorkspaceInput = {
  create?: Enumerable<JobCreateWithoutWorkspaceInput>
  connect?: Enumerable<JobWhereUniqueInput>
  set?: Enumerable<JobWhereUniqueInput>
  disconnect?: Enumerable<JobWhereUniqueInput>
  delete?: Enumerable<JobWhereUniqueInput>
  update?: Enumerable<JobUpdateWithWhereUniqueWithoutWorkspaceInput>
  updateMany?: Enumerable<JobUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<JobScalarWhereInput>
  upsert?: Enumerable<JobUpsertWithWhereUniqueWithoutWorkspaceInput>
  connectOrCreate?: Enumerable<JobCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceUpdateWithoutTagsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  users?: UserUpdateManyWithoutWorkspacesInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpsertWithoutTagsInput = {
  update: WorkspaceUpdateWithoutTagsDataInput
  create: WorkspaceCreateWithoutTagsInput
}

export type WorkspaceUpdateOneRequiredWithoutTagsInput = {
  create?: WorkspaceCreateWithoutTagsInput
  connect?: WorkspaceWhereUniqueInput
  update?: WorkspaceUpdateWithoutTagsDataInput
  upsert?: WorkspaceUpsertWithoutTagsInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutTagInput
}

export type TagUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  types?: TagUpdatetypesInput
  workspace?: WorkspaceUpdateOneRequiredWithoutTagsInput | null
  candidates?: CandidateUpdateManyWithoutTagsInput | null
}

export type TagUpsertWithoutNodeInput = {
  update: TagUpdateWithoutNodeDataInput
  create: TagCreateWithoutNodeInput
}

export type TagUpdateOneWithoutNodeInput = {
  create?: TagCreateWithoutNodeInput
  connect?: TagWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: TagUpdateWithoutNodeDataInput
  upsert?: TagUpsertWithoutNodeInput
  connectOrCreate?: TagCreateOrConnectWithoutNodeInput
}

export type NodeUpdateWithoutApplicationDataInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  client?: ClientUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutApplicationInput = {
  update: NodeUpdateWithoutApplicationDataInput
  create: NodeCreateWithoutApplicationInput
}

export type NodeUpdateOneRequiredWithoutApplicationInput = {
  create?: NodeCreateWithoutApplicationInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutApplicationDataInput
  upsert?: NodeUpsertWithoutApplicationInput
  connectOrCreate?: NodeCreateOrConnectWithoutApplicationInput
}

export type ApplicationUpdateWithoutWorkspaceDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutApplicationInput | null
  job?: JobUpdateOneRequiredWithoutApplicationsInput | null
  candidate?: CandidateUpdateOneRequiredWithoutApplicationsInput | null
  source?: SourceUpdateOneRequiredWithoutApplicationsInput | null
  stage?: StageUpdateOneRequiredWithoutApplicationsInput | null
  reviews?: ReviewUpdateManyWithoutApplicationInput | null
}

export type ApplicationUpdateWithWhereUniqueWithoutWorkspaceInput = {
  where: ApplicationWhereUniqueInput
  data: ApplicationUpdateWithoutWorkspaceDataInput
}

export type ApplicationUpsertWithWhereUniqueWithoutWorkspaceInput = {
  where: ApplicationWhereUniqueInput
  update: ApplicationUpdateWithoutWorkspaceDataInput
  create: ApplicationCreateWithoutWorkspaceInput
}

export type ApplicationUpdateManyWithoutWorkspaceInput = {
  create?: Enumerable<ApplicationCreateWithoutWorkspaceInput>
  connect?: Enumerable<ApplicationWhereUniqueInput>
  set?: Enumerable<ApplicationWhereUniqueInput>
  disconnect?: Enumerable<ApplicationWhereUniqueInput>
  delete?: Enumerable<ApplicationWhereUniqueInput>
  update?: Enumerable<ApplicationUpdateWithWhereUniqueWithoutWorkspaceInput>
  updateMany?: Enumerable<ApplicationUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<ApplicationScalarWhereInput>
  upsert?: Enumerable<ApplicationUpsertWithWhereUniqueWithoutWorkspaceInput>
  connectOrCreate?: Enumerable<ApplicationCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceUpdateWithoutJobDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  users?: UserUpdateManyWithoutWorkspacesInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpsertWithoutJobInput = {
  update: WorkspaceUpdateWithoutJobDataInput
  create: WorkspaceCreateWithoutJobInput
}

export type WorkspaceUpdateOneRequiredWithoutJobInput = {
  create?: WorkspaceCreateWithoutJobInput
  connect?: WorkspaceWhereUniqueInput
  update?: WorkspaceUpdateWithoutJobDataInput
  upsert?: WorkspaceUpsertWithoutJobInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutJobInput
}

export type JobUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  status?: JobStatus
  workspace?: WorkspaceUpdateOneRequiredWithoutJobInput | null
  client?: ClientUpdateOneRequiredWithoutJobsInput | null
  applications?: ApplicationUpdateManyWithoutJobInput | null
  locations?: LocationUpdateManyWithoutJobsInput | null
}

export type JobUpsertWithoutNodeInput = {
  update: JobUpdateWithoutNodeDataInput
  create: JobCreateWithoutNodeInput
}

export type JobUpdateOneWithoutNodeInput = {
  create?: JobCreateWithoutNodeInput
  connect?: JobWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: JobUpdateWithoutNodeDataInput
  upsert?: JobUpsertWithoutNodeInput
  connectOrCreate?: JobCreateOrConnectWithoutNodeInput
}

export type NodeUpdateWithoutCandidateDataInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  client?: ClientUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutCandidateInput = {
  update: NodeUpdateWithoutCandidateDataInput
  create: NodeCreateWithoutCandidateInput
}

export type NodeUpdateOneRequiredWithoutCandidateInput = {
  create?: NodeCreateWithoutCandidateInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutCandidateDataInput
  upsert?: NodeUpsertWithoutCandidateInput
  connectOrCreate?: NodeCreateOrConnectWithoutCandidateInput
}

export type CandidateUpdateWithoutWorkspaceDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  firstName?: string | null
  lastName?: string | null
  headline?: string | null
  emails?: CandidateUpdateemailsInput
  links?: CandidateUpdatelinksInput
  phones?: CandidateUpdatephonesInput
  node?: NodeUpdateOneRequiredWithoutCandidateInput | null
  tags?: TagUpdateManyWithoutCandidatesInput | null
  applications?: ApplicationUpdateManyWithoutCandidateInput | null
  fields?: FieldValueUpdateManyWithoutCandidateInput | null
}

export type CandidateUpdateWithWhereUniqueWithoutWorkspaceInput = {
  where: CandidateWhereUniqueInput
  data: CandidateUpdateWithoutWorkspaceDataInput
}

export type CandidateUpsertWithWhereUniqueWithoutWorkspaceInput = {
  where: CandidateWhereUniqueInput
  update: CandidateUpdateWithoutWorkspaceDataInput
  create: CandidateCreateWithoutWorkspaceInput
}

export type CandidateUpdateManyWithoutWorkspaceInput = {
  create?: Enumerable<CandidateCreateWithoutWorkspaceInput>
  connect?: Enumerable<CandidateWhereUniqueInput>
  set?: Enumerable<CandidateWhereUniqueInput>
  disconnect?: Enumerable<CandidateWhereUniqueInput>
  delete?: Enumerable<CandidateWhereUniqueInput>
  update?: Enumerable<CandidateUpdateWithWhereUniqueWithoutWorkspaceInput>
  updateMany?: Enumerable<CandidateUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<CandidateScalarWhereInput>
  upsert?: Enumerable<CandidateUpsertWithWhereUniqueWithoutWorkspaceInput>
  connectOrCreate?: Enumerable<CandidateCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceUpdateWithoutApplicationsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  users?: UserUpdateManyWithoutWorkspacesInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpsertWithoutApplicationsInput = {
  update: WorkspaceUpdateWithoutApplicationsDataInput
  create: WorkspaceCreateWithoutApplicationsInput
}

export type WorkspaceUpdateOneRequiredWithoutApplicationsInput = {
  create?: WorkspaceCreateWithoutApplicationsInput
  connect?: WorkspaceWhereUniqueInput
  update?: WorkspaceUpdateWithoutApplicationsDataInput
  upsert?: WorkspaceUpsertWithoutApplicationsInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutApplicationInput
}

export type ApplicationUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  workspace?: WorkspaceUpdateOneRequiredWithoutApplicationsInput | null
  job?: JobUpdateOneRequiredWithoutApplicationsInput | null
  candidate?: CandidateUpdateOneRequiredWithoutApplicationsInput | null
  source?: SourceUpdateOneRequiredWithoutApplicationsInput | null
  stage?: StageUpdateOneRequiredWithoutApplicationsInput | null
  reviews?: ReviewUpdateManyWithoutApplicationInput | null
}

export type ApplicationUpsertWithoutNodeInput = {
  update: ApplicationUpdateWithoutNodeDataInput
  create: ApplicationCreateWithoutNodeInput
}

export type ApplicationUpdateOneWithoutNodeInput = {
  create?: ApplicationCreateWithoutNodeInput
  connect?: ApplicationWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: ApplicationUpdateWithoutNodeDataInput
  upsert?: ApplicationUpsertWithoutNodeInput
  connectOrCreate?: ApplicationCreateOrConnectWithoutNodeInput
}

export type NodeUpdateWithoutClientDataInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutClientInput = {
  update: NodeUpdateWithoutClientDataInput
  create: NodeCreateWithoutClientInput
}

export type NodeUpdateOneRequiredWithoutClientInput = {
  create?: NodeCreateWithoutClientInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutClientDataInput
  upsert?: NodeUpsertWithoutClientInput
  connectOrCreate?: NodeCreateOrConnectWithoutClientInput
}

export type JobUpdateWithoutClientDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  status?: JobStatus
  node?: NodeUpdateOneRequiredWithoutJobInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutJobInput | null
  applications?: ApplicationUpdateManyWithoutJobInput | null
  locations?: LocationUpdateManyWithoutJobsInput | null
}

export type JobUpdateWithWhereUniqueWithoutClientInput = {
  where: JobWhereUniqueInput
  data: JobUpdateWithoutClientDataInput
}

export type JobUpsertWithWhereUniqueWithoutClientInput = {
  where: JobWhereUniqueInput
  update: JobUpdateWithoutClientDataInput
  create: JobCreateWithoutClientInput
}

export type JobUpdateManyWithoutClientInput = {
  create?: Enumerable<JobCreateWithoutClientInput>
  connect?: Enumerable<JobWhereUniqueInput>
  set?: Enumerable<JobWhereUniqueInput>
  disconnect?: Enumerable<JobWhereUniqueInput>
  delete?: Enumerable<JobWhereUniqueInput>
  update?: Enumerable<JobUpdateWithWhereUniqueWithoutClientInput>
  updateMany?: Enumerable<JobUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<JobScalarWhereInput>
  upsert?: Enumerable<JobUpsertWithWhereUniqueWithoutClientInput>
  connectOrCreate?: Enumerable<JobCreateOrConnectWithoutClientInput>
}

export type ClientUpdateWithoutWorkspaceDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  node?: NodeUpdateOneRequiredWithoutClientInput | null
  jobs?: JobUpdateManyWithoutClientInput | null
}

export type ClientUpdateWithWhereUniqueWithoutWorkspaceInput = {
  where: ClientWhereUniqueInput
  data: ClientUpdateWithoutWorkspaceDataInput
}

export type ClientScalarWhereInput = {
  id?: string | StringFilter
  wid?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  name?: string | StringFilter
  description?: string | NullableStringFilter | null
  jobs?: JobFilter | null
  AND?: Enumerable<ClientScalarWhereInput>
  OR?: Array<ClientScalarWhereInput>
  NOT?: Enumerable<ClientScalarWhereInput>
}

export type ClientUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
}

export type ClientUpdateManyWithWhereNestedInput = {
  where: ClientScalarWhereInput
  data: ClientUpdateManyDataInput
}

export type ClientUpsertWithWhereUniqueWithoutWorkspaceInput = {
  where: ClientWhereUniqueInput
  update: ClientUpdateWithoutWorkspaceDataInput
  create: ClientCreateWithoutWorkspaceInput
}

export type ClientUpdateManyWithoutWorkspaceInput = {
  create?: Enumerable<ClientCreateWithoutWorkspaceInput>
  connect?: Enumerable<ClientWhereUniqueInput>
  set?: Enumerable<ClientWhereUniqueInput>
  disconnect?: Enumerable<ClientWhereUniqueInput>
  delete?: Enumerable<ClientWhereUniqueInput>
  update?: Enumerable<ClientUpdateWithWhereUniqueWithoutWorkspaceInput>
  updateMany?: Enumerable<ClientUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<ClientScalarWhereInput>
  upsert?: Enumerable<ClientUpsertWithWhereUniqueWithoutWorkspaceInput>
  connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceUpdateWithoutCandidatesDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  users?: UserUpdateManyWithoutWorkspacesInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpsertWithoutCandidatesInput = {
  update: WorkspaceUpdateWithoutCandidatesDataInput
  create: WorkspaceCreateWithoutCandidatesInput
}

export type WorkspaceUpdateOneRequiredWithoutCandidatesInput = {
  create?: WorkspaceCreateWithoutCandidatesInput
  connect?: WorkspaceWhereUniqueInput
  update?: WorkspaceUpdateWithoutCandidatesDataInput
  upsert?: WorkspaceUpsertWithoutCandidatesInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutCandidateInput
}

export type CandidateUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  firstName?: string | null
  lastName?: string | null
  headline?: string | null
  emails?: CandidateUpdateemailsInput
  links?: CandidateUpdatelinksInput
  phones?: CandidateUpdatephonesInput
  workspace?: WorkspaceUpdateOneRequiredWithoutCandidatesInput | null
  tags?: TagUpdateManyWithoutCandidatesInput | null
  applications?: ApplicationUpdateManyWithoutCandidateInput | null
  fields?: FieldValueUpdateManyWithoutCandidateInput | null
}

export type CandidateUpsertWithoutNodeInput = {
  update: CandidateUpdateWithoutNodeDataInput
  create: CandidateCreateWithoutNodeInput
}

export type CandidateUpdateOneWithoutNodeInput = {
  create?: CandidateCreateWithoutNodeInput
  connect?: CandidateWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: CandidateUpdateWithoutNodeDataInput
  upsert?: CandidateUpsertWithoutNodeInput
  connectOrCreate?: CandidateCreateOrConnectWithoutNodeInput
}

export type NodeUpdateWithoutUserDataInput = {
  id?: string
  client?: ClientUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutUserInput = {
  update: NodeUpdateWithoutUserDataInput
  create: NodeCreateWithoutUserInput
}

export type NodeUpdateOneRequiredWithoutUserInput = {
  create?: NodeCreateWithoutUserInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutUserDataInput
  upsert?: NodeUpsertWithoutUserInput
  connectOrCreate?: NodeCreateOrConnectWithoutUserInput
}

export type UserUpdateWithoutWorkspacesDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  email?: string
  avatarUrl?: string | null
  node?: NodeUpdateOneRequiredWithoutUserInput | null
  comments?: CommentUpdateManyWithoutAuthorInput | null
  reviews?: ReviewUpdateManyWithoutAuthorInput | null
  appointments?: AppointmentUpdateManyWithoutOwnerInput | null
}

export type UserUpdateWithWhereUniqueWithoutWorkspacesInput = {
  where: UserWhereUniqueInput
  data: UserUpdateWithoutWorkspacesDataInput
}

export type UserScalarWhereInput = {
  id?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  email?: string | StringFilter
  avatarUrl?: string | NullableStringFilter | null
  workspaces?: WorkspaceFilter | null
  comments?: CommentFilter | null
  reviews?: ReviewFilter | null
  appointments?: AppointmentFilter | null
  AND?: Enumerable<UserScalarWhereInput>
  OR?: Array<UserScalarWhereInput>
  NOT?: Enumerable<UserScalarWhereInput>
}

export type UserUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  email?: string
  avatarUrl?: string | null
}

export type UserUpdateManyWithWhereNestedInput = {
  where: UserScalarWhereInput
  data: UserUpdateManyDataInput
}

export type UserUpsertWithWhereUniqueWithoutWorkspacesInput = {
  where: UserWhereUniqueInput
  update: UserUpdateWithoutWorkspacesDataInput
  create: UserCreateWithoutWorkspacesInput
}

export type UserUpdateManyWithoutWorkspacesInput = {
  create?: Enumerable<UserCreateWithoutWorkspacesInput>
  connect?: Enumerable<UserWhereUniqueInput>
  set?: Enumerable<UserWhereUniqueInput>
  disconnect?: Enumerable<UserWhereUniqueInput>
  delete?: Enumerable<UserWhereUniqueInput>
  update?: Enumerable<UserUpdateWithWhereUniqueWithoutWorkspacesInput>
  updateMany?: Enumerable<UserUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<UserScalarWhereInput>
  upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutWorkspacesInput>
  connectOrCreate?: Enumerable<UserCreateOrConnectWithoutWorkspaceInput>
}

export type WorkspaceUpdateWithoutClientsDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  users?: UserUpdateManyWithoutWorkspacesInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpsertWithoutClientsInput = {
  update: WorkspaceUpdateWithoutClientsDataInput
  create: WorkspaceCreateWithoutClientsInput
}

export type WorkspaceUpdateOneRequiredWithoutClientsInput = {
  create?: WorkspaceCreateWithoutClientsInput
  connect?: WorkspaceWhereUniqueInput
  update?: WorkspaceUpdateWithoutClientsDataInput
  upsert?: WorkspaceUpsertWithoutClientsInput
  connectOrCreate?: WorkspaceCreateOrConnectWithoutClientInput
}

export type ClientUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  workspace?: WorkspaceUpdateOneRequiredWithoutClientsInput | null
  jobs?: JobUpdateManyWithoutClientInput | null
}

export type ClientUpsertWithoutNodeInput = {
  update: ClientUpdateWithoutNodeDataInput
  create: ClientCreateWithoutNodeInput
}

export type ClientUpdateOneWithoutNodeInput = {
  create?: ClientCreateWithoutNodeInput
  connect?: ClientWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: ClientUpdateWithoutNodeDataInput
  upsert?: ClientUpsertWithoutNodeInput
  connectOrCreate?: ClientCreateOrConnectWithoutNodeInput
}

export type NodeUpdateWithoutWorkspaceDataInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  client?: ClientUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
}

export type NodeUpsertWithoutWorkspaceInput = {
  update: NodeUpdateWithoutWorkspaceDataInput
  create: NodeCreateWithoutWorkspaceInput
}

export type NodeUpdateOneRequiredWithoutWorkspaceInput = {
  create?: NodeCreateWithoutWorkspaceInput
  connect?: NodeWhereUniqueInput
  update?: NodeUpdateWithoutWorkspaceDataInput
  upsert?: NodeUpsertWithoutWorkspaceInput
  connectOrCreate?: NodeCreateOrConnectWithoutWorkspaceInput
}

export type WorkspaceUpdateWithoutUsersDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpdateWithWhereUniqueWithoutUsersInput = {
  where: WorkspaceWhereUniqueInput
  data: WorkspaceUpdateWithoutUsersDataInput
}

export type WorkspaceScalarWhereInput = {
  id?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  name?: string | StringFilter
  description?: string | NullableStringFilter | null
  website?: string | NullableStringFilter | null
  type?: WorkspaceType | WorkspaceTypeFilter
  users?: UserFilter | null
  clients?: ClientFilter | null
  candidates?: CandidateFilter | null
  applications?: ApplicationFilter | null
  job?: JobFilter | null
  tags?: TagFilter | null
  sources?: SourceFilter | null
  comments?: CommentFilter | null
  pipelines?: PipelineFilter | null
  stages?: StageFilter | null
  locations?: LocationFilter | null
  reviews?: ReviewFilter | null
  event?: EventFilter | null
  appointment?: AppointmentFilter | null
  notification?: NotificationFilter | null
  fields?: FieldDefinitionFilter | null
  AND?: Enumerable<WorkspaceScalarWhereInput>
  OR?: Array<WorkspaceScalarWhereInput>
  NOT?: Enumerable<WorkspaceScalarWhereInput>
}

export type WorkspaceUpdateManyDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
}

export type WorkspaceUpdateManyWithWhereNestedInput = {
  where: WorkspaceScalarWhereInput
  data: WorkspaceUpdateManyDataInput
}

export type WorkspaceUpsertWithWhereUniqueWithoutUsersInput = {
  where: WorkspaceWhereUniqueInput
  update: WorkspaceUpdateWithoutUsersDataInput
  create: WorkspaceCreateWithoutUsersInput
}

export type WorkspaceUpdateManyWithoutUsersInput = {
  create?: Enumerable<WorkspaceCreateWithoutUsersInput>
  connect?: Enumerable<WorkspaceWhereUniqueInput>
  set?: Enumerable<WorkspaceWhereUniqueInput>
  disconnect?: Enumerable<WorkspaceWhereUniqueInput>
  delete?: Enumerable<WorkspaceWhereUniqueInput>
  update?: Enumerable<WorkspaceUpdateWithWhereUniqueWithoutUsersInput>
  updateMany?: Enumerable<WorkspaceUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<WorkspaceScalarWhereInput>
  upsert?: Enumerable<WorkspaceUpsertWithWhereUniqueWithoutUsersInput>
  connectOrCreate?: Enumerable<WorkspaceCreateOrConnectWithoutUserInput>
}

export type UserUpdateWithoutNodeDataInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  email?: string
  avatarUrl?: string | null
  workspaces?: WorkspaceUpdateManyWithoutUsersInput | null
  comments?: CommentUpdateManyWithoutAuthorInput | null
  reviews?: ReviewUpdateManyWithoutAuthorInput | null
  appointments?: AppointmentUpdateManyWithoutOwnerInput | null
}

export type UserUpsertWithoutNodeInput = {
  update: UserUpdateWithoutNodeDataInput
  create: UserCreateWithoutNodeInput
}

export type UserUpdateOneWithoutNodeInput = {
  create?: UserCreateWithoutNodeInput
  connect?: UserWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: UserUpdateWithoutNodeDataInput
  upsert?: UserUpsertWithoutNodeInput
  connectOrCreate?: UserCreateOrConnectWithoutNodeInput
}

export type NodeUpdateInput = {
  id?: string
  user?: UserUpdateOneWithoutNodeInput | null
  client?: ClientUpdateOneWithoutNodeInput | null
  candidate?: CandidateUpdateOneWithoutNodeInput | null
  application?: ApplicationUpdateOneWithoutNodeInput | null
  job?: JobUpdateOneWithoutNodeInput | null
  tag?: TagUpdateOneWithoutNodeInput | null
  comment?: CommentUpdateOneWithoutNodeInput | null
  source?: SourceUpdateOneWithoutNodeInput | null
  pipeline?: PipelineUpdateOneWithoutNodeInput | null
  stage?: StageUpdateOneWithoutNodeInput | null
  location?: LocationUpdateOneWithoutNodeInput | null
  review?: ReviewUpdateOneWithoutNodeInput | null
  event?: EventUpdateOneWithoutNodeInput | null
  appointment?: AppointmentUpdateOneWithoutNodeInput | null
  notification?: NotificationUpdateOneWithoutNodeInput | null
  field?: FieldDefinitionUpdateOneWithoutNodeInput | null
  workspace?: WorkspaceUpdateOneWithoutNodeInput | null
}

export type NodeUpdateManyMutationInput = {
  id?: string
}

export type WorkspaceCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node: NodeCreateOneWithoutWorkspaceInput
  users?: UserCreateManyWithoutWorkspacesInput | null
  clients?: ClientCreateManyWithoutWorkspaceInput | null
  candidates?: CandidateCreateManyWithoutWorkspaceInput | null
  applications?: ApplicationCreateManyWithoutWorkspaceInput | null
  job?: JobCreateManyWithoutWorkspaceInput | null
  tags?: TagCreateManyWithoutWorkspaceInput | null
  sources?: SourceCreateManyWithoutWorkspaceInput | null
  comments?: CommentCreateManyWithoutWorkspaceInput | null
  pipelines?: PipelineCreateManyWithoutWorkspaceInput | null
  stages?: StageCreateManyWithoutWorkspaceInput | null
  locations?: LocationCreateManyWithoutWorkspaceInput | null
  reviews?: ReviewCreateManyWithoutWorkspaceInput | null
  event?: EventCreateManyWithoutWorkspaceInput | null
  appointment?: AppointmentCreateManyWithoutWorkspaceInput | null
  notification?: NotificationCreateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionCreateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
  node?: NodeUpdateOneRequiredWithoutWorkspaceInput | null
  users?: UserUpdateManyWithoutWorkspacesInput | null
  clients?: ClientUpdateManyWithoutWorkspaceInput | null
  candidates?: CandidateUpdateManyWithoutWorkspaceInput | null
  applications?: ApplicationUpdateManyWithoutWorkspaceInput | null
  job?: JobUpdateManyWithoutWorkspaceInput | null
  tags?: TagUpdateManyWithoutWorkspaceInput | null
  sources?: SourceUpdateManyWithoutWorkspaceInput | null
  comments?: CommentUpdateManyWithoutWorkspaceInput | null
  pipelines?: PipelineUpdateManyWithoutWorkspaceInput | null
  stages?: StageUpdateManyWithoutWorkspaceInput | null
  locations?: LocationUpdateManyWithoutWorkspaceInput | null
  reviews?: ReviewUpdateManyWithoutWorkspaceInput | null
  event?: EventUpdateManyWithoutWorkspaceInput | null
  appointment?: AppointmentUpdateManyWithoutWorkspaceInput | null
  notification?: NotificationUpdateManyWithoutWorkspaceInput | null
  fields?: FieldDefinitionUpdateManyWithoutWorkspaceInput | null
}

export type WorkspaceUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  website?: string | null
  type?: WorkspaceType
}

export type UserCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  email: string
  avatarUrl?: string | null
  node: NodeCreateOneWithoutUserInput
  workspaces?: WorkspaceCreateManyWithoutUsersInput | null
  comments?: CommentCreateManyWithoutAuthorInput | null
  reviews?: ReviewCreateManyWithoutAuthorInput | null
  appointments?: AppointmentCreateManyWithoutOwnerInput | null
}

export type UserUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  email?: string
  avatarUrl?: string | null
  node?: NodeUpdateOneRequiredWithoutUserInput | null
  workspaces?: WorkspaceUpdateManyWithoutUsersInput | null
  comments?: CommentUpdateManyWithoutAuthorInput | null
  reviews?: ReviewUpdateManyWithoutAuthorInput | null
  appointments?: AppointmentUpdateManyWithoutOwnerInput | null
}

export type UserUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  email?: string
  avatarUrl?: string | null
}

export type PipelineCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutPipelineInput
  workspace: WorkspaceCreateOneWithoutPipelinesInput
  stages?: StageCreateManyWithoutPipelineInput | null
}

export type PipelineUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutPipelineInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutPipelinesInput | null
  stages?: StageUpdateManyWithoutPipelineInput | null
}

export type PipelineUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
}

export type StageCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutStageInput
  workspace: WorkspaceCreateOneWithoutStagesInput
  pipeline: PipelineCreateOneWithoutStagesInput
  applications?: ApplicationCreateManyWithoutStageInput | null
  reviews?: ReviewCreateManyWithoutStageInput | null
}

export type StageUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutStageInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutStagesInput | null
  pipeline?: PipelineUpdateOneRequiredWithoutStagesInput | null
  applications?: ApplicationUpdateManyWithoutStageInput | null
  reviews?: ReviewUpdateManyWithoutStageInput | null
}

export type StageUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
}

export type ReviewCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string | null
  score?: number | null
  node: NodeCreateOneWithoutReviewInput
  workspace: WorkspaceCreateOneWithoutReviewsInput
  author: UserCreateOneWithoutReviewsInput
  application: ApplicationCreateOneWithoutReviewsInput
  stage?: StageCreateOneWithoutReviewsInput | null
}

export type ReviewUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string | null
  score?: number | null
  node?: NodeUpdateOneRequiredWithoutReviewInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutReviewsInput | null
  author?: UserUpdateOneRequiredWithoutReviewsInput | null
  application?: ApplicationUpdateOneRequiredWithoutReviewsInput | null
  stage?: StageUpdateOneWithoutReviewsInput | null
}

export type ReviewUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string | null
  score?: number | null
}

export type ClientCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  node: NodeCreateOneWithoutClientInput
  workspace: WorkspaceCreateOneWithoutClientsInput
  jobs?: JobCreateManyWithoutClientInput | null
}

export type ClientUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  node?: NodeUpdateOneRequiredWithoutClientInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutClientsInput | null
  jobs?: JobUpdateManyWithoutClientInput | null
}

export type ClientUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
}

export type CandidateCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  firstName?: string | null
  lastName?: string | null
  headline?: string | null
  emails?: CandidateCreateemailsInput
  links?: CandidateCreatelinksInput
  phones?: CandidateCreatephonesInput
  node: NodeCreateOneWithoutCandidateInput
  workspace: WorkspaceCreateOneWithoutCandidatesInput
  tags?: TagCreateManyWithoutCandidatesInput | null
  applications?: ApplicationCreateManyWithoutCandidateInput | null
  fields?: FieldValueCreateManyWithoutCandidateInput | null
}

export type CandidateUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  firstName?: string | null
  lastName?: string | null
  headline?: string | null
  emails?: CandidateUpdateemailsInput
  links?: CandidateUpdatelinksInput
  phones?: CandidateUpdatephonesInput
  node?: NodeUpdateOneRequiredWithoutCandidateInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutCandidatesInput | null
  tags?: TagUpdateManyWithoutCandidatesInput | null
  applications?: ApplicationUpdateManyWithoutCandidateInput | null
  fields?: FieldValueUpdateManyWithoutCandidateInput | null
}

export type CandidateUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  firstName?: string | null
  lastName?: string | null
  headline?: string | null
  emails?: CandidateUpdateemailsInput
  links?: CandidateUpdatelinksInput
  phones?: CandidateUpdatephonesInput
}

export type FieldDefinitionCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  type: FieldType
  node: NodeCreateOneWithoutFieldInput
  workspace: WorkspaceCreateOneWithoutFieldsInput
  values?: FieldValueCreateManyWithoutDefinitionInput | null
}

export type FieldDefinitionUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  type?: FieldType
  node?: NodeUpdateOneRequiredWithoutFieldInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutFieldsInput | null
  values?: FieldValueUpdateManyWithoutDefinitionInput | null
}

export type FieldDefinitionUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  type?: FieldType
}

export type FieldValueCreateInput = {
  value: InputJsonValue
  definition: FieldDefinitionCreateOneWithoutValuesInput
  candidate: CandidateCreateOneWithoutFieldsInput
}

export type FieldValueUpdateInput = {
  value?: InputJsonValue
  definition?: FieldDefinitionUpdateOneRequiredWithoutValuesInput | null
  candidate?: CandidateUpdateOneRequiredWithoutFieldsInput | null
}

export type FieldValueUpdateManyMutationInput = {
  value?: InputJsonValue
}

export type ApplicationCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutApplicationInput
  workspace: WorkspaceCreateOneWithoutApplicationsInput
  job: JobCreateOneWithoutApplicationsInput
  candidate: CandidateCreateOneWithoutApplicationsInput
  source: SourceCreateOneWithoutApplicationsInput
  stage: StageCreateOneWithoutApplicationsInput
  reviews?: ReviewCreateManyWithoutApplicationInput | null
}

export type ApplicationUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutApplicationInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutApplicationsInput | null
  job?: JobUpdateOneRequiredWithoutApplicationsInput | null
  candidate?: CandidateUpdateOneRequiredWithoutApplicationsInput | null
  source?: SourceUpdateOneRequiredWithoutApplicationsInput | null
  stage?: StageUpdateOneRequiredWithoutApplicationsInput | null
  reviews?: ReviewUpdateManyWithoutApplicationInput | null
}

export type ApplicationUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
}

export type JobCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  status: JobStatus
  node: NodeCreateOneWithoutJobInput
  workspace: WorkspaceCreateOneWithoutJobInput
  client: ClientCreateOneWithoutJobsInput
  applications?: ApplicationCreateManyWithoutJobInput | null
  locations?: LocationCreateManyWithoutJobsInput | null
}

export type JobUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  status?: JobStatus
  node?: NodeUpdateOneRequiredWithoutJobInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutJobInput | null
  client?: ClientUpdateOneRequiredWithoutJobsInput | null
  applications?: ApplicationUpdateManyWithoutJobInput | null
  locations?: LocationUpdateManyWithoutJobsInput | null
}

export type JobUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  status?: JobStatus
}

export type LocationCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string | null
  description?: string | null
  country: string
  city?: string | null
  node: NodeCreateOneWithoutLocationInput
  workspace: WorkspaceCreateOneWithoutLocationsInput
  jobs?: JobCreateManyWithoutLocationsInput | null
}

export type LocationUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string | null
  description?: string | null
  country?: string
  city?: string | null
  node?: NodeUpdateOneRequiredWithoutLocationInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutLocationsInput | null
  jobs?: JobUpdateManyWithoutLocationsInput | null
}

export type LocationUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string | null
  description?: string | null
  country?: string
  city?: string | null
}

export type TagCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  types?: TagCreatetypesInput
  node: NodeCreateOneWithoutTagInput
  workspace: WorkspaceCreateOneWithoutTagsInput
  candidates?: CandidateCreateManyWithoutTagsInput | null
}

export type TagUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  types?: TagUpdatetypesInput
  node?: NodeUpdateOneRequiredWithoutTagInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutTagsInput | null
  candidates?: CandidateUpdateManyWithoutTagsInput | null
}

export type TagUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  types?: TagUpdatetypesInput
}

export type SourceCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  node: NodeCreateOneWithoutSourceInput
  workspace: WorkspaceCreateOneWithoutSourcesInput
  applications?: ApplicationCreateManyWithoutSourceInput | null
}

export type SourceUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  node?: NodeUpdateOneRequiredWithoutSourceInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutSourcesInput | null
  applications?: ApplicationUpdateManyWithoutSourceInput | null
}

export type SourceUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
}

export type CommentCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message: string
  node: NodeCreateOneWithoutCommentInput
  workspace: WorkspaceCreateOneWithoutCommentsInput
  author: UserCreateOneWithoutCommentsInput
  parent?: CommentCreateOneWithoutRepliesInput | null
  replies?: CommentCreateManyWithoutParentInput | null
}

export type CommentUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string
  node?: NodeUpdateOneRequiredWithoutCommentInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutCommentsInput | null
  author?: UserUpdateOneRequiredWithoutCommentsInput | null
  parent?: CommentUpdateOneWithoutRepliesInput | null
  replies?: CommentUpdateManyWithoutParentInput | null
}

export type CommentUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  message?: string
}

export type AppointmentCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name: string
  description?: string | null
  node: NodeCreateOneWithoutAppointmentInput
  workspace: WorkspaceCreateOneWithoutAppointmentInput
  owner: UserCreateOneWithoutAppointmentsInput
}

export type AppointmentUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
  node?: NodeUpdateOneRequiredWithoutAppointmentInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutAppointmentInput | null
  owner?: UserUpdateOneRequiredWithoutAppointmentsInput | null
}

export type AppointmentUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  name?: string
  description?: string | null
}

export type EventCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutEventInput
  workspace: WorkspaceCreateOneWithoutEventInput
}

export type EventUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutEventInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutEventInput | null
}

export type EventUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
}

export type NotificationCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node: NodeCreateOneWithoutNotificationInput
  workspace: WorkspaceCreateOneWithoutNotificationInput
}

export type NotificationUpdateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  node?: NodeUpdateOneRequiredWithoutNotificationInput | null
  workspace?: WorkspaceUpdateOneRequiredWithoutNotificationInput | null
}

export type NotificationUpdateManyMutationInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
}

export type StringFilter = {
  equals?: string
  not?: string | StringFilter
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
}

export type DateTimeFilter = {
  equals?: Date | string
  not?: Date | string | DateTimeFilter
  in?: Enumerable<Date | string>
  notIn?: Enumerable<Date | string>
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
}

export type NullableDateTimeFilter = {
  equals?: Date | string | null
  not?: Date | string | null | NullableDateTimeFilter
  in?: Enumerable<Date | string> | null
  notIn?: Enumerable<Date | string> | null
  lt?: Date | string | null
  lte?: Date | string | null
  gt?: Date | string | null
  gte?: Date | string | null
}

export type NullableStringFilter = {
  equals?: string | null
  not?: string | null | NullableStringFilter
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
}

export type CandidateFilter = {
  every?: CandidateWhereInput
  some?: CandidateWhereInput
  none?: CandidateWhereInput
}

export type FieldTypeFilter = {
  equals?: FieldType
  not?: FieldType | FieldTypeFilter
  in?: Enumerable<FieldType>
  notIn?: Enumerable<FieldType>
}

export type FieldValueFilter = {
  every?: FieldValueWhereInput
  some?: FieldValueWhereInput
  none?: FieldValueWhereInput
}

export type JsonFilter = {
  equals?: InputJsonValue
  not?: InputJsonValue | JsonFilter
}

export type TagFilter = {
  every?: TagWhereInput
  some?: TagWhereInput
  none?: TagWhereInput
}

export type ApplicationFilter = {
  every?: ApplicationWhereInput
  some?: ApplicationWhereInput
  none?: ApplicationWhereInput
}

export type StageFilter = {
  every?: StageWhereInput
  some?: StageWhereInput
  none?: StageWhereInput
}

export type NullableIntFilter = {
  equals?: number | null
  not?: number | null | NullableIntFilter
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
}

export type ReviewFilter = {
  every?: ReviewWhereInput
  some?: ReviewWhereInput
  none?: ReviewWhereInput
}

export type JobFilter = {
  every?: JobWhereInput
  some?: JobWhereInput
  none?: JobWhereInput
}

export type JobStatusFilter = {
  equals?: JobStatus
  not?: JobStatus | JobStatusFilter
  in?: Enumerable<JobStatus>
  notIn?: Enumerable<JobStatus>
}

export type LocationFilter = {
  every?: LocationWhereInput
  some?: LocationWhereInput
  none?: LocationWhereInput
}

export type CommentFilter = {
  every?: CommentWhereInput
  some?: CommentWhereInput
  none?: CommentWhereInput
}

export type WorkspaceTypeFilter = {
  equals?: WorkspaceType
  not?: WorkspaceType | WorkspaceTypeFilter
  in?: Enumerable<WorkspaceType>
  notIn?: Enumerable<WorkspaceType>
}

export type UserFilter = {
  every?: UserWhereInput
  some?: UserWhereInput
  none?: UserWhereInput
}

export type ClientFilter = {
  every?: ClientWhereInput
  some?: ClientWhereInput
  none?: ClientWhereInput
}

export type SourceFilter = {
  every?: SourceWhereInput
  some?: SourceWhereInput
  none?: SourceWhereInput
}

export type PipelineFilter = {
  every?: PipelineWhereInput
  some?: PipelineWhereInput
  none?: PipelineWhereInput
}

export type EventFilter = {
  every?: EventWhereInput
  some?: EventWhereInput
  none?: EventWhereInput
}

export type AppointmentFilter = {
  every?: AppointmentWhereInput
  some?: AppointmentWhereInput
  none?: AppointmentWhereInput
}

export type NotificationFilter = {
  every?: NotificationWhereInput
  some?: NotificationWhereInput
  none?: NotificationWhereInput
}

export type FieldDefinitionFilter = {
  every?: FieldDefinitionWhereInput
  some?: FieldDefinitionWhereInput
  none?: FieldDefinitionWhereInput
}

export type WorkspaceFilter = {
  every?: WorkspaceWhereInput
  some?: WorkspaceWhereInput
  none?: WorkspaceWhereInput
}

export type UUIDFilter = {
  equals?: string
  not?: string | UUIDFilter
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
}

export type NodeOrderByInput = {
  id?: OrderByArg | null
}

export type WorkspaceOrderByInput = {
  id?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
  name?: OrderByArg | null
  description?: OrderByArg | null
  website?: OrderByArg | null
  type?: OrderByArg | null
}

export type UserOrderByInput = {
  id?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
  email?: OrderByArg | null
  avatarUrl?: OrderByArg | null
}

export type ClientOrderByInput = {
  id?: OrderByArg | null
  wid?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
  name?: OrderByArg | null
  description?: OrderByArg | null
}

export type JobOrderByInput = {
  id?: OrderByArg | null
  wid?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
  name?: OrderByArg | null
  description?: OrderByArg | null
  status?: OrderByArg | null
  clientId?: OrderByArg | null
}

export type ApplicationOrderByInput = {
  id?: OrderByArg | null
  wid?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
  jobId?: OrderByArg | null
  candidateId?: OrderByArg | null
  sourceId?: OrderByArg | null
  stageId?: OrderByArg | null
}

export type TagOrderByInput = {
  id?: OrderByArg | null
  wid?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
  name?: OrderByArg | null
  description?: OrderByArg | null
}

export type CandidateOrderByInput = {
  id?: OrderByArg | null
  wid?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
  firstName?: OrderByArg | null
  lastName?: OrderByArg | null
  headline?: OrderByArg | null
}

export type FieldValueOrderByInput = {
  value?: OrderByArg | null
  definitionId?: OrderByArg | null
  candidateId?: OrderByArg | null
}

export type StageOrderByInput = {
  id?: OrderByArg | null
  wid?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
  pipelineId?: OrderByArg | null
}

export type ReviewOrderByInput = {
  id?: OrderByArg | null
  wid?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
  message?: OrderByArg | null
  score?: OrderByArg | null
  authorId?: OrderByArg | null
  applicationId?: OrderByArg | null
  stageId?: OrderByArg | null
}

export type LocationOrderByInput = {
  id?: OrderByArg | null
  wid?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
  name?: OrderByArg | null
  description?: OrderByArg | null
  country?: OrderByArg | null
  city?: OrderByArg | null
}

export type SourceOrderByInput = {
  id?: OrderByArg | null
  wid?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
  name?: OrderByArg | null
  description?: OrderByArg | null
}

export type CommentOrderByInput = {
  id?: OrderByArg | null
  wid?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
  message?: OrderByArg | null
  authorId?: OrderByArg | null
  parentId?: OrderByArg | null
}

export type PipelineOrderByInput = {
  id?: OrderByArg | null
  wid?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
}

export type EventOrderByInput = {
  id?: OrderByArg | null
  wid?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
}

export type AppointmentOrderByInput = {
  id?: OrderByArg | null
  wid?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
  name?: OrderByArg | null
  description?: OrderByArg | null
  ownerId?: OrderByArg | null
}

export type NotificationOrderByInput = {
  id?: OrderByArg | null
  wid?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
}

export type FieldDefinitionOrderByInput = {
  id?: OrderByArg | null
  wid?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
  name?: OrderByArg | null
  type?: OrderByArg | null
}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
